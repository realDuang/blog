<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://blog.realduang.com/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://blog.realduang.com/</id>
  <title>枫之谷</title>
  <subtitle>这个人很懒，但还是想留下些什么东西。</subtitle>
  <updated>2024-12-02T12:17:07.078Z</updated>
  <generator>@vuepress/plugin-feed</generator>
  <link rel="self" href="https://blog.realduang.com/atom.xml"/>
  <link rel="alternate" href="https://blog.realduang.com/"/>
  <category term="架构设计"/>
  <category term="前端基础"/>
  <category term="前端技术研究院"/>
  <category term="机器学习"/>
  <category term="其他"/>
  <category term="VSCode For Web 深入浅出"/>
  <entry>
    <title type="text">利用 kafka 做一个上报服务</title>
    <id>https://blog.realduang.com/draft/2021-05-07.html</id>
    <link href="https://blog.realduang.com/draft/2021-05-07.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<p>Kafka 是一个目前由 Apache 软件基金会接管的一个开源流处理平台，是一种高吞吐量的基于发布-订阅模式的分布式日志收集和消息系统，它能通过 O(1) 的磁盘数据结构提供消息的持久化，使得其读写性能十分优异。</p>
<h2>Kafka 概念介绍</h2>
<p>首先，Kafka 作为一个基于发布订阅模式的消息系统，一定少不了生产者 (producer) 与消费者 (consumer) 作为链路的两端。除此之外，Kafka 中还提出了一些特性，正是这些特性帮助我们解耦消息队列的处理过程，并增强其可扩展能力。</p>
<p>其架构链路图如下：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/kafka20210513113211.png" alt="kafka"></p>]]></summary>
    <content type="html"><![CDATA[<p>Kafka 是一个目前由 Apache 软件基金会接管的一个开源流处理平台，是一种高吞吐量的基于发布-订阅模式的分布式日志收集和消息系统，它能通过 O(1) 的磁盘数据结构提供消息的持久化，使得其读写性能十分优异。</p>
<h2>Kafka 概念介绍</h2>
<p>首先，Kafka 作为一个基于发布订阅模式的消息系统，一定少不了生产者 (producer) 与消费者 (consumer) 作为链路的两端。除此之外，Kafka 中还提出了一些特性，正是这些特性帮助我们解耦消息队列的处理过程，并增强其可扩展能力。</p>
<p>其架构链路图如下：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/kafka20210513113211.png" alt="kafka"></p>
<h3>Broker</h3>
<p>Kafka 处理集群可以包含一个或多个提供消息处理的服务器节点，这些服务器节点称为 broker。Kafka 的 Broker 集群原生支持分布式，同一个集群中的节点自动实现负载均衡。</p>
<h3>Topic</h3>
<p>每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。它在逻辑上可以被认为是一个消息队列的存放单位，因此在生产与消费数据时，都需要指定 Topic。物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处。</p>
<h3>Partition</h3>
<p>每一个 Topic 的数据可以分割成一份或多份，每一份数据存放于一个 Partition 中。相较于 Topic，Partition 更偏向与物理上的概念。Partition 中的数据使用多个 segment 文件存储。在同一个 Partition 内，数据是有序的。而若在同一个 Topic 中存在多个 Partition，Cosumer 在消费时便不能保证 Partition 间数据的顺序。</p>
<p>此外，Kafka 为了实现高可用性，还对 Brokers 设计了选举淘汰机制以保证相应的唯一性，对 Producer 产生的消息进行消息路由，并对可能的产生的网络故障进行消息传递保障等等。在此不多做赘述，感兴趣的同学可以自行了解。</p>
]]></content>
    <published>2021-05-07T19:23:58.000Z</published>
  </entry>
  <entry>
    <title type="text">代码重构之我见</title>
    <id>https://blog.realduang.com/blogs/architecture/2016-10-16.html</id>
    <link href="https://blog.realduang.com/blogs/architecture/2016-10-16.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在看一些软件工程和构建方面的书籍。俗话说，书读百遍，其义自见，看得多了，自然也就有一些知识可以拿得出手分享一二了。</p>
<p>由于我在写代码的过程中往往很追求代码的优雅和简洁，因此我着重阅读了代码重构方面的知识，现在对代码的重构也算略有体会了。接下来我将结合我所吸收到的知识与我自己的一些理解和观点来阐述一下代码重构的艺术。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在看一些软件工程和构建方面的书籍。俗话说，书读百遍，其义自见，看得多了，自然也就有一些知识可以拿得出手分享一二了。</p>
<p>由于我在写代码的过程中往往很追求代码的优雅和简洁，因此我着重阅读了代码重构方面的知识，现在对代码的重构也算略有体会了。接下来我将结合我所吸收到的知识与我自己的一些理解和观点来阐述一下代码重构的艺术。</p>
</div><!-- more -->
]]></content>
    <category term="架构设计"/>
    <published>2016-10-16T20:41:33.000Z</published>
  </entry>
  <entry>
    <title type="text">设计模式的 js 实现 (1)--单例模式</title>
    <id>https://blog.realduang.com/blogs/architecture/2019-09-20.html</id>
    <link href="https://blog.realduang.com/blogs/architecture/2019-09-20.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>在所有设计模式中，最基础同时也非常实用的一类就是单例模式了。单例模式，顾名思义，指的是在此种设计模式下，整个系统将只会构建一次实例，接下来每一次的新的生成都视为对第一次生成实例的引用。</p>
<p>其实，单例模式在我们的项目中运用的十分广泛，例如浏览器的全局变量 window 就是一个例子，所有声明的全局变量都要挂靠在 window 下，并且 window 变量只生成一次，全局都能够调用。再比如一些一些需要保持唯一性的组件，例如顶部提示框、对话框、抽屉组件等等，也都可以用单例模式来解决。</p>
]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>在所有设计模式中，最基础同时也非常实用的一类就是单例模式了。单例模式，顾名思义，指的是在此种设计模式下，整个系统将只会构建一次实例，接下来每一次的新的生成都视为对第一次生成实例的引用。</p>
<p>其实，单例模式在我们的项目中运用的十分广泛，例如浏览器的全局变量 window 就是一个例子，所有声明的全局变量都要挂靠在 window 下，并且 window 变量只生成一次，全局都能够调用。再比如一些一些需要保持唯一性的组件，例如顶部提示框、对话框、抽屉组件等等，也都可以用单例模式来解决。</p>
<!-- more -->
<h2>基础实现</h2>
<p>接下来我们尝试着来实现一下单例模式的构造函数。假设我们现在想实现一个单例的顶部提示框组件，简单展示如下：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Notification</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了实现所需的目标，我们需要为该类增添一个获取单例实例的函数 getInstance。先定义一个标志位记录生成的实例，每次调用时检查，若未实例化则生成一个实例，否则返回之前生成实例的引用。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>Notification<span class="token punctuation">.</span><span class="token function-variable function">getInstance</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若未生成过实例，则实例化该方法，并将实例引用赋值给一个属性，之后返回该属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Notification<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Notification<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Notification<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> Notification<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> Notification<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>这样就实现了这个组件的单例化。</p>
<h2>能不能更通用</h2>
<p>上面这个例子能够实现所需要的目标，但是代码过于耦合，且不方便复用。我们可以考虑使用更通用的方法来实现这一目标。比如我们可以将单例逻辑抽离出来，在原组件外层包裹一个用于生成单例的函数，返回一个功能相同，但拥有单例功能的新组件。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Singleton</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">Class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> SingleNotification <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>Notification<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleNotification</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleNotification</span><span class="token punctuation">(</span><span class="token string">"warning"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "info"</span>

b<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">"warning"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "warning"</span>
</code></pre></div><p>这样就实现了单例逻辑与实际功能组件的解耦。这里实际上用到了装饰器模式的一些思想，关于装饰器模式我们留到下一节说。</p>
]]></content>
    <category term="架构设计"/>
    <published>2019-09-20T16:58:52.000Z</published>
  </entry>
  <entry>
    <title type="text">设计模式的 js 实现 (2)--装饰器模式</title>
    <id>https://blog.realduang.com/blogs/architecture/2019-09-23.html</id>
    <link href="https://blog.realduang.com/blogs/architecture/2019-09-23.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>上一篇中我们提到了装饰器模式，这也是一种非常实用的设计模式，主要的特点是非侵入式，能让组件功能能被更好的解耦和复用，解决了不同组件之间共享某些相同功能的难题。有时候我们并不关心函数的内部实现，仅仅想做功能增强，装饰器模式就能给我们带来良好的可读性的同时，减少我们修改需求的成本。</p>
<p>在 js 中，我们可以构造一个装饰器函数，接收任何一个组件函数，返回一个增强功能的新组件，原组件其他功能不受影响，并且当该增强功能不再使用时，只需要在调用处去除包裹的装饰器函数即可，这样可插拔式的功能体验可使得代码变得简单而优雅。</p>
]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>上一篇中我们提到了装饰器模式，这也是一种非常实用的设计模式，主要的特点是非侵入式，能让组件功能能被更好的解耦和复用，解决了不同组件之间共享某些相同功能的难题。有时候我们并不关心函数的内部实现，仅仅想做功能增强，装饰器模式就能给我们带来良好的可读性的同时，减少我们修改需求的成本。</p>
<p>在 js 中，我们可以构造一个装饰器函数，接收任何一个组件函数，返回一个增强功能的新组件，原组件其他功能不受影响，并且当该增强功能不再使用时，只需要在调用处去除包裹的装饰器函数即可，这样可插拔式的功能体验可使得代码变得简单而优雅。</p>
<!-- more -->
<h2>修饰函数的装饰器实现</h2>
<p>正是因为装饰器模式带来的种种好处，在 es7 标准中已经正式引入了装饰器特性，标志符为 <code>@</code>。我们可以设定如下情况：设计一个通用型的日志补丁，能够输出组件中某些方法的调用日志的功能，我们可以这样写：</p>
<blockquote>
<p>以下代码请务必在支持 es7 的环境下运行，如何使用请自行查阅 babel 相关文档</p>
</blockquote>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  @decorateLog
  <span class="token function">addNum</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">decorateLog</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.arguments：</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> descriptor<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> comp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> comp<span class="token punctuation">.</span><span class="token function">addNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">answer is:</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// addNum.arguments：[1, 2] answer is: 3</span>
</code></pre></div><p>不难看出，装饰器函数接收三个参数：被修饰对象，被修饰对象名，以及该对象属性描述符(参考<code>Object.defineProperty</code>中的<code>descriptor</code>属性)，返回新的被修饰对象属性描述符。</p>
<h2>修饰类的装饰器实现</h2>
<p>装饰器不仅能被用于修饰类属性，甚至能够直接修饰类本身，增强类功能。这个特性也十分实用。本质上，装饰器的行为就是一个高阶函数，其作用全等于以下用法：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">decorator</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Component <span class="token operator">=</span> <span class="token function">decorator</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span> <span class="token operator">||</span> Component<span class="token punctuation">;</span>
</code></pre></div><p>之前在写 redux 相关的文章时也顺口提到过，connect 这个高阶组件也能够用装饰器模式来实现，使得导出类变得更美观且易读。</p>
<p>这是不使用装饰器的 connect 组件写法，高阶函数显得冗长不易读，export 导出物不够明显与直观。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用装饰器后，写法变成了这样</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>@<span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>我们也参照上述写法，来实现自己的类装饰器。假设这样一种情况，我们需要对每一个类组件增添一个获取作者名的通用方法，那我们可以这样来做：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>@decorateAuthor
<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他属性</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">decorateAuthor</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getAuthor</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'synccheng'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> comp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comp<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>需要注意的一点的是，在 js 中，装饰器只能用于类和类中的方法，不能用于函数。这是因为，装饰器函数是在编译时执行，而不是在运行时执行。因此，若之间在普通函数中使用会存在函数提升的问题，即先定义函数名称，并不赋值，在被修饰函数声明时只能取到 undefined 的装饰器值，导致调用结果与预期不符。</p>
<p>总而言之，在适当的时机使用装饰器模式能帮我们得到一份优雅、易读、可插拔式的代码体验，使用装饰器模式，不需要深入理解原有的代码逻辑就能直接开发新特性，在对老代码进行功能增强的时候，有着事半功倍的效果。</p>
]]></content>
    <category term="架构设计"/>
    <published>2019-09-23T11:07:08.000Z</published>
  </entry>
  <entry>
    <title type="text">设计模式的 js 实现 (3)--观察者模式</title>
    <id>https://blog.realduang.com/blogs/architecture/2019-09-26.html</id>
    <link href="https://blog.realduang.com/blogs/architecture/2019-09-26.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>在行为型模式中，最值得我们前端学习的设计模式就是观察者模式了，也就是我们熟悉的发布-订阅模式。因为前端与用户侧强交互的需要，我们会对用户操作实现非常多的联动依赖，当页面中某个对象状态改变后，所有依赖其状态的组件都能收到通知，并相应地改变自己的状态。而这也衍生出来一种编程思想--事件驱动编程。</p>
<p>在前端中，这种思想运用的非常广泛。例如 DOM 事件监听，路由变化更新，vue 的事件机制甚至是其双向绑定原理--defineProperty 等等都是基于观察者模式实现的。</p>
]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>在行为型模式中，最值得我们前端学习的设计模式就是观察者模式了，也就是我们熟悉的发布-订阅模式。因为前端与用户侧强交互的需要，我们会对用户操作实现非常多的联动依赖，当页面中某个对象状态改变后，所有依赖其状态的组件都能收到通知，并相应地改变自己的状态。而这也衍生出来一种编程思想--事件驱动编程。</p>
<p>在前端中，这种思想运用的非常广泛。例如 DOM 事件监听，路由变化更新，vue 的事件机制甚至是其双向绑定原理--defineProperty 等等都是基于观察者模式实现的。</p>
<!-- more -->
<h2>基础实现</h2>
<p>我们可以尝试实现一个观察者模式模型。这个对象至少应该包括：一个记录所有被监听事件的映射对象 subscribersMap(其中每个属性的 value 值都应为一个订阅该事件的所有函数组成的数组 subscriber)、将订阅者添加进相应事件的 subscriber 中的订阅函数、删除某个事件中订阅者的退订函数、发布者发布时广播给所有订阅者的发布函数、以及一个获取某个事件所有订阅者的查询函数组成。简单实现如下：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">subscribersMap</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">subscribe</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">eventKey<span class="token punctuation">,</span> func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function-variable function">unSubscribe</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">eventKey<span class="token punctuation">,</span> func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> funcList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>funcList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span> <span class="token operator">=</span> funcList<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>
        <span class="token parameter">subscribeFunc</span> <span class="token operator">=&gt;</span> subscribeFunc <span class="token operator">!==</span> func
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function-variable function">publish</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">eventKey<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> funcList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>funcList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    funcList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">func</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function-variable function">getSubscribeFunc</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">eventKey</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribersMap<span class="token punctuation">[</span>eventKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">subscribeFunc</span> <span class="token operator">=</span> <span class="token parameter">answer</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"subscription update:"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
event<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"addNum"</span><span class="token punctuation">,</span> subscribeFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getSubscribeFunc</span><span class="token punctuation">(</span><span class="token string">"addNum"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ [Function: subscribeFunc] ]</span>

<span class="token comment">// 在不相关的组件内</span>
<span class="token keyword">function</span> <span class="token function">publishFunc</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> answer <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  event<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"addNum"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">publishFunc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// subscription update: 3</span>

event<span class="token punctuation">.</span><span class="token function">unSubscribe</span><span class="token punctuation">(</span><span class="token string">"addNum"</span><span class="token punctuation">,</span> subscribeFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getSubscribeFunc</span><span class="token punctuation">(</span><span class="token string">"addNum"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// []</span>
</code></pre></div><h2>总结</h2>
<p>使用观察者模式能够使得两个毫不相关的组件能够产生联动，免去了逐级传递状态信息的麻烦，并且在一对多的联动表现中优势突出。但观察者模式也有其局限性：</p>
<ol>
<li>由于其影响对象之间的关系过于松散，过度使用观察者模式将导致功能的维护以及调用栈追踪变得困难。</li>
<li>订阅者一旦使用生成订阅后，该函数就会常驻内存运行，在生命周期中并没有销毁操作，过度使用将对系统造成负荷。</li>
</ol>
<p>由此可以看出，设计模式没有银弹，我们应该正确认识到每一种设计模式带给我们的益处以及它可能为我们的项目带来的风险，在合适的地方使用合适的设计模式来解决问题。</p>
]]></content>
    <category term="架构设计"/>
    <published>2019-09-26T10:35:19.000Z</published>
  </entry>
  <entry>
    <title type="text">设计模式的 js 实现 (4)--代理模式</title>
    <id>https://blog.realduang.com/blogs/architecture/2019-10-07.html</id>
    <link href="https://blog.realduang.com/blogs/architecture/2019-10-07.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>代理模式在注重交互体验的前端应用环境中是一个十分重要的思想，有些时候，当调用方不适合直接访问一个对象的时候，代理模式可以提供出来一个替身对象来控制对这个对象的访问，当替身对象对请求做出一些处理后，再转交给目标对象。</p>
<p>根据上述定义，我们可以将代理模式分解为三种类型：虚拟代理、保护代理以及缓存代理。其中缓存代理能够为计算开销大的一些运算函数提供一层缓存，避免重复计算，多用于一些算法优化的实现，本文暂且不论，重点介绍其他两种代理模式在前端项目中的应用。</p>
]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p>
<ol>
<li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p>
</div><h2>介绍</h2>
<p>代理模式在注重交互体验的前端应用环境中是一个十分重要的思想，有些时候，当调用方不适合直接访问一个对象的时候，代理模式可以提供出来一个替身对象来控制对这个对象的访问，当替身对象对请求做出一些处理后，再转交给目标对象。</p>
<p>根据上述定义，我们可以将代理模式分解为三种类型：虚拟代理、保护代理以及缓存代理。其中缓存代理能够为计算开销大的一些运算函数提供一层缓存，避免重复计算，多用于一些算法优化的实现，本文暂且不论，重点介绍其他两种代理模式在前端项目中的应用。</p>
<!-- more -->
<h2>虚拟代理</h2>
<p>虚拟代理的应用范围非常广泛，它常用于对创建或使用时开支较大的目标对象进行代理，以达到推迟与减少资源消耗的目的。例如异步请求常用的函数节流、函数防抖、以及懒加载都可以使用此种思想。</p>
<p>我们以实现某图片懒加载来举例：</p>
<div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">body</span> <span class="token punctuation">{</span>
      <span class="token property">height</span><span class="token punctuation">:</span> 2000px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token selector">#others</span> <span class="token punctuation">{</span>
      <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
      <span class="token property">height</span><span class="token punctuation">:</span> 1000px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>others<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">function</span> <span class="token function">lazyloadImage</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> intersectionObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">entries</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 进入 viewport 后加载图片，并解除监听，防止离开 viewport 后再次触发</span>
          node<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>
          intersectionObserver<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 开始监听</span>
      intersectionObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> imgNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#img"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lazyloadImage</span><span class="token punctuation">(</span>imgNode<span class="token punctuation">,</span> <span class="token string">"https://github.com/realDuang/blog-storage/blob/master/avatar.jpg?raw=true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>又或者通过代理模式实现函数的防抖：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// leading 为是否在进入时立即执行一次</span>
<span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
  <span class="token parameter">fn<span class="token punctuation">,</span>
  time <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">,</span>
  options <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">leading</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">context</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span></span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">_debounce</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    timer <span class="token operator">&amp;&amp;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>leading <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 立即执行一次</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> _debounce<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 目标对象</span>
<span class="token keyword">const</span> <span class="token function-variable function">scrollFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> scrollTop <span class="token operator">=</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop <span class="token operator">||</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"滚动条位置："</span> <span class="token operator">+</span> scrollTop<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token comment">// 代理对象</span>
<span class="token keyword">const</span> proxyScrollFunc <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>
  scrollFunc<span class="token punctuation">,</span>
  <span class="token number">200</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">leading</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> proxyScrollFunc
</code></pre></div><h2>保护代理</h2>
<p>保护代理适用于目标对象安全要求较高，需要鉴权功能时，将所有请求汇聚到代理对象中统一进行授权与控制，再将符合要求的请求转发给目标对象。这种代理解耦了复杂鉴权控制与实际业务处理之间的联系，并且负责鉴权控制的代理模块能做到可复用，从而进一步优化代码架构。</p>
<p>能使用保护代理的情况也有很多，这里以最常见的登录验证为例。(为了更明显体现代理模式的存在，使用了 es6 规范下的 Proxy 对象特性)</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getValidatorProxy</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">validator</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">account</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\d+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">isValid</span><span class="token operator">:</span> re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token string">"账号组成必须全为数字"</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function-variable function">password</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">isValid</span><span class="token operator">:</span> value<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> <span class="token number">6</span><span class="token punctuation">,</span>
        <span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token string">"密码长度不能小于 6"</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> checkVar <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>validator<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>checkVar<span class="token punctuation">.</span>isValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">参数校验通过</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">参数校验不通过，错误原因：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>checkVar<span class="token punctuation">.</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> loginProxy <span class="token operator">=</span> <span class="token function">getValidatorProxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">account</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
  <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

loginProxy<span class="token punctuation">.</span>account <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> <span class="token comment">// account 参数校验通过</span>
loginProxy<span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> <span class="token comment">// password 参数校验不通过，错误原因：密码长度不能小于 6</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>loginProxy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { account: '123', password: '' }</span>
</code></pre></div>]]></content>
    <category term="架构设计"/>
    <published>2019-10-07T16:42:54.000Z</published>
  </entry>
  <entry>
    <title type="text">前端首屏渲染时间的极致优化</title>
    <id>https://blog.realduang.com/blogs/architecture/2022-09-08.html</id>
    <link href="https://blog.realduang.com/blogs/architecture/2022-09-08.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>我们知道，用户体验是 Web 产品最为重要的部分。尽可能减少首屏加载时间，更为流畅地展示用户所需求的内容，会是用户是否留存的关键因素。</p>
<p>而随着现代 Web 业务可供用户的交互行为越来越多，前端项目的复杂度越来越高，每个页面的渲染时间也必然越来越长，这就导致了用户的体验不佳，用户的操作变慢。</p>
<p>为此，前端工程师们在此部分持续发力，不断探究如何将首次页面渲染的时间减少到更小，提供更为优秀的产品体验。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>我们知道，用户体验是 Web 产品最为重要的部分。尽可能减少首屏加载时间，更为流畅地展示用户所需求的内容，会是用户是否留存的关键因素。</p>
<p>而随着现代 Web 业务可供用户的交互行为越来越多，前端项目的复杂度越来越高，每个页面的渲染时间也必然越来越长，这就导致了用户的体验不佳，用户的操作变慢。</p>
<p>为此，前端工程师们在此部分持续发力，不断探究如何将首次页面渲染的时间减少到更小，提供更为优秀的产品体验。</p>
</div><!-- more -->
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220722174820.png" alt="20220722174820"></p>
<p>我们知道，用户体验是 Web 产品最为重要的部分。尽可能减少首屏加载时间，更为流畅地展示用户所需求的内容，会是用户是否留存的关键因素。</p>
<p>而随着现代 Web 业务可供用户的交互行为越来越多，前端项目的复杂度越来越高，每个页面的渲染时间也必然越来越长，这就导致了用户的体验不佳，用户的操作变慢。</p>
<p>为此，前端工程师们在首屏请求的各个阶段中持续钻研，不断探究如何将首次页面渲染的时间减少到更小，力求提供更为优秀的产品体验。</p>
<h2>CSR(Client Side Render)</h2>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220720162452.png" alt="20220720162452"></p>
<p>浏览器渲染是最简单，最符合 Web 应用设计思路的渲染方式。</p>
<p>所谓浏览器渲染，就是将应用所需的页面展示、前端逻辑、接口请求全都在用户的浏览器中执行。它很好的实现了前后端的解耦，让前端开发更为独立，也让后台实现更为简单。</p>
<p>同时，为了缓解用户的等待焦虑，我们可以用 loading 态，或者骨架屏，进一步提升异步请求接口时的用户体验。</p>
<p>不过，随着业务复杂程度提高，浏览器渲染的开销也会变大，我们无法控制用户侧使用的机器性能，很多时候，用户使用的机器性能甚至不足以满足应用的需求，造成卡顿，甚至崩溃，这一点在移动端上尤甚。</p>
<p>而浏览器渲染由于前端的动态性过高，也会带来 SEO 不佳的问题。</p>
<h2>SSR(Server Side Render)</h2>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220720162513.png" alt="20220720162513"></p>
<p>服务端渲染的出现时间实际上是要比浏览器渲染要更早的。在 Web 应用发展的早期，所有的 ASP、JSP 等模板引擎构建的前端页面实际上就是服务端渲染的结果。而此时的服务端渲染无法进行前后端职责的解耦，因此逐步被浏览器渲染淘汰。</p>
<p>但在处理首屏体验的问题上，服务端渲染有着独到的优势。它能提前再服务端中完成页面模板的数据填充，从而一次性返回完整的首屏内容，从而面对 SEO 的爬取时能获取到更多有效的关键信息。</p>
<p>此外，由于其能快速直出首页的真实数据，体验往往比 loading 态更佳，在 TTI 的表现上更为出色。</p>
<p>但是，服务端渲染也有其自身的局限性。因为从本质上来说，SSR 服务无法完全与前端页面解耦开来。因此市面上较完备的 SSR 解决方案都只解决首屏的服务端渲染，并采用同构的方式，增加一层 node 中间层的方式来解决前端与 SSR 服务的更新同步问题，并与后端开发项目解耦。</p>
<p>但这无疑增加了项目的复杂度，并且随着业务的复杂程度变高，服务端渲染往往需要调起多个接口去请求数据并填充页面，这样可能会导致在 TTFB 上有一定劣势。</p>
<p>当然，最重要的是，服务端渲染对于服务器的负载要求是很高的。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220722153734.png" alt="20220722153734"></p>
<p>上图是引用的字节的某项目的 SSR 服务的单机 QPS 承载表现。我们可以看出，对于一个高访问量的网页应用来说，提供一个较为复杂的 SSR 服务的成本是相当高的，需要花费大量的金钱来堆机器。</p>
<p>因此，从降本增效的角度考虑，我们需要评估 SSR 带来的 ROI 是否符合预期。</p>
<h2>NSR(Native Side Render)</h2>
<p>在移动互联网的浪潮下，移动端机能飞速提升，那么 Web 应用是否能搭上这一班车，将 Native 的性能利用起来，提升页面渲染性能呢？答案是肯定的，这就需要介绍到 NSR 了。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220720162547.png" alt="20220720162547"></p>
<p>Native 渲染的本质其实还是 SSR，只不过提供服务的 Server 转变为了客户端。由于需要用到客户端机能，因此此种实现通常应用在移动端 APP，或者 PWA 下。</p>
<p>当链接被点击时，先借助浏览器启用一个 JS 运行时，并加载 APP 中存储的 Html 模板，发送 xhr 请求预加载页面数据，从而在客户端本地拼接并渲染生成一个有数据的 Html 首屏，形成首次 NSR。同时可以将该首屏 Html 缓存在客户端，供下次页面打开时，实现 <code>stale-while-revalidate</code> 的缓存效果。</p>
<p>由于 NSR 将服务器的渲染工作放在了客户端的一个个独立设备中，既实现了页面的预加载，同时又不会增加额外的服务器压力。达到秒看的效果。</p>
<p>这种能力在拥有客户端或者支持 PWA 的应用中应用广泛，例如手 Q，腾讯文档 APP 中都拥有通过 APP 中的离线包来实现首屏渲染加速的能力。</p>
<h2>ESR(Edge Side Render)</h2>
<p>那么，对于纯 Web 应用，而又由于兼容性等原因暂时无法支持 PWA 的页面，有没有一个合适的首屏渲染加速方案呢？</p>
<p>随着云与边缘计算的快速发展，前端页面也需要考虑分布式的请求处理优化。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220720162606.png" alt="20220720162606"></p>
<p>我们知道，CDN 节点相比真实服务节点更贴近用户，能更快将内容返回。因此我们可以将静态的 Html 内容模板缓存在 CDN 上。当接到请求时，先快速将静态模板页面返回给用户，同时在 CDN 服务器上对页面动态部分发起向后端发起请求，并将获取到的动态内容在以流式下发的方式继续返回给用户。</p>
<p>这里实际上利用到了 HTTP 的 SSE(Server Send Events)协议，通过服务器向客户端发送单向事件流，实现同一个 Html 文件的分块传输预渲染。</p>
<h2>最佳实践是？</h2>
<p>这也是我们最近在腾讯文档中探索实践并落地的，通过服务中间节点的流式下发能力，实现多级首屏渲染加速。</p>
<p>对于一个复杂前端页面来说，首屏需要加载和运算的资源类型可能有很多，有需要客户端解析并执行的 JS 动效，也有需要服务端获取数据直出的数据分片展示页面。</p>
<p>通常来说，客户端只能等待服务端获取分片数据，并生成经过 SSR 渲染后的 HTML，才能开始进行 script 解析与 js 资源拉取的行为，最终渲染出完整的页面数据以及动效。</p>
<p>而既然他们所需要的计算方式不同，那么为什么不能并行来做呢？</p>
<p>我们可以在版本发布前，将未经过服务端直出的模板 HTML 进行解析，将需要发起资源请求的所有的外链脚本 url 提取出来，生成一个 HTML Header 结构，并将该 Header 内容伪装为正常 HTML 缓存在 CDN 节点中。</p>
<p>结合之前我们介绍的 HTTP SSE 协议，当用户请求时，我们可以以最快的速度向用户返回 CDN 中的 HTML header，从而让用户的浏览器提前拉取并解析外链资源。于此同时，CDN 节点将用户的请求转发给真实的服务端，从而让服务端进行真实数据的获取拼接并返回给客户端。</p>
<p>由于客户端此时已经提前拉取了外链资源，因此收到服务端分片的 SSR 后，客户端可以直接将真实数据渲染到页面中，而不需要再次等待外链资源的解析。</p>
<p>由于并行的关系，这样的 SSR 与 NSR 混合方式能大大降低复杂页面首屏渲染的时间，提升用户体验。</p>
<p>以百度首页的请求为例，通过 Chorme Network 提供的瀑布图，通过我们可以直观的看到一条请求的执行过程。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220913172530.png" alt="20220913172530"></p>
<p>我们可以看出，除了 DNS 寻址与 SSL 建连是我们无法控制的以外，占用请求时间的大头是 <code>Waiting for server response</code>，请求服务器 (CDN) 的时间，以及 <code>Content Download</code>，外链资源的拉取时间。</p>
<p>而使用本文的混合方案后，理论上可以使总请求时间降低到 Max(A, B), (A 为 <code>Waiting for server response</code>，B 为 <code>Content Download</code>) 的水平。(当然，实际操作过程中，由于 CDN 节点进行了一次请求转发，因此拥有 SSR 能力的页面请求返回时间会更长一些)。</p>
<h2>结语</h2>
<p>前端的页面首屏时间优化是永恒的话题，本文介绍了前端界对首屏时间优化的进程，并提供了一种 SSR 与 NSR 混合的新思路，通过并行处理耗时任务的方式，进一步提升首屏加载时间，希望能够给大家提供一点参考价值。</p>
]]></content>
    <category term="架构设计"/>
    <published>2022-09-08T16:28:03.000Z</published>
  </entry>
  <entry>
    <title type="text">Redux 深入理解 (1)</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/ 2017-11-30.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/ 2017-11-30.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>学习 react 的过程中，redux 的熟练掌握是一个绕不开并且很难绕过去的坎。接触 react 已经有一段时间了，甚至连一些小项目都用 react 做了不少了，但 redux 的使用上还是有诸多不理解不熟练的地方。正好有很长一段时间没有更过博客了，就从这里着手，增强一下自己的理解。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>学习 react 的过程中，redux 的熟练掌握是一个绕不开并且很难绕过去的坎。接触 react 已经有一段时间了，甚至连一些小项目都用 react 做了不少了，但 redux 的使用上还是有诸多不理解不熟练的地方。正好有很长一段时间没有更过博客了，就从这里着手，增强一下自己的理解。</p>
</div><!-- more -->
<h2>先从解决全局事件的问题开始</h2>
<p>我们都知道，react 的数据流是单向的，这样做是为了保证数据同源。</p>
<p>一般来说，子组件可以直接从父组件提供的 props 中获取数据放入 state 或是渲染出来，但是子组件要影响父组件的 state 的话就比较困难了，一般来说需要从父组件写一个回调函数通过 props 传入子组件，子组件调用这个回调函数之后，值就能在父组件中获取了。</p>
<p>那么，如何与孙组件传值呢？依据单向数据流的思路，层层 props 传递，回调函数再层层传递回来，是不是在写法上就有点看不懂了？</p>
<p>那么，跟与这个组件几乎完全没关系的远房亲戚组件传值呢？数据状态管理上就非常混乱了。我们自然而然的会想到，是不是能设计出一种思路，解决多级无关层次属性传递的问题呢？</p>
<p>有计算机基础的同学应该会从设计模式中找到灵感。没错，发布-订阅模式啊，全局订阅一个事件，将监听函数的回调函数置入其中，之后让想要改变数据的操作 dispatch 一个 action 的话，会依次激活通知所有订阅了这个事件的组件，这样再也不用辛苦的一级一级传递数据了，岂不是美滋滋？</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> EventEmitter <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">_events</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">dispatch</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">subscribe</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">unSubscribe</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>是不是看起来很简单？事实上，redux 本身的思路就是这么简单，甚至你可以直接拿这个自己写的“myRedux”中的发布订阅功能投入到 react 项目的使用中。举个例子：</p>
<div class="language-jsx" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token keyword">var</span> MyContainer <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CurItemPanel</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionButtons</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> CurItemPanel <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">getInitialState</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">curItem</span><span class="token operator">:</span> <span class="token string">'item1'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">componentDidMount</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    EventEmitter<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">'changeItem'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newItem</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      self<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">curItem</span><span class="token operator">:</span> newItem
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">componentWillUnmount</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    EventEmitter<span class="token punctuation">.</span><span class="token function">unSubscribe</span><span class="token punctuation">(</span><span class="token string">'changeItem'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">The curItem is: </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>curItem<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> SelectionButtons <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">onClickItem</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  EventEmitter<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'changeItem'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onClickItem</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'item1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">item1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onClickItem</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'item2'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">item2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当点击按钮时，<code>SelectionButtons</code>的兄弟节点<code>CurItemPanel</code>可直接通过订阅的回调函数取得数据啦。</p>
<p>redux 本身的思路就是这么简洁明了。</p>
<h2>有没有别的方法</h2>
<p>如果你的工程的数据流动没有那么繁杂，不想加入 redux 库来强行增加代码复杂度，但又实在觉得单项数据流的祖先传值太不友好的话，react 本身还提供了一个解决办法：Context(上下文)。它同样能解决层次传递的痛点，可以使子组件直接访问祖先组件数据，先写一个示例：</p>
<div class="language-jsx" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token keyword">var</span> CurItemWrapper <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CurItemPanel</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> CurItemPanel <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">contextTypes</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">curItem</span><span class="token operator">:</span> React<span class="token punctuation">.</span>PropTypes<span class="token punctuation">.</span>any
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">The curItem is: </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span>curItem<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> MyContainer <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">getInitialState</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    ……
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">childContextTypes</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">curItem</span><span class="token operator">:</span> React<span class="token punctuation">.</span>PropTypes<span class="token punctuation">.</span>any<span class="token punctuation">,</span>
    <span class="token literal-property property">changeItem</span><span class="token operator">:</span> React<span class="token punctuation">.</span>PropTypes<span class="token punctuation">.</span>any
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">getChildContext</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">curItem</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>curItem<span class="token punctuation">,</span>
      <span class="token literal-property property">changeItem</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>changeItem
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">changeItem</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">curItem</span><span class="token operator">:</span> item
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CurItemWrapper</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ListWrapper</span></span> <span class="token attr-name">changeItem</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeItem<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> ListWrapper <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">List</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> List <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">contextTypes</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">changeItem</span><span class="token operator">:</span> React<span class="token punctuation">.</span>PropTypes<span class="token punctuation">.</span>any
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">onClickItem</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">changeItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onClickItem</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'item1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> item1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onClickItem</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'item2'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">item2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> MyContainer <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">getInitialState</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    ……
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">childContextTypes</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">curItem</span><span class="token operator">:</span> React<span class="token punctuation">.</span>PropTypes<span class="token punctuation">.</span>any<span class="token punctuation">,</span>
    <span class="token literal-property property">changeItem</span><span class="token operator">:</span> React<span class="token punctuation">.</span>PropTypes<span class="token punctuation">.</span>any
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">getChildContext</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">curItem</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>curItem<span class="token punctuation">,</span>
      <span class="token literal-property property">changeItem</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>changeItem
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">changeItem</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">curItem</span><span class="token operator">:</span> item
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CurItemWrapper</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ListWrapper</span></span> <span class="token attr-name">changeItem</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeItem<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看出，通过指定<code>childContextTypes</code>后，父组件通过<code>getChildContext</code>方法可以直接获取到子孙组件中的 context，而子孙组件通过调用 context 对象也能轻松获取来自祖先的回调函数，省去了中间商赚差价(误</p>
<p><code>getChildContext</code> 函数将会在每次 state 或者 props 改变时调用。为了更新 context 中的数据，使用 <code>this.setState</code>触发本地状态的更新。这将触发一个的 context 并且数据的改变可以被子元素收到。</p>
<p>但是！官方似乎并不希望 context 这个功能被广泛的使用，并声称在日后很可能下架这项功能。以下是原话：</p>
<blockquote>
<p>绝大多数的应用程序不需要使用上下文 (context)。</p>
<p>如果你希望使用应用程序更加稳定，就不要使用上下文 (context)。这只是一个实验性的 API ，并且可能在未来的 React 版本中移除。</p>
<p>如果你不熟悉 <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener noreferrer">Redux</a> 或者 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener noreferrer">MobX</a> 这类 state 管理库，就不要使用 context 。在许多实际应用中，这些库以及和 React 绑定是一个很好的管理 和许多组件相关的 state 。Redux 相比 context 是更好的解决方案。</p>
<p>如果你不是一个经验丰富的 React 开发者，就不要使用 context 。更好的方式是使用 props 和 state 。</p>
<p>如果你不顾这些警告仍然坚持使用 context ，尝试着将 context 的使用隔离在一个将小的范围内，并且在可能的情况下直接使用 context ，以便在 API 改变的时候进行升级。</p>
</blockquote>
<p>emmm，所以呀，我们还是尽情拥抱 redux 吧，作为一个状态管理 flux 的 react 优化版，还是很值得学习一番的。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-11-30T11:10:37.000Z</published>
  </entry>
  <entry>
    <title type="text">js 学习笔记梳理 (1)</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-02-10.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-02-10.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在梳理关于 js 一些原理层次的东西，感觉学的有点乱，是时候整理沉淀一下记录成文字了。在我看来，最难理解的核心就两点，一是对闭包的理解，二是对原型链的深入。在这里我先说说闭包。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在梳理关于 js 一些原理层次的东西，感觉学的有点乱，是时候整理沉淀一下记录成文字了。在我看来，最难理解的核心就两点，一是对闭包的理解，二是对原型链的深入。在这里我先说说闭包。</p>
</div><!-- more -->
<p>大家都知道闭包是 JavaScript 的难点，首先我们得知道什么是闭包？</p>
<p>《JavaScript 高级程序设计)》中是这样说的：</p>
<blockquote>
<p>闭包就是指有权访问另一个函数中的变量的函数。</p>
</blockquote>
<p>《JavaScript 权威指南》这样定义：</p>
<blockquote>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包”。</p>
</blockquote>
<p>简单的来说呢，这个牵扯到 JavaScript 作用域的问题。</p>
<p>在 es6 以前，js 其实只有一种作用域，那就是函数级作用域，也就是说任何的私有变量或者函数必须包裹在函数内才能导致不产生全局的变量污染。当然 es6 以后出现的 let()也有这个功能了，关于 let 的用法可参考 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener noreferrer">《ECMAScript 6 入门》中第二章</a>。这里暂且按住不表。</p>
<p>那么闭包是什么呢，闭包简单来说就是一个特殊的函数，<strong>能在自己的作用域里调用其他函数中的私有变量或者私有函数的特殊函数</strong>。通俗的来讲就是闭包就还一个嵌套在其他函数里的函数，其中可以引用外部函数的参数和变量，这些参数和变量不会被 js 的垃圾回收机制自动回收，且变量和参数不会对外部的作用域造成污染。</p>
<p>说完了是什么，那么为什么要创建闭包，它又有什么功能呢？</p>
<p>在我看来好处有三点：</p>
<h2>提供访问函数中的私有变量的入口</h2>
<p>举个例子：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> privateVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">privateFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> privateVar<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//特权方法(闭包访问私有变量和私有函数并传递给外界)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">publicFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        privateVar<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">privateFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">publicFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里就可以看到一个闭包就能把函数中的私有变量以及私有函数的值取出到了外部作用域。</p>
<h2>作用域隔离</h2>
<p>闭包的另一个作用是防止变量污染，限制向全局作用域中添加过多的变量和函数。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        a <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以看到，在 fun2() 这个闭包里定义的新的变量并进行更改时，并不会对外部变量造成污染。</p>
<h2>在循环中包含函数且该函数中使用了遍历数据</h2>
<p>记得在知乎上看到一道面试题，地址搜不到了，大体说是要利用循环给一个数组绑定数组索引对应的值，我先列一个错误的写法：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token function">createFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> funcs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>funcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样并不能得到想要的结果，因为 result[i] 绑定的是一个函数，但是当场并不执行，等到 console.log() 的时候才想到去执行，并调用 i，但此时 i 早已结束了循环，此时的值为 5，因此，输出为 5 个 5，而不是 0-4。</p>
<p>那么需要怎么改才能达到想要的结果呢，这个时候，闭包闪亮登场了。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">_createFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token function">_createFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> funcs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>funcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>加一个 IIFE，并将遍历参数传了进去，一切都不一样了，为什么呢？</p>
<p>这就又得提到垃圾回收机制了，由于闭包函数传入了外部函数的参数变量 i，因此在 var funcs = _createFunctions(); 这一句之后、_createFunctions() 被销毁，但是函数变量 i 不会随着外部函数_createFunctions() 的销毁而回收，因为闭包能够保持对当前 i 的引用，于是在真正调用时，执行闭包中的 i 为当时循环遍历到的数值，从而输出了 0-4.</p>
<p>最后，我们再来做道课后习题来巩固一下吧。
更改下面的代码，使得它能够每个一秒分别输出 0-4:</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我想到了两个利用闭包的解法</p>
<p>法一：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>法二：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">_fun2</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">_fun2</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>原理我就不细说啦，自己琢磨琢磨会有更多收获的哦。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-02-10T01:11:38.000Z</published>
  </entry>
  <entry>
    <title type="text">js 学习笔记梳理 (2)</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-02-20.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-02-20.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>上一节我梳理了一下闭包的概念，这些天各种学校的事情挺忙的，直到现在才有空余时间来写写博客这样杀时间的事儿。这一次整理一下原型链的那些事儿。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>上一节我梳理了一下闭包的概念，这些天各种学校的事情挺忙的，直到现在才有空余时间来写写博客这样杀时间的事儿。这一次整理一下原型链的那些事儿。</p>
</div><!-- more -->
<p>大家都知道在 JavaScript 的世界里，一切皆对象。而我们又知道，JavaScript 并不是完全的一门 OOP(面向对象编程)的语言，它是一门面向原型链编程的语言。综上我们可以得出，其实原型也是一个对象。这对我接下来要讲的内容的理解有至关重要的作用。</p>
<p>OOP 中一个最重要的特性就是继承，那 JavaScript 作为一门完全独立的语言自然也需要有这一特性，而 JavaScript 本身并没有类继承或者接口继承相关的概念，我们需要使用原型链来模拟这一过程。不多说，先上一个例子。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>    <span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">Father</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
    <span class="token class-name">Father</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment">//Father 的原型</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
        <span class="token literal-property property">home</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Beijing'</span><span class="token punctuation">,</span> <span class="token string">'Shanghai'</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> father<span class="token punctuation">;</span> <span class="token comment">//Person 的原型为 Father</span>
    <span class="token comment">// 这样写的好处是子类如果更改了 prototype，那么更改的东西也是附加到 father 这个实例对象上的</span>
    <span class="token comment">// 如果你直接写 Person.prototype = Father.prototype，</span>
    <span class="token comment">// 那你对 Person 的 prototype 的任何修改都会同时修改 Father 的 prototype</span>

</code></pre></div><p>这个例子中，我定义了一个父类构造函数 Father，和一个子类构造函数 Person。至于为什么用构造函数这么奇怪的模式来定义一个类的原因我认为完全可以下次再开一篇专门的文章来阐述，简单来说这个构造函数模式是 JavaScript 生成自定义原型链的一种模式。</p>
<p>好，那么接下来，重点来了。这里使用了父类构造函数的 prototype，这是个什么东东呢？在 JavaScript 里，对每一个函数，都自动会继承一个 prototype 的属性，指向了构造函数所继承的原型对象。</p>
<p>我之前说过，万物皆对象。函数当然也是一个对象，它当然也需要继承另一个对象，那么被函数对象继承的对象，就叫原型对象，在例子里面，他就叫做 Father.prototype。</p>
<p>原型对象，首先是一个对象呀。因此我在重写父类构造函数的原型对象的时候使用了字面量模式，也就是{……}的方法来指定一个对象。当然，你要这么书写也是对的：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>    <span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>home <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Beijing'</span><span class="token punctuation">,</span> <span class="token string">'Shanghai'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，它们之间会有一些差别，但就为对象赋值的情况他们的作用是等效的。</p>
<p>在之后呢，我们为父类创建了一个实例，并将子类构造函数的原型对象指向了这个实例，到此继承原型链完成。</p>
<p>啊啊啊不要问我为什么要这样继承了，这样做并不奇怪。首先我们知道函数的 prototype 必定指向一个 obj 对象，那么构造函数显然不能担当这一职责，只有被实例化的对象才能成为子类的原型对象。这里可以填入的对象有两个，一个是 father，另一个是 Father.prototype。那为什么不是后面这个呢？试试就知道了。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><p>这行代码一敲完我就觉得非常的搞笑了，按自然语言的理解来看看，你的父亲等于你父亲的父亲！？？那你爸是你表哥咯？实际上呢，这样子的赋值语句也经常用到，只不过含义完全不同，这是继承自同一原型的两个不同子类，相当于兄弟节点，这好理解吧？</p>
<p>这里要讲的是子类继承，因此接下来子类的构造函数的 prototype 自然也指向这个被实例化的原型对象。JavaScript 的语言逻辑就是这么奇怪又好有道理的样子。</p>
<p>好，接下来我要给子类实例化两个对象出来，分别是我和我弟弟。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'成龙'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'成风'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>前戏就讲到这里，接下来我们进入正题。基于原型到底有哪些特性。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-02-20T22:08:38.000Z</published>
  </entry>
  <entry>
    <title type="text">es6 学习笔记</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-04-16.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-04-16.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在尝试学习新框架，感觉学习曲线异常的陡峭，全然没有当时学习 bootstrap 和 jquery 的顺畅感觉。后面仔细想来，自己应该是缺了一些基础知识没有补上来，才会导致框架学习遇到了极大的阻力。那自己的知识栈到底缺失了哪一块呢？没错，就是面向未来的 javascript 语法————ES6。</p>
<p>那么现在开始恶补吧，还不算晚。我将我的学习过程记录下来，为自己做 notes，也与各位分享。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在尝试学习新框架，感觉学习曲线异常的陡峭，全然没有当时学习 bootstrap 和 jquery 的顺畅感觉。后面仔细想来，自己应该是缺了一些基础知识没有补上来，才会导致框架学习遇到了极大的阻力。那自己的知识栈到底缺失了哪一块呢？没错，就是面向未来的 javascript 语法————ES6。</p>
<p>那么现在开始恶补吧，还不算晚。我将我的学习过程记录下来，为自己做 notes，也与各位分享。</p>
</div><!-- more -->
<p>这个学习笔记我决定由浅入深，先说说 es6 中最有用、最常用的一些新特性，并举例子介绍它们的特点，所举例子大部分参考自阮一峰老师的 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">《ECMAScript 6 入门》</a>。这本书可是 es6 入门的一本佳作，更难能可贵的是还获得了开源许可，推荐大家一读。</p>
<p>好了言归正传，这一期我准备先来介绍 es6 新增的用来定义变量的新命令。</p>
<h2>let 命令</h2>
<p>只要是听过 es6 大名的人，第一个想到的应该就是 let 命令，因为它的出现一举解决了 es5 时代的许多莫名其妙的变量提升，变量污染的问题。</p>
<p>我们都知道，es5 以前的规范中，javascript 并没有作用域作用块的概念，唯一能够限制使用 var 定义的变量不溢出的块只有函数包裹的块。其他的任何方式都很容易一个不小心就把局部变量泄漏了出去。比如这样：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//ReferenceError: a is not defined</span>

<span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment">// 5</span>
</code></pre></div><p>但是自从引入了 let 命令，js 就有了作用域和代码块，我们可以定义只在块作用域(使用花括号括起来的作用域，包括函数、对象等)中作用的变量了。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//ReferenceError: a is not defined</span>

<span class="token punctuation">{</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//ReferenceError: b is not defined</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment">//ReferenceError: c is not defined</span>
</code></pre></div><p>这就是 let 的特性。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-04-16T22:41:33.000Z</published>
  </entry>
  <entry>
    <title type="text">Flex 布局体验</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-05-25.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-05-25.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>还在为各种布局的 hack 方法犯愁么？还在想着网上流传的各类垂直居中存在的各种奇怪 bug 而影响工作体验么？还在为找不到一个合适自己的规范而疯狂造轮子么？现在，一个全新的布局解决方案规范已经展现在我们面前，它就是 flex 布局。只要 998，各类布局完美解决方案带回家！</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>还在为各种布局的 hack 方法犯愁么？还在想着网上流传的各类垂直居中存在的各种奇怪 bug 而影响工作体验么？还在为找不到一个合适自己的规范而疯狂造轮子么？现在，一个全新的布局解决方案规范已经展现在我们面前，它就是 flex 布局。只要 998，各类布局完美解决方案带回家！</p>
</div><!-- more -->
<blockquote>
<p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
</blockquote>
<p>看到没，w3c 大佬亲自提出来，这权威性不用质疑了吧。</p>
<p>Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局，包括行内元素。只需要设置元素的 display 为 flex 或者 flex-inline 即可。需要注意的是，元素设为 Flex 布局以后，它的子元素的 float、clear 和 vertical-align 属性将失效。</p>
<p>好，接下来我们就来看看，flex 布局到底是个什么样的布局原理和思想。以下内容摘自阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener noreferrer">Flex 布局教程</a>:</p>
<blockquote>
<p>采用 Flex 布局的元素，称为 Flex 容器(flex container)，简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目(flex item)，简称"项目"。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/flex-02.png" alt="flex 结构图"></p>
<blockquote>
<p>容器默认存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置(与边框的交叉点)叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>
</blockquote>
<p>因此啊，我们只需要关注当前元素的水平轴和垂直轴位置，即可完全定位整个元素，是不是很有道理呢？</p>
<p>具体的工具教程请自行查阅相关文档，这里我随便给个 <a href="http://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener noreferrer">传送门</a>，要授人以渔喔。</p>
<p>demo 分割线</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-05-25T14:17:25.000Z</published>
  </entry>
  <entry>
    <title type="text">Redux 深入理解 (2)</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-12-01.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-12-01.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在理解了 redux 的作用原理后，我们来看看 redux 的基本概念。</p>
</div><h3>state</h3>
<p><code>state</code>：state 是状态管理的根本。在 redux 中，有唯一的状态树 state，为整个应用共享。本质上是一个普通对象。处于程序逻辑中，无法直接调用。</p>
<h3>store</h3>
<p><code>store</code>：store 是 state 的管理者，一个应用同样只有唯一的 store，管理着唯一的 state。store 包含下列四个函数：</p>
<blockquote>
<p><code>getState()</code> ：用于获取整个 state</p>
<p><code>dispatch(action)</code> ：View 触发 action 改变 state 的<strong>唯一途径</strong>，请注意我用了<strong>唯一</strong>这个词</p>
<p><code>subscribe(listener)</code> ：可以理解成是 DOM 中的 addEventListener ，也就是我在上一篇里说过的发布订阅模式中的订阅方法，在 redux 的使用中，这个方法通常不需要手动使用，一般会放在 setState 方法中。</p>
<p><code>replaceReducer(nextReducer)</code> ：这个不太常用，一般在 Webpack Code-Splitting 按需加载的时候用获取 state 的方式：</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在理解了 redux 的作用原理后，我们来看看 redux 的基本概念。</p>
</div><h3>state</h3>
<p><code>state</code>：state 是状态管理的根本。在 redux 中，有唯一的状态树 state，为整个应用共享。本质上是一个普通对象。处于程序逻辑中，无法直接调用。</p>
<h3>store</h3>
<p><code>store</code>：store 是 state 的管理者，一个应用同样只有唯一的 store，管理着唯一的 state。store 包含下列四个函数：</p>
<blockquote>
<p><code>getState()</code> ：用于获取整个 state</p>
<p><code>dispatch(action)</code> ：View 触发 action 改变 state 的<strong>唯一途径</strong>，请注意我用了<strong>唯一</strong>这个词</p>
<p><code>subscribe(listener)</code> ：可以理解成是 DOM 中的 addEventListener ，也就是我在上一篇里说过的发布订阅模式中的订阅方法，在 redux 的使用中，这个方法通常不需要手动使用，一般会放在 setState 方法中。</p>
<p><code>replaceReducer(nextReducer)</code> ：这个不太常用，一般在 Webpack Code-Splitting 按需加载的时候用获取 state 的方式：</p>
</blockquote>
<!-- more -->
<p>这几个方法中，<code>dispatch</code>函数略微难理解一点，单独提出来说说。</p>
<h3>dispatch</h3>
<p><code>dispatch(action)</code>用于 View 层想要更改 state 的操作，发布订阅模式中的发布操作。用于通知 store 做相应变更。</p>
<p>那么怎么让 store 知道变更哪一个属性呢？这里就要提到<code>action</code>了。<code>action</code>实际上是一个包含了<code>type</code>属性以及<code>payload</code>对象属性(这个叫载荷，不是必须的，但是在规范里推荐使用)的普通对象。其中<code>type</code>属性定义了应该进行的操作名。</p>
<p>我们从这里可以看出，由于载荷的存在，通常我们需要对<code>action</code>进行一些处理，因此，通常<code>action</code>对象由一个返回<code>action</code>对象的普通函数生成，一般我们称之为<code>actionCreator</code>函数。</p>
<p><code>actionCreator</code>函数不仅可以直接返回<code>action</code>对象，也可以返回一个闭包，闭包传入的参数可以为我们刚才介绍的 store 中的四个函数，最终结果必须返回一个<code>action</code>对象。</p>
<blockquote>
<p>注：<code>actionCreator</code>函数不能直接当做参数传入 dispatch 中，必须引入中间件<code>redux-thunk</code>。</p>
</blockquote>
<h3>createStore</h3>
<p>于是问题来了，既然<code>state</code>是由<code>store</code>生成和管理的，那么这个<code>store</code>又是怎么来的呢？生成 store 的方式又需要用到一个新的函数：<code>createStore(reducer, intialState, applyMiddleware)</code>。(<code>initialState</code>参数可以设置初始 state，非必须。<code>applyMiddleware(middlewares)</code>方法用于引入中间件，这里按住不表)这里又引出来一个新东西：reducer，这是干什么的呢？</p>
<h3>reducer</h3>
<p>刚刚说到的 action ，我的简单的理解是：type 的值就是函数名，payload 的值就是函数的传入参数。那么这个特殊的“函数”在哪里执行呢？redux 的思想是：当 View 层调用<code>dispatch</code>方法，发出相应的<code>action</code>给<code>store</code>，<code>store</code> 收到 <code>action</code> 以后，必须给出一个新的 <code>state</code>，这样 View 才会发生变化。这种 <code>state</code> 的计算过程就叫做 <code>reducer</code>。</p>
<p><code>reducer(oldState, action)</code>是一个纯函数(指任何时候输入同一个数据，返回的数据永远都相同，也就是说 reducer 函数中的处理不能带有任何异步操作)，<code>reducer</code>负责对<code>state</code>操作，接收旧的 state 和 action，根据<code>action.type</code>的类型以及<code>action.payload</code>中的数据，处理 state 并返回。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">case</span> <span class="token string">'DELETE'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>一行代码简单来说就是<code>(oldState, action) =&gt; newState</code>。由于<code>reducer</code>是直接替换<code>state</code>，因此<code>reducer</code>必须有返回值。不然整个 redux 就会得不到<code>state</code>了。</p>
<p>话说一个计算变化重新生成 state 的方法为什么要叫 reducer 呢？我查了查资料，原来这个方法可以作为数组的<code>reduce</code>方法的参数。使用方法如下：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newState <span class="token operator">=</span> actions<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {..., count: 3}</span>
</code></pre></div><p>由于 redux 中，<code>reducer</code>和<code>state</code>一样，也是唯一的，因此如果我们需要根据不同的处理逻辑分割<code>reducer</code>的话，需要用<code>combineReducers({reducer})</code>将这些<code>reducer</code>合并成一个<code>rootReducer</code>。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-12-01T12:44:56.000Z</published>
  </entry>
  <entry>
    <title type="text">Redux 深入理解 (3)</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-12-03.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-12-03.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>上一节说到，reducer 是一个纯函数。那么纯函数具体的定义是什么呢？阮一峰老师是这样说的：</p>
<p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<blockquote>
<ul>
<li>
<p>不得改写参数</p>
</li>
<li>
<p>不能调用系统 I/O 的 API</p>
</li>
<li>
<p>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</p>
</li>
</ul>
</blockquote>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>上一节说到，reducer 是一个纯函数。那么纯函数具体的定义是什么呢？阮一峰老师是这样说的：</p>
<p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<blockquote>
<ul>
<li>
<p>不得改写参数</p>
</li>
<li>
<p>不能调用系统 I/O 的 API</p>
</li>
<li>
<p>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</p>
</li>
</ul>
</blockquote>
</div><!-- more -->
<p>我们知道，处理业务逻辑的过程中不可避免的要用到异步操作，而 reducer 是一个纯函数，无法完成这项使命，那怎么办呢？</p>
<p>这又是一个非常复杂的故事了。</p>
<p>首先我想到的是，<code>action</code>不是由<code>actionCreator</code>函数生成的吗？我们可以在<code>actionCreator</code>函数里面进行异步操作，返回不同的<code>payload</code>，问题不就解决了吗？但是问题又来了，之前说过，reducer 不能接收一个函数作为参数传入啊。</p>
<p>事实上，著名的中间件<code>redux-thunk</code>就是处理这样的问题的，使得<code>actionCreator</code>方法能接受一个返回 action 对象的函数作为返回值。</p>
<p>那么这里就引入了一个中间件的概念。中间件实际上就是用来修饰 reducer 操作，增强 reducer 函数功能的。</p>
<p>我们来看看 redux 中间件是怎么运作的：</p>
<blockquote>
<p>若 reducer 涉及到异步操作，则必须使用中间件。创建 store 时使用<code>applyMiddleware(middleware)(createStore)(reducer, initialState)</code>来创建 store</p>
</blockquote>
<p>这看起来实在是太绕了……</p>
<p>实际上，我们可以将<code>applyMiddleware(middleware)</code>看成一个修饰器，用来修饰<code>createStore(reducer, initialState)</code>函数。是不是看明白了一点？</p>
<p>因此，这个函数我们也能写成这样：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>
  reducer<span class="token punctuation">,</span>
  initial_state<span class="token punctuation">,</span>
  <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>middleware<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将<code>applyMiddleware(middleware)</code>作为<code>createStore</code>的最后一个参数传入，现在是不是好理解多了？</p>
<p>另外，中间件的传入是有顺序讲究的，涉及到执行顺序的问题，通过 redux 中<code>applyMiddleware</code>的源码中可以看出，<code>applyMiddleware(middleware1，middleware2，middleware3)</code>的实际执行顺序为<code>store.dispatch</code>=&gt;<code>middleware1</code>=&gt;<code>middleware2</code>=&gt;<code>middleware3</code>。这一点一定要非常小心，比如著名的 redux-logger 中间件是用来记录操作日志的，一定要放在最后一个参数中以便第一时间执行。</p>
<p>redux 中间件的各种组件可谓是博大精深，有各种各样好用的中间件让人去探索学习，本文着重讲解 redux 本身的原理，对中间件插件就不多做介绍了。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-12-03T13:00:52.000Z</published>
  </entry>
  <entry>
    <title type="text">Redux 深入理解 (4)</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2017-12-04.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2017-12-04.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这一节主要来讲讲 Redux 在 React 项目中的具体使用。</p>
<p>将学的新知识新组件集成进项目里是初学者最大的障碍，这也是我最初学习 Redux 的时候很难有进展的原因。Redux 的源码体积很小，加起来连 1k 行都不到，利用的原理在之前已经说过，也很好理解，但由于 Redux 只是 Flux 对 React 的一种优化，但并不只是服务于 React，如果你愿意，在 Vue 中使用 Redux 也是完全可行的，毕竟状态管理的思想还是不会变的嘛。</p>
<p>因此我们需要一个 Redux 与 React 之间的连接件来方便我们的搭建，这就是<code>React-redux</code>。也是我们将 Redux 合并进 React 最后也是最大的难点。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这一节主要来讲讲 Redux 在 React 项目中的具体使用。</p>
<p>将学的新知识新组件集成进项目里是初学者最大的障碍，这也是我最初学习 Redux 的时候很难有进展的原因。Redux 的源码体积很小，加起来连 1k 行都不到，利用的原理在之前已经说过，也很好理解，但由于 Redux 只是 Flux 对 React 的一种优化，但并不只是服务于 React，如果你愿意，在 Vue 中使用 Redux 也是完全可行的，毕竟状态管理的思想还是不会变的嘛。</p>
<p>因此我们需要一个 Redux 与 React 之间的连接件来方便我们的搭建，这就是<code>React-redux</code>。也是我们将 Redux 合并进 React 最后也是最大的难点。</p>
</div><!-- more -->
<h2><code>React-redux</code>的总体思想</h2>
<blockquote>
<p><code>React-redux</code> 将所有组件分成两大类：UI 组件和容器组件。</p>
</blockquote>
<p>UI 组件和容器组件的定义很好理解。</p>
<p>UI 组件不负责任何的交互逻辑，只负责展示，类比于纯函数，它是一个“纯组件”。不应该有自己定义的 state，所有的状态和事件动作应全由上层的 props 获取。</p>
<p>容器组件则跟 UI 组件相反，可以有自己的状态，能处理业务交互逻辑。</p>
<blockquote>
<p><code>React-redux</code> 规定，所有的 UI 组件都由用户提供，容器组件则是由 <code>React-redux</code> 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p>
</blockquote>
<p>这个思想完美的解决了逻辑数据处理与 UI 界面耦合的问题，让程序的思路更清晰，极大地提高开发与调试效率，这也是为什么越大型的项目越需要使用这样的状态管理组件的根本原因。</p>
]]></content>
    <category term="前端基础"/>
    <published>2017-12-04T15:22:30.000Z</published>
  </entry>
  <entry>
    <title type="text">CSS 的垂直居中方法</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2018-03-14.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2018-03-14.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>CSS 是每一个前端工程师都绕不过去的坎，熟练运用 CSS 后，实现同样一种效果我们可以有很多种写法，但由于兼容问题，通常简洁的写法并不能实现全平台统一效果，复杂的写法对性能又不太友好，导致我们在编写 CSS 过程中有很多需要注意的点，要踩很多的坑，因此用一个笔记来集中记录一下方法。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>CSS 是每一个前端工程师都绕不过去的坎，熟练运用 CSS 后，实现同样一种效果我们可以有很多种写法，但由于兼容问题，通常简洁的写法并不能实现全平台统一效果，复杂的写法对性能又不太友好，导致我们在编写 CSS 过程中有很多需要注意的点，要踩很多的坑，因此用一个笔记来集中记录一下方法。</p>
</div><!-- more -->
<p>(为方便表达代码，在此定义 html 结构为：</p>
<div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>默认的 css 样式为：</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> #ccc<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">.target</span> <span class="token punctuation">{</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 25%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>行内元素 html 结构改为：</p>
<div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Duang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>css 样式改为：</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.target</span> <span class="token punctuation">{</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> #eee<span class="token punctuation">;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>以下无特殊说明的话结构都使用这个。</p>
<h2>水平居中</h2>
<h3>1. 行内元素</h3>
<p>只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加 text-align:center 即可：</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200713145226.png" alt="text-align"></p>
<h3>2. 块状元素</h3>
<p>对于块状元素来说，我们需要将它的左右外边距(即，margin-left，margin-right)设置为 auto，即可实现块状元素的居中，如下：</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.target</span> <span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200713144819.png" alt="margin-0-auto"></p>
<h2>垂直居中</h2>
<h3>1. 行内元素单行居中</h3>
<p>对于单行行内元素来说，垂直居中就是设定父元素行高等于其块状元素高度。</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">line-height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">.target</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200715165311.png" alt="line-height"></p>
<h3>2. 行内元素多行居中</h3>
<p>这个使用的手段是比较复杂的，我这里组合使用 display:table-cell 和 vertical-align:middle 属性来定义需要居中的元素的父容器元素，但是缺点有很多，比如这里因为格式变成了 table 类型，宽高必须设置成定值才行，希望有大佬提出更好的解决方法。</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
    <span class="token property">vertical-align</span><span class="token punctuation">:</span>middle<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200715165348.png" alt="table-cell"></p>
<h2>水平垂直居中</h2>
<p>这里的方法同样适用于仅水平或者仅垂直居中。取与之相关的居中代码即可。</p>
<h3>1. 最通用且实用的首选方法</h3>
<p>在不知道自己高度和父容器高度的情况下，给父元素设置相对定位，子元素绝对定位，然后按照向右向下偏移的办法移到中心位置即可。</p>
<p>这里绝对定位的好处是无论父元素的实际高度以及子元素的个数，都能够完成覆盖型的居中显示。</p>
<p>代码示例如下：</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">.target</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>(注：其实这里可以不用知道父子元素高度，为了方便显示才使用)</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200715165411.png" alt="absolute-top-left"></p>
<h3>2. 已知父元素的高度，并且子元素有且只有一个</h3>
<p>如果已知父元素的高度，并且子元素有且只有一个的话，完全可以只对子元素使用相对定位完成同样的效果：</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.target</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200715165411.png" alt="relative-top-left"></p>
<h3>3. 多个子元素自适应的同时水平垂直居中</h3>
<p>如果想实现多个子元素自适应的同时水平垂直居中，同时浏览器兼容性也支持的不错的话，推荐使用简单方便的 flex 布局。仅仅只设定父元素 display 属性为 flex 即可。</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200715165507.png" alt="flex"></p>
<h3>4. table-cell 方式</h3>
<p>附加一个兼容性更好但是不太推荐的方法，就是由刚才多行行内元素垂直居中衍生出来的，再加一行行内水平居中的代码就能解决了。</p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code>  <span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
    <span class="token property">vertical-align</span><span class="token punctuation">:</span>middle<span class="token punctuation">;</span>
    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200715165534.png" alt="table-cell"></p>
<p>不太推荐的原因同垂直居中时说的。</p>
<p>而且想实现这个效果还不如直接用一个块状元素包裹这些行内元素，然后再用块状元素的水平垂直居中即可，当然显示方式可能会有少许的不同，自己斟酌使用吧~</p>
]]></content>
    <category term="前端基础"/>
    <published>2018-03-14T16:51:25.000Z</published>
  </entry>
  <entry>
    <title type="text">利用 React 高阶组件实现一个面包屑导航</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2018-11-12.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2018-11-12.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>什么是 React 高阶组件</h2>
<p>React 高阶组件就是以高阶函数的方式包裹需要修饰的 React 组件，并返回处理完成后的 React 组件。React 高阶组件在 React 生态中使用的非常频繁，比如<code>react-router</code> 中的 <code>withRouter</code> 以及 <code>react-redux</code> 中 <code>connect</code> 等许多 API 都是以这样的方式来实现的。</p>
]]></summary>
    <content type="html"><![CDATA[<h2>什么是 React 高阶组件</h2>
<p>React 高阶组件就是以高阶函数的方式包裹需要修饰的 React 组件，并返回处理完成后的 React 组件。React 高阶组件在 React 生态中使用的非常频繁，比如<code>react-router</code> 中的 <code>withRouter</code> 以及 <code>react-redux</code> 中 <code>connect</code> 等许多 API 都是以这样的方式来实现的。</p>
<!-- more -->
<h2>使用 React 高阶组件的好处</h2>
<p>在工作中，我们经常会有很多功能相似，组件代码重复的页面需求，通常我们可以通过完全复制一遍代码的方式实现功能，但是这样页面的维护可维护性就会变得极差，需要对每一个页面里的相同组件去做更改。因此，我们可以将其中共同的部分，比如接受相同的查询操作结果、组件外同一的标签包裹等抽离出来，做一个单独的函数，并传入不同的业务组件作为子组件参数，而这个函数不会修改子组件，只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数，从而我们能够在不改变这些组件逻辑的情况下将这部分代码解耦，提升代码可维护性。</p>
<h2>自己动手实现一个高阶组件</h2>
<p>前端项目里，带链接指向的面包屑导航十分常用，但由于面包屑导航需要手动维护一个所有目录路径与目录名映射的数组，而这里所有的数据我们都能从 <code>react-router</code> 的路由表中取得，因此我们可以从这里入手，实现一个面包屑导航的高阶组件。</p>
<p>首先我们看看我们的路由表提供的数据以及目标面包屑组件所需要的数据：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 这里展示的是 react-router4 的route示例</span>
<span class="token keyword">let</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">breadcrumb</span><span class="token operator">:</span> <span class="token string">'一级目录'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../a/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">,</span>
    <span class="token literal-property property">items</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">breadcrumb</span><span class="token operator">:</span> <span class="token string">'二级目录'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/a/b'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">component</span><span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../a/b/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">,</span>
        <span class="token literal-property property">items</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token literal-property property">breadcrumb</span><span class="token operator">:</span> <span class="token string">'三级目录1'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/a/b/c1'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">component</span><span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../a/b/c1/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">,</span>
            <span class="token literal-property property">exact</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">{</span>
            <span class="token literal-property property">breadcrumb</span><span class="token operator">:</span> <span class="token string">'三级目录2'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/a/b/c2'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">component</span><span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../a/b/c2/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">,</span>
            <span class="token literal-property property">exact</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

<span class="token comment">// 理想中的面包屑组件</span>
<span class="token comment">// 展示格式为 a / b / c1 并都附上链接</span>
<span class="token keyword">const</span> <span class="token function-variable function">BreadcrumbsComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> breadcrumbs <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>breadcrumbs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">breadcrumb<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>span key<span class="token operator">=</span><span class="token punctuation">{</span>breadcrumb<span class="token punctuation">.</span>props<span class="token punctuation">.</span>path<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>link to<span class="token operator">=</span><span class="token punctuation">{</span>breadcrumb<span class="token punctuation">.</span>props<span class="token punctuation">.</span>path<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>breadcrumb<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>link<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>index <span class="token operator">&lt;</span> breadcrumbs<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span>i<span class="token operator">&gt;</span> <span class="token operator">/</span> <span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">&gt;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们可以看到，面包屑组件需要提供的数据一共有三种，一种是当前页面的路径，一种是面包屑所带的文字，一种是该面包屑的导航链接指向。</p>
<p>其中第一种我们可以通过 react-router 提供的 withRouter 高阶组件包裹，可使子组件获取到当前页面的 location 属性，从而获取页面路径。</p>
<p>后两种需要我们对 routes 进行操作，首先将 routes 提供的数据扁平化成面包屑导航需要的格式，我们可以使用一个函数来实现它。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * 以递归的方式展平react router数组
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">flattenRoutes</span> <span class="token operator">=</span> <span class="token parameter">arr</span> <span class="token operator">=&gt;</span>
  arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prev<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> prev<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>
      Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flattenRoutes</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token operator">:</span> item
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>之后将展平的目录路径映射与当前页面路径一同放入处理函数，生成面包屑导航结构。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">getBreadcrumbs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> flattenRoutes<span class="token punctuation">,</span> location <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化匹配数组match</span>
  <span class="token keyword">let</span> matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  location<span class="token punctuation">.</span>pathname
    <span class="token comment">// 取得路径名，然后将路径分割成每一路由部分.</span>
    <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
    <span class="token comment">// 对每一部分执行一次调用`getBreadcrumb()`的reduce.</span>
    <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> curSection</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将最后一个路由部分与当前部分合并，比如当路径为 `/x/xx/xxx` 时，pathSection分别检查 `/x` `/x/xx` `/x/xx/xxx` 的匹配，并分别生成面包屑</span>
      <span class="token keyword">const</span> pathSection <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prev<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>curSection<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> breadcrumb <span class="token operator">=</span> <span class="token function">getBreadcrumb</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        flattenRoutes<span class="token punctuation">,</span>
        curSection<span class="token punctuation">,</span>
        pathSection<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 将面包屑导入到matches数组中</span>
      matches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>breadcrumb<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 传递给下一次reduce的路径部分</span>
      <span class="token keyword">return</span> pathSection<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> matches<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>然后对于每一个面包屑路径部分，生成目录名称并附上指向对应路由位置的链接属性。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">getBreadcrumb</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> flattenRoutes<span class="token punctuation">,</span> curSection<span class="token punctuation">,</span> pathSection <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> matchRoute <span class="token operator">=</span> flattenRoutes<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">ele</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> breadcrumb<span class="token punctuation">,</span> path <span class="token punctuation">}</span> <span class="token operator">=</span> ele<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>breadcrumb <span class="token operator">||</span> <span class="token operator">!</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>
        <span class="token string">'Router中的每一个route必须包含 `path` 以及 `breadcrumb` 属性'</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 查找是否有匹配</span>
    <span class="token comment">// exact 为 react router4 的属性，用于精确匹配路由</span>
    <span class="token keyword">return</span> <span class="token function">matchPath</span><span class="token punctuation">(</span>pathSection<span class="token punctuation">,</span> <span class="token punctuation">{</span> path<span class="token punctuation">,</span> <span class="token literal-property property">exact</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回breadcrumb的值，没有就返回原匹配子路径名</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>matchRoute<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">content</span><span class="token operator">:</span> matchRoute<span class="token punctuation">.</span>breadcrumb <span class="token operator">||</span> curSection<span class="token punctuation">,</span>
      <span class="token literal-property property">path</span><span class="token operator">:</span> matchRoute<span class="token punctuation">.</span>path<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 对于routes表中不存在的路径</span>
  <span class="token comment">// 根目录默认名称为首页.</span>
  <span class="token keyword">return</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">content</span><span class="token operator">:</span> pathSection <span class="token operator">===</span> <span class="token string">'/'</span> <span class="token operator">?</span> <span class="token string">'首页'</span> <span class="token operator">:</span> curSection<span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> pathSection<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>之后由 render 函数生成最后的单个面包屑导航样式。单个面包屑组件需要为 render 函数提供该面包屑指向的路径 <code>path</code>, 以及该面包屑内容映射<code>content</code> 这两个 props。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 *
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> content<span class="token punctuation">,</span> path <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> componentProps <span class="token operator">=</span> <span class="token punctuation">{</span> path <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> content <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>content <span class="token punctuation">{</span><span class="token operator">...</span>componentProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>span <span class="token punctuation">{</span><span class="token operator">...</span>componentProps<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>content<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>有了这些功能函数，我们就能实现一个能为包裹组件传入当前所在路径以及路由属性的 React 高阶组件了。传入一个组件，返回一个新的相同的组件结构，这样便不会对组件外的任何功能与操作造成破坏。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">BreadcrumbsHoc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
  <span class="token parameter">location <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">,</span>
  routes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token parameter">Component</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> BreadComponent <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Component
      breadcrumbs<span class="token operator">=</span><span class="token punctuation">{</span><span class="token function">getBreadcrumbs</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">flattenRoutes</span><span class="token operator">:</span> <span class="token function">flattenRoutes</span><span class="token punctuation">(</span>routes<span class="token punctuation">)</span><span class="token punctuation">,</span>
        location<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> BreadComponent<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> BreadcrumbsHoc<span class="token punctuation">;</span>
</code></pre></div><p>调用这个高阶组件的方法也非常简单，只需要传入当前所在路径以及整个 <code>react router</code> 生成的 <code>routes</code> 属性即可。
至于如何取得当前所在路径，我们可以利用 <code>react router</code> 提供的 <code>withRouter</code> 函数，如何使用请自行查阅相关文档。
值得一提的是，<code>withRouter</code> 本身就是一个高阶组件，能为包裹组件提供包括 <code>location</code> 属性在内的若干路由属性。所以这个 API 也能作为学习高阶组件一个很好的参考。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> location <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token function">BreadcrumbsHoc</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> routes<span class="token punctuation">)</span><span class="token punctuation">(</span>BreadcrumbsComponent<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>Q&amp;A</h2>
<p>如果<code>react router</code> 生成的 <code>routes</code> 不是由自己手动维护的，甚至都没有存在本地，而是通过请求拉取到的，存储在 redux 里，通过 <code>react-redux</code> 提供的 <code>connect</code> 高阶函数包裹时，路由发生变化时并不会导致该面包屑组件更新。使用方法如下：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mapStateToProps</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">routes</span><span class="token operator">:</span> state<span class="token punctuation">.</span>routes<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">)</span><span class="token punctuation">(</span>
  <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> location <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token function">BreadcrumbsHoc</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> routes<span class="token punctuation">)</span><span class="token punctuation">(</span>BreadcrumbsComponent<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>]]></content>
    <category term="前端基础"/>
    <published>2018-11-12T11:51:01.000Z</published>
  </entry>
  <entry>
    <title type="text">React15 与 React16 生命周期区别与使用方式</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2019-12-21.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2019-12-21.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>因为 React16 框架使用了全新的<code>Fiber</code>架构，这其中有一个特性叫做<code>async rendering</code>，render 过程可中断，因此，render 函数之前的所有生命周期函数都有可能被多次执行，如果在这些函数中存在异步请求的话将会造成许多无用的请求被调用。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>因为 React16 框架使用了全新的<code>Fiber</code>架构，这其中有一个特性叫做<code>async rendering</code>，render 过程可中断，因此，render 函数之前的所有生命周期函数都有可能被多次执行，如果在这些函数中存在异步请求的话将会造成许多无用的请求被调用。</p>
</div><!-- more -->
<h2>为什么要变更生命周期</h2>
<p>因为 React16 框架使用了全新的<code>Fiber</code>架构，这其中有一个特性叫做<code>async rendering</code>，render 过程可中断，因此，render 函数之前的所有生命周期函数都有可能被多次执行，如果在这些函数中存在异步请求的话将会造成许多无用的请求被调用。</p>
<p>涉及到的生命周期函数一共有 4 个：</p>
<blockquote>
<p>componentWillMount</p>
<p>componentWillReceiveProps</p>
<p>shouldComponentUpdate</p>
<p>componentWillUpdate</p>
</blockquote>
<p>很多开发者在<code>componentWillMount</code>或是<code>componentWillUpdate</code>里调用请求的原因是期望请求回更新的状态能在 render 之前刷新，但这样是不可能的，无论请求相应速度多快，异步操作的返回逻辑执行都会被安排在下一次 tick 之后，页面还是会被 render 两次。</p>
<p>而在<code>componentWillReceiveProps</code>写同步逻辑也会存在一些问题，如当父组件传入的 props 变更非常频繁的时候，<code>componentWillReceiveProps</code>的调用次数是非常多的，但若是将这些逻辑放入 render 及以后的周期函数中则并不会这样，这是因为 react 进行 setState 的时候是会通过<code>transaction</code>进行合并的，实际 render 的执行次数并不会增多。</p>
<p>因此，从合理性上来说，推荐将异步请求放在<code>componentDidMount</code>里，同步处理逻辑写在 render 中或使用<code>shouldComponentUpdate</code>优化直接省去 render 步骤。为了强制开发者彻底摈弃这样的使用习惯，官方在 React16 中干脆去掉了除了<code>shouldComponentUpdate</code>以外的其他声明周期。</p>
<p>但仍然有开发者需要在 render 之前获取到 props 的更新，因此官方增加了新的生命周期函数<code>getDrivedStateFromProps</code>。它的作用其实与<code>componentWillReceiveProps</code>差不多，但优势在于在多次变更 props 操作的过程中，它与 render 一样，只更新一次。</p>
<p>我画了一张图来清晰地展示 React 新旧生命周期过程的对比：</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/React新旧生命周期对比.png" alt="React 新旧生命周期对比。png"></p>
<h2>componentWillXX 生命周期函数的替代者</h2>
<p>首先来看看这个新增引入的生命周期函数：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">static</span> <span class="token function">getDrivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span><span class="token operator">:</span> newState <span class="token operator">||</span> <span class="token keyword">null</span>
</code></pre></div><p>在组件创建和更新时都会调用，它能获取到更新的 props 与当前的 state，返回更新后的 state，若不需要进行更新则返回 null。</p>
<p>我们需要注意的是，这个函数一定需要写成 static 的静态函数，这样做的目的是不让开发者在这个函数中拿到 this，因此无法进行<code>setState</code>操作，使之变成一个纯函数。以这样的方式规范了 react 在 render 函数执行之前不做任何更新状态的异步请求。</p>
<h2>如何在页面更新后立即获取到更新后的 DOM 信息</h2>
<p>这就要提到 React16 的另一个生命周期函数：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span>
</code></pre></div><p>这个函数的作用时机是 render 函数之后，实际组件更新之前，这个时候组件无法进行更改但可以读取 DOM 中的信息，我们可以在这个阶段获取到如 <code>ref</code> 之类的真实 DOM 数据，并将结果传递给 componentDidUpdate(prevProps, prevState, snapshot) 中的第三个参数，从而在更新后可以根据当前 DOM 的数据进行状态的相应调整。</p>
<h2>React16 如何进行错误捕获与处理</h2>
<p>因为 React 是基于 javascript 的框架，因此组件内部若存在 js 异常，将会阻断一些状态的更新，导致应用崩溃。而一般认为，在 UI 部分发生的异常不应该让整个应用 crash，为此在 React16.0 中，引入了一个新的异常处理捕获的生命周期函数<code>componentDidCatch</code>。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token function">componentDidCatch</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> info<span class="token punctuation">)</span>
</code></pre></div><p>它引入了一个新概念：<code>error boundary</code>，错误边界。它是一个内部包含<code>componentDidCatch</code>函数的 React 类组件，它用以捕获在整个<strong>子组件树</strong>的构造函数以及生命周期函数中的 JS 异常，从而渲染不同的子页面。</p>
<p>注意，由于它本质上还是利用了 React 类的生命周期，因此只能对类组件的错误捕获有效，并且只能对错误边界包裹的子组件(不包括自身)有效。</p>
<p>若没有在错误边界中被 catch 的 JS 错误将导致整个 React 组件被卸载。</p>
<p>与 try/catch 不同的是，错误边界保留了 React 声明式的特性，而前者适用于命令式的代码。并且错误边界能捕获组件树内部底层逻辑导致的错误，如在<code>componentDidUpdate</code>中的<code>setState</code>。</p>
]]></content>
    <category term="前端基础"/>
    <published>2019-12-21T17:38:35.000Z</published>
  </entry>
  <entry>
    <title type="text">React16.8 useHook 特性</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2020-01-21.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2020-01-21.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>React16.8 迎来了大众期盼已久的函数式编程利器：<code>useHook</code>特性。它能大大增强函数式组件的能力，使得立即执行的、没有生命周期与 state 等等类组件特性的函数式组件拥有相同的能力。</p>
<p><code>useHook</code>的原理实际上是利用了 JavaScript 的闭包机制，因此在多次执行函数的同时记住一些状态。</p>
<p><code>useHook</code>拥有多种函数，我们也可以自定义自己的 hook。在这里主要来说说其中最常用的几种，简述他们的大致原理，以及使用时的注意事项。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>React16.8 迎来了大众期盼已久的函数式编程利器：<code>useHook</code>特性。它能大大增强函数式组件的能力，使得立即执行的、没有生命周期与 state 等等类组件特性的函数式组件拥有相同的能力。</p>
<p><code>useHook</code>的原理实际上是利用了 JavaScript 的闭包机制，因此在多次执行函数的同时记住一些状态。</p>
<p><code>useHook</code>拥有多种函数，我们也可以自定义自己的 hook。在这里主要来说说其中最常用的几种，简述他们的大致原理，以及使用时的注意事项。</p>
</div><!-- more -->
<h2>useState</h2>
<p><code>useState</code>就是为了给纯函数组件加入 class 组件中的 state 能力。它返回一个有两个元素的数组，第一个元素是需要设置的 state 变量，第二个是改变这个变量的 setter 函数。<code>useState</code>的入参决定了返回变量的初始值。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><p>在每一次执行 setter 之后，使用了<code>useState</code>的整个函数组件都会被重新执行一次。但是此时<code>useState</code>函数本身并不会被再次执行。这是因为实际上，<code>useState</code>利用了闭包的特性，在闭包内设置了一个私有变量。事实上 setter 改变的值是这个私有变量，我们能取出的变量是这个私有变量的 getter 返回值。</p>
<p><em>注意，只能在函数的最外层调用 Hook，不能在循环、条件判断或子函数中使用。</em></p>
<p>这是因为，为了支持在同一个函数组件中使用多次<code>useState</code>，在闭包中，被<code>useState</code>的赋值的私有变量本质上是一个数组类型，通过函数首次被调用的<code>useState</code>的顺序来决定被赋值变量的索引位置，最后 getter 通过索引顺序找到希望取得的变量值。若在循环、条件判断或子函数中使用，则有可能造成函数组件重新执行时顺序与首次执行不一致，这将导致<code>useState</code>的取值混乱。</p>
<h2>useEffect</h2>
<p>useEffect 为纯函数组件提供了 class 组件中的<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnMount</code>、<code>shouldComponentUpdate</code>这些生命周期能力。</p>
<p>useEffect 接收两个参数，第一个参数是一个函数，在函数中执行的动作相当于在类组件中生命周期中的所需要进行的工作。该函数的返回值也是一个函数，若不为空的话它执行的时机等同于<code>componentWillUnMount</code>。</p>
<p>第二个参数是一个数组，传入的是需要监听变量列表，若填写该值，只有当监听范围内的变量更新时，才执行第一个参数函数中的动作。起到了类似<code>shouldComponentUpdate</code>的作用。当传入空数组时相当于不监听任何变量，只在组件生成时执行一遍，等同于<code>componentDidMount</code>。当传入为空值时相当于监听所有变量，等同于<code>componentDidUpdate</code>。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fetchSth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 执行异步操作 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">destroySth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 执行 unmount 操作 */</span>
<span class="token punctuation">}</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">fetchSth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token function">detroySth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><h2>useReducer</h2>
<p><code>useReducer</code>事实上与 redux 概念中的<code>reducer</code>十分类似，如果使用过 redux 应该对<code>reducer</code>的概念和定义不会陌生。</p>
<p>它与<code>useState</code>作用场景相似，也能赋予函数组件设定和处理 state 的能力。通常情况下，它们是可以互换的。</p>
<p>但是，对于在组件中存在着多个 state 的定义，或者是操作逻辑复杂需要同时更改多个 state，又或者定义的 state 是一个复杂类型，如数组、对象或存在嵌套，使用<code>useReducer</code>会使得 state 声明更加集中，同时操作逻辑更为清晰，代码也能有更好的可读性。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 第一个参数：应用的初始化</span>
<span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">isDone</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 第二个参数：state 的 reducer 处理函数</span>
<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">...</span>initialState<span class="token punctuation">,</span> <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">isDone</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">...</span>initialState<span class="token punctuation">,</span> <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">isDone</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> initialState
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 用法</span>
<span class="token keyword">function</span> <span class="token function">onIncrementClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>useMemo 和 useCallback</h2>
<p>这两个 API 我拿在一起来说，原因很简单，他们的目标都是一致的，都是缓存结果，只不过<code>useCallback</code>是缓存函数本身，<code>useMemo</code>是缓存函数返回的结果。从这里也可以看出，实际上，<code>useCallback</code>是可以被<code>useMemo</code>通过多包裹一层函数实现的。</p>
<p>这两个 API 的函数签名与 useEffect 基本一致，因此调用方法区别不大。在用法功能上，他们之间区别最大的一点是，useEffect 是处理副作用的，是在 render 函数执行完后执行的，相当于 class 组件的<code>didMount/didUpdate</code>。而这两个 API 不能处理副作用，必须同步调用，即在哪里调用就在哪里立即执行函数内容，在下一行就能直接使用返回的结果。</p>
<p>那么，这两个 API 的使用情景是什么呢？答案是性能优化。我们先来看看需要使用<code>useMemo</code>的情况：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">keywordChangeCompute</span><span class="token punctuation">(</span><span class="token parameter">keyword</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 执行一些非常消耗资源的同步操作 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>keyword<span class="token punctuation">,</span> setKeyword<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">keywordChangeCompute</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>若不使用<code>useMemo</code>而直接将函数调用写在 render 中的话，当外部组件或者该组件的其他 state 进行频繁的更新时，该组件会不断地多次触发<code>keywordChangeCompute</code>函数，造成不必要的性能损失。而对于使用了<code>useMemo</code>来说，只在<code>keyword</code>变化的时候才会触发一次函数调用，这与<code>useEffect</code>的触发机制是一致的。</p>
<p>对于<code>useCallback</code>的使用，有一种情况是非常实用的，即该方法会被传给子组件的情况：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>status<span class="token punctuation">,</span> setStatus<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">onChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/api/get/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>ChildComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token function">useCallback</span><span class="token punctuation">(</span>onChange，<span class="token punctuation">[</span>status<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span>
</code></pre></div><p>因为父组件在每一次更新的时候都会生成一个全新的<code>onChange</code>函数，而由于<code>status</code>状态不变，新的<code>onChange</code>函数并没有改变，这样会导致子组件进行一次没必要的更新，造成性能损失。而使用了<code>useCallback</code>后，只会在<code>status</code>状态更新时生成新的函数传给子组件，从而减少子组件渲染次数。</p>
]]></content>
    <category term="前端基础"/>
    <published>2020-01-21T18:19:28.000Z</published>
  </entry>
  <entry>
    <title type="text">一文讲透 React Diff 算法核心</title>
    <id>https://blog.realduang.com/blogs/frontend-basics/2024-12-02.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-basics/2024-12-02.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>前言</h2>
<p>一直以来我对八股文一直是深恶痛绝的，总觉得这种东西如空中楼阁，对实际解决工程问题没有任何帮助。并且很多人只从网上搜索面试题答案死记硬背，反而可能由于该题目版本老旧而自己又没有从实际场景中理解，而导致获得了过时的甚至是错误的知识。</p>
<p>但随着工作的深入，我发现这种观点是有些偏颇的，因为在实际工程中，如果我们自己都不知道这个技术的运行原理，又何谈对它的深入优化呢？这在 AI 辅助工作的时代更是如此，AI 无法回答你提不出来的问题。</p>
<p>因此，我想新开辟一个板块，就写一些老生常谈的"八股文", 但是我会尽量从源码层面去理解这些问题，并且尽量做到一通百通，而不是死记硬背。希望这样的方式能够帮助大家更好地理解这些问题。</p>]]></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<p>一直以来我对八股文一直是深恶痛绝的，总觉得这种东西如空中楼阁，对实际解决工程问题没有任何帮助。并且很多人只从网上搜索面试题答案死记硬背，反而可能由于该题目版本老旧而自己又没有从实际场景中理解，而导致获得了过时的甚至是错误的知识。</p>
<p>但随着工作的深入，我发现这种观点是有些偏颇的，因为在实际工程中，如果我们自己都不知道这个技术的运行原理，又何谈对它的深入优化呢？这在 AI 辅助工作的时代更是如此，AI 无法回答你提不出来的问题。</p>
<p>因此，我想新开辟一个板块，就写一些老生常谈的"八股文", 但是我会尽量从源码层面去理解这些问题，并且尽量做到一通百通，而不是死记硬背。希望这样的方式能够帮助大家更好地理解这些问题。</p>
<p>这一次，让我们重走西游，踏上取经路的是 React 的 Diff 算法。（注：以下代码实现均基于 React 18.3 版本实现进行）</p>
<h2>React Diff 算法的诞生背景</h2>
<p>要讲透 React Diff，就一定不能只讲 React Diff。我们需要知道 React Diff 算法为什么会被设计出来。</p>
<p>在 React 之前，我们在操作 DOM 的时候，通常是直接操作 DOM，比如我们要在一个列表中插入一个新的元素，我们会直接在 DOM 中插入一个新的元素。这样的操作会导致浏览器的重排和重绘，性能开销很大。为了解决这个问题，React 引入了 Virtual DOM。</p>
<p>Virtual DOM 用于描述 UI 树的理想状态，是一个纯粹的 JavaScript 对象。这样一来，React 的更新操作就从 DOM 操作中解放出来，只需要在内存中对一个
JavaScript 对象频繁进行更新即可。当需要更新 UI 时，React 拥有双缓存机制，会通过 Diff 算法比较新旧 Virtual DOM 的差异，算出需要更新的节点，将需要更新的部分一次性更新到真实的 DOM 中。</p>
<p>这样一来，React 不仅仅大大减少了浏览器的重排和重绘，提高了性能，同时还带来了一个巨大的好处：逻辑抽象层与视图层操作完全分离，为 React 的跨平台开发提供了可能。实际上，包括 React Native 在内的所有跨平台框架，他们在抽象逻辑层的代码，即 Virtual DOM 以及 React Diff 部分（在 React 中称为 React-Reconciler 库），都是与平台无关，完全相同且复用的。</p>
<h2>React Diff 算法执行性能</h2>
<p>现在我们知道了 React Diff 算法本质上就是用于比较新旧 Virtual DOM 的差异，得出需要更新的 DOM 行为。显而易见这个算法在整个 React 中的使用频率相当高，因此 React Diff 算法的执行性能是非常重要的。</p>
<p>我们知道，DOM 节点本质上是一个树型结构，因此通常来说，我们可以通过树的遍历算法来比较新旧 Virtual DOM 的差异。但是，即使在最前沿的算法中，将两棵树完全比对的复杂度仍为 O(n^3) （我们可以在 LeetCode 中很容易找到这样的题型，感兴趣可以自己实现一下），这显然是不可接受的。而 React Diff 算法将这一行为的时间复杂度降低到了 O(n)。</p>
<p>当然，科学领域里没有银弹，React Diff 能实现这么优异的性能，也是因为设计团队根据 React 本身的特点，预设了比对的 3 个限制：</p>
<ol>
<li><strong>只对同级元素 diff</strong>。若同一个 DOM 节点在更新中变更了层级，则 react 不会复用。</li>
<li><strong>不同类型的元素变更时，元素不会复用</strong>。例如元素从 div 变成 p，react 会销毁 div 和所有子孙节点，并重新建立。</li>
<li>开发者可以对元素指定 key 属性来表示该元素能在更新后保持稳定，帮助算法优化。</li>
</ol>
<p>正是由于 React 只针对同级同类型元素进行比对，所以 React Diff 将不会存在递归与回溯，从而保证了如此优异算法的复杂度。这就是 React Diff 算法的核心，也是八股文中真正有价值的内容，可惜不是每一个熟背的人都能真正理解。</p>
<h2>React Diff 算法的实现</h2>
<p>为了加深理解，我们也可以自己动手根据上述的思路实现 React Diff 算法。</p>
<p>通过进入 Diff 算法的 React 节点的子节点个数不同，我们可以将 React Diff 算法分为两种情况：单节点 Diff 和多节点 Diff。在实际的使用中，我们可以通过判断节点的 props.children 是否为数组来判断当前节点是单节点还是多节点。</p>
<h3>单节点 Diff（reconcileSingleElement）</h3>
<p>单节点 Diff 是指<strong>新节点只有一个子节点的情况（但旧节点可能有多个 children）</strong>。在这种情况下，我们只需要比较新旧节点的 props 和 children 是否相同即可。若旧的 React 节点可以被复用，将旧的 React 节点生成副本并返回。若旧的 React 节点无法被复用，则新生成一个 React 节点并直接返回，进入下一个节点判断。</p>
<p>那么我们如何判断旧节点是否能被复用呢？根据上面的限制我们可以得出，若当前元素的元素类型不同，则直接不复用。若相同，则遍历该旧节点的所有 children，判断元素的 key 和 type 与新节点的子元素是否相同。此时有会出现两种情况：</p>
<p>遍历时找到了子元素的 key 匹配，但此时元素 type 不同，表示该元素类型变更，依据限制 2，不进行复用。此时由于新节点为单 children，因此没有节点会与剩下旧子节点匹配了，直接将旧节点下的所有其他子节点标记为删除，并将新子节点标记为插入。</p>
<p>遍历时发现 key 不同，则表示该旧子节点不能被复用，将当前节点标记为删除，之后接着遍历后续的其它子节点去寻找是否有 key 匹配的子节点。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code>  <span class="token keyword">function</span> <span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span>returnFiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span> currentFirstChild<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> element<span class="token operator">:</span> ReactElement<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> element<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
    <span class="token keyword">let</span> child <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> elementType <span class="token operator">=</span> element<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
        <span class="token comment">// Key 相同，比较 type</span>
        <span class="token class-name"><span class="token keyword">if</span></span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span> <span class="token operator">===</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// type 相同 可以复用</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> elementType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 当前节点可复用，其他兄弟节点都删除</span>
            <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> element<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
            existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>

            <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// key 相同但 type 不同，没法复用。后面的兄弟节点也没有复用的可能性了，都删除</span>
          <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// type 不同，删除旧的，并继续比较</span>
          <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建新节点</span>
    <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromElement</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
    <span class="token keyword">return</span> created<span class="token punctuation">;</span>
</code></pre></div><h3>多节点 Diff（reconcileChildrenArray）</h3>
<p>多节点 Diff 是指<strong>新节点有多个子节点的情况</strong>。这种情况的处理比较复杂，我们需要将新节点的每个子元素 （即 newChildren 数组） 与旧节点的所有兄弟节点 （即 old.sibling) 相比较，去寻找是否有复用的可能，此时，每一次对 old.sibling 的比较都能简化为，old.sibling 与 newChildren 数组进行 diff，判断逻辑应当与单节点 Diff 类似。</p>
<ol>
<li>如果找到可复用元素，则继续遍历其他 newChildren 看是否有可复用。</li>
<li>如果 key 相同，type 不同，由规则 2，不复用。将旧节点标记删除，新节点标记新增。并继续对其他 newChildren 进行遍历。</li>
<li>如果 key 不同导致的不可复用，此时说明该节点位置变更，立即跳出遍历循环，在接下来的逻辑中处理。</li>
<li>如果 newChildren 或者旧 oldfiber.sibling 任意一个遍历完，此时可能有新增新节点，删除旧节点和没有节点变更三种可能，也在接下来的逻辑中处理</li>
</ol>
<p>在这一轮的比较结束后，我们可以来查看并判断一下 newChildren 和 old.sibling 的状态。</p>
<ol>
<li>如果两者都遍历完毕，那说明已经完成所有子节点的比对，Diff 环节结束。</li>
<li>如果 newChildren 遍历完毕，但 old.sibling 还有剩余节点，说明这些剩余节点都是需要删除的。</li>
<li>如果 old.sibling 遍历完毕，但 newChildren 还有剩余节点，说明这些剩余节点都是新增节点，需要创建并插入。</li>
<li>如果两者都没有遍历完毕，说明此时是由上一轮的条件 3 跳出循环的，说明此时有节点改变了位置。</li>
</ol>
<p>这种情况比较复杂，也是 diff 算法处理的精髓所在。可以将剩下的 old.sibling 保存为 map，判断剩余的 newChildren 的 key 是否在 old 节点中存在。若存在则找变更位置，判断 oldIndex 与 lastPlacedIndex 的大小，lastPlacedIndex 初始为 0，若 oldIndex &gt;= lastPlacedIndex，则节点不需要移动，将 lastPlacedIndex = oldIndex，否则将当前节点标记为向右移动。</p>
<p>通过这个实现我们也可以看出来，React Diff 在判断节点是否移动时，是通过从前往后遍历判断移动位置的。因此，从性能优化的角度考虑，我们要尽量减少将节点从后面移动到前面的操作。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 若 newChildren 为数组，则需要遍历比较来更新当前 Fiber 树</span>
<span class="token comment">// 注：该算法不能通过头尾两侧遍历来优化，因为 Fiber 树是单链表结构</span>
<span class="token keyword">function</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span>
  returnFiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  currentFirstChild<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  newChildren<span class="token operator">:</span> <span class="token punctuation">(</span>ReactElement <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> resultingFirstChild<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> previousNewFiber<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 旧 Fiber 列表</span>
  <span class="token keyword">let</span> oldFiber <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>
  <span class="token keyword">let</span> nextOldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// !!! 重要变量。遍历到的最后一个可复用 fiber 在旧节点中的索引位置</span>
  <span class="token keyword">let</span> lastPlacedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 指向当前新节点的索引位置</span>
  <span class="token keyword">let</span> newIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 多节点 Diff 第一次遍历所有旧的和新的子节点，找到需要更新的节点，设置更新标记</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">.</span>index <span class="token operator">&gt;</span> newIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">;</span>
      oldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取最新的 fiber 节点</span>
    <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateSlot</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果此时新旧节点都已经遍历完毕，则直接跳出循环</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 标记该节点的插入状态，并返回标记顺序</span>
    lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果是第一个新子节点，设置 resultingFirstChild，否则将其作为上一个新子节点的兄弟节点。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>

    oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 情况 1：如果新 children 列表已经遍历完成，但旧 children 列表还有剩余节点，删除这些旧的剩余节点，返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newIdx <span class="token operator">===</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 情况 2：旧节点已经遍历完，但还剩余新节点，说明剩余的新节点都是新增节点，直接创建并插入</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">createChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 如果是第一个新子节点，设置 resultingFirstChild，否则将其作为上一个新子节点的兄弟节点。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 情况 3：新旧节点都没遍历完，需要进行 Diff 操作</span>
  <span class="token comment">// 设立一个 map 用于存储所有旧节点，方便后续查找</span>
  <span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 继续遍历剩余的新 fiber 节点，并利用 map，判断新节点为新增节点还是原有旧节点的移动导致。</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateFromMap</span><span class="token punctuation">(</span>
      existingChildren<span class="token punctuation">,</span>
      returnFiber<span class="token punctuation">,</span>
      newIdx<span class="token punctuation">,</span>
      newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将新节点插入，并返回标记顺序</span>
      lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 如果是第一个新子节点，设置 resultingFirstChild，否则将其作为上一个新子节点的兄弟节点。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此我们就已经完全理解并实现了 React Diff 算法的核心逻辑。</p>
<p>在 React 中，Diff 算法的实现是在 React-Reconciler 库中的 ReactChildFiber 模块中。我们可以通过 <a href="https://github.com/facebook/react/blob/v18.3.0/packages/react-reconciler/src/ReactChildFiber.new.js" target="_blank" rel="noopener noreferrer">阅读源码</a> 来了解完整的 React Diff 算法的实现。</p>
<h2>利用 React Diff 特性优化性能</h2>
<p>在进行上面对于实现逻辑的理解中，我们对 React 的底层运行逻辑也有了更深的了解，从而也能更好的触类旁通理解一些 React 的一些性能优化技巧。</p>
<p>例如，我们耳熟能详的如下这些"React 开发最佳实践"，其实都是基于 React Diff 算法的特性而演化出来的。</p>
<h3>避免使用 index 作为 key</h3>
<p>这是由于在 React Diff 中，key 是用来判断节点是否可以复用的重要依据。如果我们使用 index 作为 key，那么在节点的插入和删除时，会导致节点的 key 发生变化，从而导致 React Diff 算法无法正确判断节点是否可以复用，从而会触发不必要的重渲染，导致性能下降。</p>
<div class="language-jsx" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token comment">// good</span>
<span class="token keyword">const</span> items <span class="token operator">=</span> itemsArray<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ListItem</span></span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span></span> <span class="token attr-name">data</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// bad</span>
<span class="token keyword">const</span> items <span class="token operator">=</span> itemsArray<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ListItem</span></span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span></span> <span class="token attr-name">data</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>对复杂组件树进行结构拆分</h3>
<p>在 React Diff 算法中，只有同级同类型的节点才会进行比对。因此，如果我们的组件树结构过于复杂，会导致 React Diff 算法的比对过程变得复杂，从而影响性能。因此，这也是为什么 React 推崇组件封装与拆分，将同级同类型的节点提取出来，从而减少 React Diff 算法的比对复杂度，提高性能。</p>
<div class="language-jsx" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token comment">// 将大型组件拆分为更小的子组件</span>
<span class="token keyword">function</span> <span class="token function">LargeComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> data <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Header</span></span> <span class="token attr-name">title</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>title<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Content</span></span> <span class="token attr-name">items</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>items<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Footer</span></span> <span class="token attr-name">info</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>info<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>避免不必要的重渲染</h3>
<p>在 React Diff 算法中，只有节点的 props 或者 children 发生变化时，才会触发节点的重渲染。因此，我们应该尽可能地保证，当组件在不需要变化时，避免因为传入组件的 props 改变而导致不必要的重渲染。</p>
<p>例如我们可以使用 useMemo (React.memo) 或 useCallback 来避免触发不必要的重渲染。</p>
<div class="language-jsx" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> nextProps<span class="token punctuation">.</span>value <span class="token operator">===</span> prevProps<span class="token punctuation">.</span>value
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>除此之外，包括推荐使用不可变的数据结构，避免频繁地进行 setState 操作，通过 CSS 动画来代替 JS 动画等等，都是基于 React Diff 算法的特性，为了减少不必要的 Diff 开销而推荐的性能优化技巧。</p>
<h2>结语</h2>
<p>所以你看，从一个 React Diff 是怎么实现的八股文中，我们可以学习并融会贯通这么多个性能优化技巧。这无疑才是我认为的真正有价值的技术技巧。</p>
<p>很多时候，我们抵制八股文，本质上是在抵制没有任何基础理解的，应试的死记硬背。比如几乎没有运用场景的 ie 兼容性问题，或者是已经被浏览器优化过的 css 渲染问题。而对那些我们时刻都需要使用到的技术架构，我们更需要仔细研究其核心原理，甚至自己动手实现一遍，这样才能更好地理解其运行机制，在实际工作中遇到性能问题时，有很大的帮助。</p>
]]></content>
    <category term="前端基础"/>
    <published>2024-12-12T19:58:57.000Z</published>
  </entry>
  <entry>
    <title type="text">MongoDB 极简实践入门</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2017-09-17.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2017-09-17.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>为什么用 MongoDB</h2>
<p>传统的计算机应用大多使用关系型数据库来存储数据，比如大家可能熟悉的 MySql, Sqlite 等等，它的特点是数据以表格 (table) 的形式储存起来的。数据库由一张张排列整齐的表格构成，就好像一个 Excel 表单一样，每个表格会有若干列，比如一个学生信息表，可能包含学号、姓名、性别、入学年份、高考成绩、籍贯等等。而表格的每一排，则是一个个学生的具体信息。在企业级应用和前互联网时代，关系型数据库几乎是不二选择。关系型数据库的特点是有整齐划一的组织，很方便对数据进行描述、插入、搜索。</p>
]]></summary>
    <content type="html"><![CDATA[<h2>为什么用 MongoDB</h2>
<p>传统的计算机应用大多使用关系型数据库来存储数据，比如大家可能熟悉的 MySql, Sqlite 等等，它的特点是数据以表格 (table) 的形式储存起来的。数据库由一张张排列整齐的表格构成，就好像一个 Excel 表单一样，每个表格会有若干列，比如一个学生信息表，可能包含学号、姓名、性别、入学年份、高考成绩、籍贯等等。而表格的每一排，则是一个个学生的具体信息。在企业级应用和前互联网时代，关系型数据库几乎是不二选择。关系型数据库的特点是有整齐划一的组织，很方便对数据进行描述、插入、搜索。</p>
<!-- more -->
<p>想象有一个传统的网上服装商店吧，它的主要的数据可能是储存在一张叫 products 的表单里，表单可能包含这些列：商品编号 (ID)、名称 (Name)、商家 (brand)、主目录 (cate)、子目录 (sub-cat)、零售价 (price)、是否促销 (promotion) 等等。如果有一个用户想要查找所有价格低于 300 元的正在促销的鞋子的编号和名称，则可以执行类似于以下的 SQL 语句：</p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> ID<span class="token punctuation">,</span> name <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> cate<span class="token operator">=</span><span class="token string">'shoes'</span> <span class="token operator">AND</span> price<span class="token operator">&lt;</span><span class="token number">300</span> <span class="token operator">and</span> <span class="token operator">AND</span> promotion<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p>SQL 具备了强大了的深度查询能力，能满足各式各样的查询要求。而如果要对数据进行添加和删除，成本也是非常低的。这些是 SQL 的优势之一， 但随着互联网的兴起以及数据形式的多样化，四平八稳的 SQL 表单在一些领域渐渐显现出它的劣势。让我们通过一个例子来说明。考虑一个博客后台系统，如果我们用关系型数据库为每篇博客 (article) 建一个表单的话，这个表单大概会包括以下这些列：</p>
<p>| ID  | Title  |    Description    | Author |  Content  | Likes |
|</p>
]]></content>
    <category term="前端技术研究院"/>
    <published>2017-09-17T17:13:38.000Z</published>
  </entry>
  <entry>
    <title type="text">给 JavaScript 插上多线程的翅膀 —— Web Worker 的 Promise 化实践</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2020-06-16.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2020-06-16.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在现代大型前端项目中，随着代码的复杂程度越来越高，本地的计算型事务也在变得繁重，而运行在单线程下 JavaScript 项目必定会忙于处理计算而无暇顾及用户接下来的频繁操作，造成卡顿等不太好的用户体验，更严重的情况是，当计算型事务过多时还有可能因为资源被占满带来网页无响应的卡死现象。因此，Web 项目的本地多线程运算能力势在必行，由此，Web Worker 应运而生了。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在现代大型前端项目中，随着代码的复杂程度越来越高，本地的计算型事务也在变得繁重，而运行在单线程下 JavaScript 项目必定会忙于处理计算而无暇顾及用户接下来的频繁操作，造成卡顿等不太好的用户体验，更严重的情况是，当计算型事务过多时还有可能因为资源被占满带来网页无响应的卡死现象。因此，Web 项目的本地多线程运算能力势在必行，由此，Web Worker 应运而生了。</p>
</div><!-- more -->
<h2>Web Worker 介绍</h2>
<p>众所周知，JavaScript 这门语言的一大特点就是单线程，即同一时间只能同步处理一件事情，这也是这门语言衍生出的 nodeJS 被后端开发诟病的的一点。</p>
<p>然而，JavaScript 在设计之初，其实是故意被设计成单线程语言的，这是由于它当时的主要用途的决定的。</p>
<p>JavaScript 最初的设计初衷是完成页面与用户的交互，操作 DOM 或者 BOM 元素，此时如果一味地追求效率使用多线程的话，会带来资源抢占，数据同步等等问题，因此必须规定，同一时间只有一个线程能直接操作页面元素，以保证系统的稳定性以及安全性。</p>
<p>尽管如此，但是 JavaScript 并不是只能线性处理任务。JS 拥有消息队列和事件循环机制，通过异步处理消息的能力来实现并发。在高 I/O 型并发事务处理的过程中，由于不需要手动生成与销毁线程以及占用额外管理线程的空间，性能表现及为优异。因此，nodeJS 作为 JavaScript 在服务端的探索者，在处理高并发网络请求的优势极为明显。</p>
<p>尽管 JavaScript 通过异步机制完美解决了高 I/O 性能的问题，但 JavaScript 单线程执行的本质还是没有变的。因此缺点就显而易见了，那就是处理 CPU 密集型的事务时没有办法充分调动现代多核心多线程机器的运算资源。</p>
<p>在现代大型前端项目中，随着代码的复杂程度越来越高，本地的计算型事务也在变得繁重，而运行在单线程下 JavaScript 项目必定会忙于处理计算而无暇顾及用户接下来的频繁操作，造成卡顿等不太好的用户体验，更严重的情况是，当计算型事务过多时还有可能因为资源被占满带来网页无响应的卡死现象。因此，Web 项目的本地多线程运算能力势在必行，由此，Web Worker 应运而生了。</p>
<p>Web Worker 是 HTML5 中推出的标准，官方是这样定义它的：</p>
<blockquote>
<p>Web Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application.</p>
</blockquote>
<p>它允许 JavaScript 脚本创建多个线程，从而充分利用 CPU 的多核计算能力，不会阻塞主线程(一般指 UI 渲染线程)的运行。</p>
<p>Web Worker 虽然是 HTML5 标准，但其实早在 2009 年 W3C 就已经提出了草案，因此它的兼容性良好，基本覆盖了所有主流浏览器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20200703113954.png" alt="20200703113954"></p>
<h2>Web Worker 的局限</h2>
<p>需要注意的是，Web Worker 本质上并没有突破 JavaScript 的单线程的性质。</p>
<p>事实上，Web Worker 脚本中的代码并不能直接操作 DOM 节点，并且不能使用绝大多数 BOM API。它的全局环境是 DedicatedWorkerGlobalScope 而并不是 Window。运行 Worker 的实际上是一个沙箱，跑的是与主线程完全独立 JavaScript 文件。</p>
<p>Worker 做的这些限制，实际上也是为了避免文章开头说过的抢占问题。它更多的使用场景是作为主线程的附属，完成高 CPU 计算型的数据处理，再通过线程间通信将执行结果传回给主线程。在整个过程中，主线程仍然能正常地相应用户操作，从而很好地避免页面的卡顿现象。</p>
<h2>Web Worker 的使用</h2>
<h3>新建</h3>
<p>目前 Web Worker 的浏览器支持已经较为完善，基本上直接传入 Worker 脚本的 URI 并实例化即可使用。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* main.js */</span>

<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">"./worker.js"</span><span class="token punctuation">)</span>
</code></pre></div><h3>通信</h3>
<p>Worker 与主线程之间的通信只需要各有两个 API：onmessage/addEventListener 与 postMessage 即可完成收发消息的交互。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* main.js */</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">"./worker.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 主线程发送消息</span>
worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token string">'mainthread send data'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 主线程接收消息</span>
worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* worker.js */</span>
<span class="token comment">// worker 线程接收消息</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// worker 线程发送消息</span>
    self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token string">'worker received data'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注：Worker 中，this.xxx，self.xxx 与直接使用 xxx，其作用域都指向 worker 的全局变量 DedicatedWorkerGlobalScope，可以互换。</p>
<h3>销毁</h3>
<p>Worker 的销毁方式有两种，既能在内部主动销毁，也能够被主线程通知销毁。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* main.js */</span>
worker<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* worker.js */</span>
self<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>进阶：让通信方式 Promise 化</h2>
<p>根据上一节，我们已经能够简单地使用 Worker 的 API 来获取浏览器多线程计算的能力，但是它离工程化的应用还缺少了一些易用性，比如我们多数时候需要使用到的异步相应。接下来我们就来做这件事情。</p>
<p>首先我们需要一个异步回调集合 actionHandlerMap，用于存放等待 Worker 响应的 Promise resolve 方法，其 key 值可以用通信中的某一 id 指定(保证其唯一性即可)。接着我们需要封装一下原生的 postMessage 与 onmessage 方法。</p>
<p>我们在原生的 postMessage 发送的信息中加入 id，并将当前的 Promise 的 resolve 方法放入 actionHandlerMap，等待 Worker 返回结果后触发。</p>
<p>对于 onmessage 的监听，在接收到 Worker 发送过来的响应之后，匹配响应的 Promise 并执行 .then() 方法，完成后删除集合中的 Promise resolve 函数。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* main.js */</span>
<span class="token keyword">let</span> fakeId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">MainThreadController</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>workerUrl<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> options<span class="token punctuation">.</span>workerName <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 等待异步回调集合</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onmessage</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">onmessage</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> response <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">// 执行相应的 Promise resolve</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实际使用中，可以指定或生成一个业务 id 作为 key 值</span>
        <span class="token keyword">const</span> id <span class="token operator">=</span> fakeId<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token punctuation">{</span>
                id<span class="token punctuation">,</span>
                <span class="token operator">...</span>action<span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> mainThreadController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MainThreadController</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">workerUrl</span><span class="token operator">:</span> <span class="token string">'./worker.js'</span><span class="token punctuation">,</span> <span class="token literal-property property">workerName</span><span class="token operator">:</span> <span class="token string">'test-worker'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mainThreadController
    <span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">actionType</span><span class="token operator">:</span> <span class="token string">'asyncCalc'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">'send messages to worker'</span><span class="token punctuation">,</span> <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'message received from worker: '</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对于 worker 部分的处理就简单得多，计算处理完毕后，在响应回复中带上请求的 id 即可。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* worker.js */</span>
<span class="token keyword">class</span> <span class="token class-name">WorkerThreadController</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>worker <span class="token operator">=</span> self<span class="token punctuation">;</span>

        <span class="token comment">// 等待异步回调集合</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onmessage</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">async</span> <span class="token function">onmessage</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> actionType<span class="token punctuation">,</span> payload <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>actionType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'print'</span><span class="token operator">:</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> <span class="token literal-property property">response</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">'msg has been print.'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">'asyncCalc'</span><span class="token operator">:</span>
                <span class="token comment">// 构造一个异步处理情形</span>
                <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>params <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> <span class="token literal-property property">response</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">the caculated answer is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>

            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> workerThreadController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WorkerThreadController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，worker 这边的改造还能够更进一步。我们发现，当 Worker 需要接收的计算种类增多，使用 switch 方式包裹的 onmessage 函数就会变得冗长，使用字符串判断也不够可靠，我们可以用策略模式简单地封装一下 Worker 中的逻辑。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">/* worker.js */</span>
<span class="token comment">// 可以单独抽成一个文件，然后 import 进来</span>
<span class="token keyword">const</span> api <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token parameter">payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">'msg has been print.'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">async</span> <span class="token function">asyncCalc</span><span class="token punctuation">(</span><span class="token parameter">payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>params <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">the caculated answer is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">WorkerThreadController</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>worker <span class="token operator">=</span> self<span class="token punctuation">;</span>

        <span class="token comment">// 等待异步回调集合</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>actionHandlerMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onmessage</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">async</span> <span class="token function">onmessage</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> actionType<span class="token punctuation">,</span> payload <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> api<span class="token punctuation">[</span>actionType<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
        self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> <span class="token literal-property property">payload</span><span class="token operator">:</span> result <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> workerThreadController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WorkerThreadController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>至此，一个简单好用的 Promise Worker 就建立完成了。</p>
<p>当然，为了增加框架的鲁棒性，我们还应该加入类似于错误处理，报错及监控数据上报等等能力。由于不属于本文探讨的范围，这里就先按住不表，有兴趣的读者可以参看 AlloyTeam 最新开源的 <a href="https://github.com/AlloyTeam/alloy-worker" target="_blank" rel="noopener noreferrer">alloy-worker</a> 项目，其中对上述存在的问题进行了全面的补足，是一个较为完善的高可用的 Worker 通信框架。</p>
<h2>总结</h2>
<p>本文对 Web Worker 进行了简要的介绍，包括其能力以及局限性，让读者对 Worker 的使用场景有一个全面的了解。提出了一种封装 Worker 原生 API 使之能被 Promise 化调用的解决方案，并在最后推荐了团队内正在使用的功能完善的成熟解决方案，希望能帮助到近期有兴趣进行 Worker 改造的前端开发者们。</p>
]]></content>
    <category term="前端技术研究院"/>
    <published>2020-06-16T21:04:10.000Z</published>
  </entry>
  <entry>
    <title type="text">实现一个版本自动控制的 IndexedDB</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2020-07-13.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2020-07-13.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>随着现代大型项目复杂度的提升，渲染一个 WEB 页面需要的数据越来越多，在多次打开并渲染的过程中，有许多数据都是重复并且不常更新的，因此这部分的数据需要通过浏览器缓存来缓解网络压力，同时提升页面打开速度。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>随着现代大型项目复杂度的提升，渲染一个 WEB 页面需要的数据越来越多，在多次打开并渲染的过程中，有许多数据都是重复并且不常更新的，因此这部分的数据需要通过浏览器缓存来缓解网络压力，同时提升页面打开速度。</p>
</div><!-- more -->
<h2>IndexedDB 的存储方案比较</h2>
<p>在 IndexedDB 推出以前，浏览器数据的存储方案就已经有了一些实现，例如 cookie，localStorage 等等。</p>
<p>cookie 不用多说，每次都需要随着请求全部带给服务端，并且大小只有可怜的 4KB。cookie 用来做存储数据缓存必然会给网络请求带来更大的压力，因此在该种情况下不是一个合适的载体。</p>
<p>localStorage 作为一个 HTML5 标准，很适合用来做存储数据的本地缓存，并且它能够在不同的标签页之间共享数据，一些网站利用这个特点能够实现一些神奇的操作。它的存储限制比 cookie 要大，根据浏览器的实现不同，大部分浏览器至少支持 5MB - 50MB 的存储。但是，由于 localStorage 的实现与 cookie 类似，存储格式只能为 key-value, 并且 value 只能为 string 类型。因此需要存储复杂类型时，还必须得进行一次 JSON 的序列化转换。于此同时，localStorage 的读写是同步的，会阻塞主线程的执行，因此在存取复杂类型或大数据量的缓存数据时，localStorage 并不是一个很合适的选择。</p>
<p>为了解决 localStorage 存在的上述问题，W3C 提出了浏览器数据库 —— IndexedDB 标准。一个<em>无大小限制</em>的(一般只取决于硬盘容量)、<em>异步</em>的、<em>支持存储任意类型数据</em>的浏览器存储方案。</p>
<h2>IndexedDB 的基本概念</h2>
<p>要学习 IndexedDB 的使用，首先得了解它的一些核心概念。</p>
<h3>数据库版本</h3>
<p>和所有数据库一样，IndexedDB 也有 Database 的概念。每个同源策略下，都可以有多个数据库。</p>
<p>由于 IndexedDB 存在于客户端，数据存储在浏览器中。因此开发人员不能直接访问它。因此 IndexedDB 有一个独特的 scheme 版本控制机制，引申出来数据库版本的概念。同一时间统一数据库只保留唯一且最新的版本，低于此版本的标签页会触发 upgradeneeded 事件升级版本库。修改数据库结构的操作(如增删表、索引等)，只能通过升级数据库版本完成。</p>
<h3>ObjectStore</h3>
<p>IndexedDB 用来存储数据集的单位是 ObjectStore，相当于关系型数据库的表，或是非关系型数据库的集合。</p>
<h3>事务</h3>
<p>事务相当于是一个原子操作，在一个事务中若出现报错，整个事务之中执行的所有功能都不会生效。从而使得数据库能够保证数据一致性，提升业务可靠性。</p>
<p>IndexedDB 的一大特点就是事务化，所有的数据操作都必须被包裹在事务之内执行。IndexedDB 的层级关系为：请求 -&gt; 事务 -&gt; 数据库，我们也可以通过这个关系链来进行错误处理的事件委托，从而集中错误捕获逻辑处理。</p>
<h2>IndexedDB API 的原生使用</h2>
<p>IndexedDB 的 API 较为繁杂，由于并不是本文要讲的重点，在此不展开，对原生 API 感兴趣的可以参考一下 MDN 的文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API</a>。</p>
<p>由于原生 API 的异步过程采用的是<em>监听回调机制</em>，在现代项目中使用起来不是很方便，一般来说推荐使用 Promise 的方式在外部封装一层，更能够贴合现代项目的使用场景。</p>
<h2>建立版本自动控制的 IndexedDB</h2>
<h3>解决思路</h3>
<p>从使用文档中可以知道，IDBFactory.open 方法用于打开一个数据库连接，它通过传入数据库名称以及版本号 version 两个参数，执行以下步骤，并在相应的时期触发指定回调的钩子。</p>
<blockquote>
<ol>
<li>指定数据库已经存在时，等待 versionchange 操作完成。如果数据库已计划删除，那等着删除完成。</li>
<li>如果已有数据库版本高于给定的 version，中止操作并返回 Error。</li>
<li>如果已有数据库版本，且版本低于给定的 version，触发一个 versionchange 操作。</li>
<li>如果数据库不存在，创建指定名称的数据库，将版本号设置为给定版本，如果没有给定版本号，则设置为 1。</li>
<li>创建数据库连接。</li>
</ol>
</blockquote>
<p>从这里可以看出，这个方法兼具了创建数据库与建立数据库连接两个功能，这里与我们常用数据库的操作不太一致，因此使用起来会有些奇怪。</p>
<p>事实上，IndexedDB 的设计初衷及推荐用法是让我们在代码中硬编码 version 这个版本号，从而在触发的 versionchange 事件中根据版本号不同给出确定的响应。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>    <span class="token keyword">const</span> <span class="token literal-property property">openRequest</span><span class="token operator">:</span> IDBOpenDBRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbFactory<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">,</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span>

    openRequest<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">versionChangeCb</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>oldVersion <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> objectStore <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span><span class="token string">'test_objectStore'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>oldVersion <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">...</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token operator">...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这与我们对熟悉的数据库认知是不一致的。有的时候，我们希望 IndexedDB 只像一个建立在浏览器本地的普通的数据库一样在项目执行时进行任意的增删表操作，并不想关心当前最新的版本号是多少，希望能自动控制版本。</p>
<p>而现有的IndexedDB能力对于这样的使用场景来说就变得非常艰难。因为在不知道当前最新版本号的情况下根本没法打开最新版本的数据库，并且，在不打开数据库得到数据库实例之前也没法获取当前数据库的最新版本！这就形成了一个死结，我们必须在某个本地位置记录下当前数据库的最新版本，以便下次打开表时能够直接读取到。</p>
<p>理清了处理思路，接下来就是具体的实现环节。</p>
<h3>本地存取某个数据库的最新版本</h3>
<p>首先我们需要解决的就是在本地存储版本号的问题。</p>
<p>本地存取的方式有很多，在之前也简单介绍过各种本地存储的解决方案。在这里，考虑到最大的兼容性，使用的是多使用一个版本固定不变的IndexedDB数据库。(这里使用 localStorage 等存储方案也同样合适)</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code>    <span class="token keyword">private</span> <span class="token function">getDBLatestVersion</span><span class="token punctuation">(</span>dbName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> openRequest<span class="token operator">:</span> IDBOpenDBRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbFactory<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'DBVersion'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">OPEN_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">const</span> objectStore <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'version'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'readonly'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">const</span> request <span class="token operator">=</span> objectStore<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dbName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 找不到说明应该是新建的数据库</span>
                request<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
                request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>result<span class="token operator">?.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">resolve</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>result<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">const</span> objectStore <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
                    keyPath<span class="token operator">:</span> <span class="token string">'dbName'</span><span class="token punctuation">,</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                objectStore<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span><span class="token string">'dbName'</span><span class="token punctuation">,</span> <span class="token string">'dbName'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                objectStore<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token function">updateDBLatestVersion</span><span class="token punctuation">(</span>dbName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> newVersion<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> openRequest<span class="token operator">:</span> IDBOpenDBRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbFactory<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'DBVersion'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">OPEN_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">const</span> objectStore <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'version'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'readwrite'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 更新数据库版本字段</span>
                <span class="token keyword">const</span> updateRequest <span class="token operator">=</span> objectStore<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span> dbName<span class="token punctuation">,</span> version<span class="token operator">:</span> newVersion <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                updateRequest<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>
                updateRequest<span class="token punctuation">.</span>onsuccess <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">const</span> objectStore <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
                    keyPath<span class="token operator">:</span> <span class="token string">'dbName'</span><span class="token punctuation">,</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                objectStore<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span><span class="token string">'dbName'</span><span class="token punctuation">,</span> <span class="token string">'dbName'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                objectStore<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这里使用<em>dbName</em>与<em>version</em>两个字段来对每一个数据库以及其最新版本进行存储映射。这里需要注意的是，若是无法在这里找到该数据库名称，说明应该是数据库在新建过程中，也是正常情况，根据建表方法所需，返回0。</p>
<h3>建立数据库连接</h3>
<p>为了像普通数据库一样操作，首先我们需要拆分IndexedDB.open这个API的建立连接和新增表这两个功能，先来看建连部分。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code>    <span class="token keyword">private</span> <span class="token function">getDBConnection</span><span class="token punctuation">(</span>version<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>IDBDatabase<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hasDBOpened <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> openRequest<span class="token operator">:</span> IDBOpenDBRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbFactory<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">,</span> version <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">CONNECTION_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onblocked</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">CONNECTION_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>hasDBOpened <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>openRequest<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            <span class="token comment">// 此时会新建一个数据库，不正确的调用</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">CONNECTION_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>db <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hasDBOpened <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这块逻辑挺好理解，在取得最新版本号后打开数据库，并对高于或低于当前版本的输入均抛出报错。目的是为了确保该方法仅执行打开连接的操作。</p>
<p>断开连接即使用 IDBDatabase.close 方法，并重置标记位即可。</p>
<h3>增删表操作</h3>
<p>新建表的逻辑为，再打开数据库前，先获取到当前数据库的最新版本，并在该基础上+1，这是为了确保触发onupgradeneeded事件，从而在这里进行更新数据库版本与创建新表的操作。</p>
<p>由于版本号是一个 unsigned long long 类型，因此不要使用浮点数来记录它的版本，否则会被强行取整。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code>    <span class="token keyword">public</span> <span class="token function">createTable</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token punctuation">{</span>
        tableName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
        objectStoreOptions
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>IDBDatabase<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hasDBOpened<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">const</span> <span class="token punctuation">{</span> tableName<span class="token punctuation">,</span> createIndexParamsArr<span class="token punctuation">,</span> primaryKey <span class="token punctuation">}</span> <span class="token operator">=</span> options<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> version <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDBLatestVersion</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> newVersion <span class="token operator">=</span> version <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

            <span class="token keyword">const</span> openRequest<span class="token operator">:</span> IDBOpenDBRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbFactory<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">,</span> newVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>

            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// 版本更新</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>dbVersion <span class="token operator">=</span> newVersion<span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateDBLatestVersion</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">,</span> newVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>

                db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span>tableName<span class="token punctuation">,</span> objectStoreOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>hasDBOpened <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>openRequest<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">OPEN_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onblocked</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>删表也是同理</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>    <span class="token keyword">public</span> <span class="token function">deleteTable</span><span class="token punctuation">(</span>tableName<span class="token operator">:</span> string<span class="token punctuation">)</span><span class="token operator">:</span> Promise<span class="token operator">&lt;</span>IDBDatabase<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hasDBOpened<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> version <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDBLatestVersion</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> newVersion <span class="token operator">=</span> version <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

            <span class="token keyword">const</span> <span class="token literal-property property">openRequest</span><span class="token operator">:</span> IDBOpenDBRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dbFactory<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">,</span> newVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// 版本更新</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>dbVersion <span class="token operator">=</span> newVersion<span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateDBLatestVersion</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dbName<span class="token punctuation">,</span> newVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">const</span> db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>db<span class="token punctuation">.</span>objectStoreNames<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    db<span class="token punctuation">.</span><span class="token function">deleteObjectStore</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">CAN_NOT_FIND_TABLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>db <span class="token operator">=</span> openRequest<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>openRequest<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            openRequest<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">INDEXEDDB_ERROR</span><span class="token punctuation">.</span><span class="token constant">OPEN_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>至此，就能实现一个能够进行自动版本控制的 IndexedDB promise 封装了。</p>
<p>当然，接下来还需要对表的增删改查进行promise化处理，并支持批量增删、索引与主键查询、多条件查询等等，就能封装成一个完整可用的库了。由于跟本次主题无关，就不将代码贴上来了，感兴趣的可以自己实现一下。</p>
]]></content>
    <category term="前端技术研究院"/>
    <published>2020-07-13T16:05:22.000Z</published>
  </entry>
  <entry>
    <title type="text">有向无环图的模型设计与应用</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2020-11-02.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2020-11-02.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>对于我们程序开发者来说，想要学习一个框架，从开发一个 TodoList 项目做起，这就像学习语言先学会写 Hello world 一样基础。但其实，简单的 TodoList 里面，同样可以蕴含一些复杂的算法思想。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>对于我们程序开发者来说，想要学习一个框架，从开发一个 TodoList 项目做起，这就像学习语言先学会写 Hello world 一样基础。但其实，简单的 TodoList 里面，同样可以蕴含一些复杂的算法思想。</p>
</div><!-- more -->
<h2>从 TodoList 说起</h2>
<p>对于我们程序开发者来说，想要学习一个框架，从开发一个 TodoList 项目做起，这就像学习语言先学会写 Hello world 一样基础。但其实，简单的 TodoList 里面，同样可以蕴含一些复杂的算法思想。</p>
<p>设想一下，今天需要完成若干个任务，需要规划一下工作流，可以通过 TodoList 记录下来。但与普通的线性工作不同的是，每条工作任务可能会有若干个前置工作，那么现在我们该如何分配工作顺序呢？</p>
<p>其实这样的事情在我们自己平时的工作中经常遇到，而我们通常的做法是：优先找出不需要做前置工作的任务，将其完成。再寻找剩下的工作任务中，是否有已经将所有前置工作做完的任务，在接下来完成。如此往复，直到所有工作都已经被完成。</p>
<p>事实上，不知不觉中，我们已经悄然构建了一个有向无环图，并对其进行好了拓扑排序，按照拓扑序列的结果执行任务了。</p>
<h2>有向无环图与拓扑排序</h2>
<p>啥啥啥？我怎么不知道？</p>
<p>你看，每一个任务与它的前置任务之间都存在着一个父子关系。由于每个任务的前置可以有多个，因此使用有向图而不是有向树来表示更为合适。而已经做过的工作不会在被重复做一遍，因此工作流中不可能形成环路，从第一个工作开始，至最后一个工作结束，对于每个任务的执行必定是有且只有一遍的。而这，也就是有向无环图(Directed Acyclic Graph，下称 DAG 图)的定义了：</p>
<blockquote>
<p>如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图。</p>
</blockquote>
<p>而拓扑序列，实际上指的是一个 DAG 图的所有顶点的线性序列，即将一个二维图展平成一维链的一种表示形式。</p>
<p>并非所有有向图都能生成拓扑序列，我们必须确保该图是不存在环的。</p>
<p>而检查有向图是否存在环的方法，我们可以跟无向图一样，以深度优先遍历的方式查找图，并在遍历时对节点染色，以方便判断该节点是否已被访问过。而其实，我们可以直接使用拓扑排序算法来更直观的进行判断。</p>
<p>拓扑排序的具体方法如下：先统计所有节点的入度，找到一个入度为 0 的节点作为序列的第一个节点，将该点从图中删去，同时删去以该节点为弧尾的所有有向边，并将有向边指向的顶点入度减一，得到一个新图，之后重复以上操作。</p>
<p>举个例子，假设有这样一个 DAG 图，其拓扑排序的算法演示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20201012172421.png" alt="20201012172421"></p>
<p>这样最终得到的拓扑序列为：</p>
<p>A -&gt; D -&gt; E -&gt; B -&gt; C</p>
<p>操作结束时，若未删去所有的节点，即出现找不到入度为 0 的节点，则说明剩余的节点形成了一个环路，即该图有环，此时该函数就抛出错误，存在循环引用，终止计算。</p>
<h2>DAG 图数据模型设计</h2>
<p>在了解了 DAG 图的工作原理之后，接下来我们就可以撸起袖子开干了。</p>
<p>为了生成一个稳定的 DAG 图，首先我们需要一个严谨的数据模型作为工程的支撑。我们可以将项目的实现分为控制器与构成单元两个部分：</p>
<p>控制器部分负责 DAG 类整体的信息读取与写入，如查看布局信息，节点生成的拓扑序列，以及具体节点的增删改查等方法并在操作之后维持图的正确性，等等。</p>
<p>构成单元部分则相对简单，负责存放图中的自定义的顶点 node 以及关联关系 edge 的相关信息。</p>
<p>通过对这两部分的数据模型设计，即可描述一个完整的 DAG 图的状态扭转关系以及查改任意一处的数据或关联关系了。于是我们可以设计出一套基础且通用的数据模型，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/20201103175325.png" alt="20201103175325"></p>
<h2>图结构变化后依赖关系的修复</h2>
<p>在上节数据模型中提到的 <code>高级 API</code> 对 DAG 图的操作中，都提到了一个子图的修复或重建行为，这也恰恰是这个算法中的难点，值得单独抽出来简要说一说。</p>
<p>当我们增加一个节点时，在设置好所有的邻边关系后，还需要对整图进行一次拓扑排序以排除存在环的可能。当存在环时，增加节点时添加的那条边可能会被弃用，以永远维持依赖图有向无环的稳定性。</p>
<p>当我们删除一个节点时，会使得其该节点所关联的所有入度与出度失效，因此处理这种情况时，应该先去除该节点所有的入度，取消掉对这些节点的监听，并沿着出度染色所有依赖该节点的继任节点，之后更新邻接表。</p>
<p>由于前置节点删除导致这些染色节点无法完成原本的计算，因此也需要将这些染色节点进行清除处理(当然，染色节点是可以根据具体产品策略来判断是否需要保留的，如保留节点但存储的数据结果返回错误)。</p>
<p>觉得比较难以理解的话，我们可以在下节的例子中实践一下。</p>
<h2>在 Excel 中依赖图的应用</h2>
<p>在 Excel 的设计中，函数功能是一个非常重要且难点极多的部分。设计函数功能，其中的难点在于：如何以代价最小的方式获取到该 Excel 函数所有依赖的数据，并能建立起对这些依赖数据的监听机制，在依赖数据更改时触发重算。</p>
<p>而对于这样复杂且频繁的数据变更，显然使用普通处理事件的方式：订阅者模式是不适用的，我们很难及时地进行事件的挂载与清理。</p>
<p>我们知道，在 Excel 表格中，一个单元格，既可以依赖多个单元格的数据，该单元格的运算结果也可以被多个单元格所依赖。并且当单元格之间形成了相互依赖时会报出循环引用 <code>"#REF!"</code> 错误。</p>
<p>经过了之前的介绍，我们很容易想到，函数的依赖关系恰好是符合 DAG 图的特性的，因此我们采用该数据结构来存储表格内所有函数之间的依赖关系，称为表格的<code>依赖图</code>。</p>
<p>依赖图中拥有多个单元格中存储的数据作为图顶点，(当然，在 Excel 中作为顶点的可以是任何依赖图中其它顶点的自定义数据，以下统一称之为数据节点)，这些顶点之间存在的依赖关系作为图的边。</p>
<p>当依赖图建立完成以后，我们就能够处理任意一处的数据变更导致所有依赖节点的数据重算了。从变更的节点开始进行拓扑排序，依照生成的拓扑序列依次重算所有继任节点，直到所有相关节点数据都被更新完成。</p>
<p>我们来举一个例子，模拟一下计算机是怎样处理表格的依赖关系的。</p>
<p>假如有如下的一个 Excel 表格：</p>
<p>|        |   A    |   B    |
| :</p>
]]></content>
    <category term="前端技术研究院"/>
    <published>2020-11-02T15:59:22.000Z</published>
  </entry>
  <entry>
    <title type="text">大型前端项目 DevOps 沉思录 -- CI 篇</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2021-05-11.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2021-05-11.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p><code>DevOps</code>一词源于<code>Development</code> 和 <code>Operations</code> 的组合，即将软件交付过程中开发与测试运维的环节通过工具链打通，并通过自动化的测试与监控，减少团队的时间损耗，更加高效稳定地交付制品。</p>
<p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续集成阶段</code> 需要提供的能力，将对工作流的设计及流水线的优化思路做一个简要讲解。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p><code>DevOps</code>一词源于<code>Development</code> 和 <code>Operations</code> 的组合，即将软件交付过程中开发与测试运维的环节通过工具链打通，并通过自动化的测试与监控，减少团队的时间损耗，更加高效稳定地交付制品。</p>
<p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续集成阶段</code> 需要提供的能力，将对工作流的设计及流水线的优化思路做一个简要讲解。</p>
</div><!-- more -->
<p>随着项目规模越来越大，功能特性与维护人员越来越多，特性交付频率与软件质量之间的矛盾日渐尖锐，如何平衡两者成为了目前团队亟需关注的一个重点，于是，落地一个完善的<code>DevOps</code>工具链便被提上日程。</p>
<p>我们认为，从代码集成、功能测试，到部署发布、基础设施架构管理，每一个环节都应该有全面且完善的自动化监控手段，并尽量避免人工介入。只有这样，软件才能同时兼顾质量与效率，在提高发布频率的情况下保证可靠性。这是每一个成功的大型项目最终一定要实现的目标。</p>
<p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续集成阶段</code> 需要提供的能力，将对工作流的设计及流水线的优化思路做一个简要讲解。</p>
<h2>当我们在谈论 CI 时，我们在谈论什么</h2>
<p>CI(Continuous Integration)，即持续集成，指频繁地(一天多次)将代码集成到主干的行为。</p>
<p>注意，这里既包含持续将代码集成到主干的含义，也包含持续将源码生成可供实际使用的制品的过程。因此，我们需要通过 CI，自动化地保证代码的质量，并对其构建产物转换生成可用制品供下一阶段调用。</p>
<p>因此，在 CI 阶段，我们至少有如下阶段需要实现：</p>
<ol>
<li>静态代码检查</li>
</ol>
<p>这其中包括，ESLINT/TSLINT 静态语法检查，验证 git commit message 是否符合规范，提交文件是否有对应 owner 可以 review 等等。这些静态检查不需要编译过程，直接扫描源代码就可以完成。</p>
<ol start="2">
<li>单元测试/集成测试/E2E 测试</li>
</ol>
<p>自动化测试这一环节是保障制品质量的关键。测试用例的覆盖率及用例质量直接决定了构建产物的质量，因此，全面且完善的测试用例也是实现持续交付的必备要素。</p>
<ol start="3">
<li>编译并整理产物</li>
</ol>
<p>在中小型项目中，这一步通常会被直接省略，直接将构建产物交由部署环节实现。但对于大型项目来说，多次频繁的提交构建会产生数量庞大的构建产物，需要得到妥善的管理。产物到制品的建立我们接下来会有详细讲解。</p>
<h2>利于集成的工作流设计</h2>
<p>在正式接入 CI 前，我们需要规划好一种新的工作流，以适应项目切换为高频集成后可能带来的问题与难点。这里涉及到的改造层面非常多，除了敦促开发人员习惯的转变以及进行新流程的培训外，我们主要关心的是源码仓库的更新触发持续集成步骤的方式。</p>
<h3>流水线的组织形式</h3>
<p>我们需要一个合适的组织形式来管理一条 CI 流水线该在什么阶段执行什么任务。</p>
<p>市面上有非常多的 CI 工具可以进行选择，仔细观察就会发现，无论是 Drone 这样的新兴轻量的工具，亦或是老牌的 Jenkins 等，都原生或通过插件方式支持了这样一个特性：<code>Configuration as Code</code>，即使用配置文件管理流水线。</p>
<p>这样做的好处是相当大的。首先，它不再需要一个 web 页面专门用于流水线管理，这对于平台方来说无疑减少了维护成本。其次对于使用方来说，将流水线配置集成在源码仓库中，享受与源码同步升级的方式，使得 CI 流程也能使用 git 的版本管理进行规范与审计溯源。</p>
<p>确立了流水线的组织形式后，我们还需要考虑版本的发布模式以及源码仓库的分支策略，这直接决定了我们该以什么样的方式规划流水线进行代码集成。</p>
<h3>版本发布模式的取舍</h3>
<p>在《持续交付 2.0》一书中提到，版本发布模式有三要素：<code>交付时间、特性数量以及交付质量</code>。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210525201849.png" alt="20210525201849"></p>
<p>这三者是相互制衡的。在开发人力与资源相对固定的情况下，我们只能对其中的两个要素进行保证。</p>
<p>传统的项目制发布模式是牺牲了交付时间，等待所有特性全部开发完成并经历完整人工测试后才发布一次新版本。但这样会使得交付周期变长，并且由于特性数量较多，在开发过程中的不可控风险变高，可能会导致版本无法按时交付。不符合一个成熟的大型项目对于持续交付的要求。</p>
<p>对于持续集成的思想来说，当我们的集成频率足够高，自动化测试足够成熟且稳定时，完全可以不用一股脑的将特性全堆在一次发布中。每开发完成一个特性就自动进行测试，完成后合入等待发布。接下来只需要在特定的时间周期节点自动将已经稳定的等待中的特性发布出去即可。这对于发布频率越来越高，发布周期越来越短的现代大型项目中无疑是一个最优解。</p>
<h3>分支策略</h3>
<p>与大部分团队一样，我们原有的开发模式也是<code>分支开发，主干发布</code>的思想，分支策略采用业界最成熟也是最完善的<code>Git-Flow</code>模式。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210601150436.png" alt="gitflow"></p>
<p>可以看出，该模式在特性开发，bug 修复，版本发布，甚至是 hotfix 方面都已经考虑到位了，是一个能应用在生产环境中的工作流。但整体的结构也因此变得极为复杂，不便管理。例如进行一次 hotfix 的操作流程是：从最新发布前使用的主干分支拉出 hotfix 分支，修复后合入到 develop 分支中，等待下一次版本发布时拉出到 release 分支中，发布完成后才能合回主干。</p>
<p>此外，对于<code>Git-Flow</code>的每一个特性分支来说，并没有一个严格的合入时间，因此对于较大需求来说可能合入时间间隔会很长，这样在合入主干时可能会有大量的冲突需要解决，导致项目工期无端延长。对此，做大型改造与重构的同学应该深有体会。</p>
<p>针对这一点，我们决定大胆采用<code>主干开发，主干发布</code>的分支策略。</p>
<p>我们要求，开发团队的成员尽量每天都将自己分支的代码提交到主干。在到达发布条件时，从主干直接拉出发布分支用于发布。若发现缺陷，直接在主干上修复，并根据需要 <code>cherry pick</code> 到对应版本的发布分支。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/主干开发.png" alt="主干开发"></p>
<p>这样一来，对于开发人员来说需要关注的分支就只有主干和自己 working 的分支两条，只需要 push 与 merge 两条 git 命令就能完成所有分支操作。同时，由于合入频率的提高，平均每人需要解决的冲突量大大减少，这无疑解决了很多开发人员的痛点。</p>
<p>需要说明的是，分支策略与版本发布模式没有银弹。我们采用的策略可能并不适合所有团队的项目。提高合入频率尽快能让产品快速迭代，但无疑会让新开发的特性很难得到充分的手工测试及验证。</p>
<p>为了解决这一矛盾点，这背后需要有强大的基础设施及长期的习惯培养做支持。这里将难点分为如下几个类型，大家可以针对这些难点做一些考量，来确定是否有必要采用主干开发的方式。</p>
<ol>
<li>完善且快速的自动化测试。只有在单元测试、集成测试、E2E 测试覆盖率极高，且通过变异测试得出的测试用例质量较高的情况下，才能对项目质量有一个整体的保证。但这需要团队内所有开发人员习惯 TDD(测试驱动开发)的开发方式，这是一个相当漫长的工程文化培养过程。</li>
<li>Owner 责任制的 Code Review 机制。让开发人员具有 Owner 意识，对自己负责的模块进行逐行审查，可以在代码修改时规避许多设计架构上的破坏性修改与坑点。本质上难点其实还是开发人员的习惯培养。</li>
<li>大量的基础设施投入。高频的自动化测试其实是一个相当消耗资源的操作，尤其是 E2E 测试，每一个测试用例都需要启动一个无头浏览器来支撑。另外，为了提升测试的效率，需要多核的机器来并行执行。这里的每一项都是较大的资源投入。</li>
<li>快速稳定的回滚能力和精准的线上及灰度监控等等。只有在高度自动化的全链路监控下，才能保证该机制下发布的新版本能够稳定运行。这里的建设我会在之后的文章里详细介绍。</li>
</ol>
<h2>大型项目中产物-&gt;制品的建立</h2>
<p>对于大多数项目来说，在代码编译完成生成产物后，部署项目的方式就是登录发布服务器，将每一次生成的产物粘贴进发布服务器中。生成的静态文件由于 hash 不同可以同时存放，html 采用直接覆盖的方式进行更新。</p>
<p>直接使用复制粘贴的方式来操作文件的更新与覆盖，这样既不方便对更新历史的审计与追溯，同时这样的更改也很难保证正确性。</p>
<p>除此之外，当我们需要回滚版本时，由于服务器上并没有存放历史版本的 html，因此回滚的方式其实是重新编译打包生成历史版本的产物进行覆盖。这样的回滚速度显然不是令人满意的。</p>
<p>一个解决方法是，不要对文件进行任何的覆盖更新，所有的产物都应该被上传持久化存储。我们可以在请求上游增设一个流量分发服务，来判断每一条请求应该返回哪一个版本的 html 文件。</p>
<p>对于大型项目来说，返回的 html 文件也不一定不是一成不变的。它可能会被注入渠道、用户自定义等标识，以及 SSR 所需要的首屏数据，从而改变其代码形式。因此，我们认为 html 文件的制品提供方应该是一个单独的动态服务，通过一些逻辑完成对模板 html 的替换并最终输出。</p>
<p>总结一下，在每次编译完成后，产物将会进行如下的整理以生成最终的前端制品：</p>
<ol>
<li>针对静态文件，如 CSS、JS 等资源将会发布到云对象存储中，并以此为源站同步给 CDN 做访问速度优化。</li>
<li>针对 HTML 制品，需要一个直出服务做支撑，并打包成 docker 镜像，与后端的微服务镜像同等级别，供上游的流量分发服务(网关)根据用户请求选择调起哪些服务负载进行消费。</li>
</ol>
<h2>速度即效率，流水线优化思路</h2>
<p>对于一个好的工具来说，内部设计可以很复杂，但对于使用者来说必须足够简单且好用。</p>
<p>在主干开发这样高频的持续集成下，集成速度即效率，流水线的执行时间毫无疑问是开发人员最关心的，也是流水线是否好用的决定性指标。我们可以从几个方面着手，提高流水线执行效率，减少开发人员的等待时间。</p>
<h3>流水线任务编排</h3>
<p>对流水线各个阶段需要执行的任务我们需要遵循一定的编排原则：<code>无前置的任务优先</code>，<code>执行时间短的任务优先</code>，<code>无关联的任务并行</code>。</p>
<p>根据这一原则，我们可以通过分析流水线中执行的各个任务，对每一个任务做一次最短路径依赖分析，最终得出该任务的最早执行时机。</p>
<h3>巧用 Docker Cache</h3>
<p>Docker提供了这样一个特性：在Docker镜像的构建过程中，Dockerfile的每一条可执行语句都会构建出一个新的镜像层，并缓存起来。在第二次构建时，Docker会以镜像层为单位逐条检查自身的缓存，若命中相同镜像层，则直接复用该条缓存，使得多次重复构建的时间大大缩短。</p>
<p>我们可以利用Docker的这一特性，在流水线中减少通常会重复执行的步骤，从而提高CI的执行效率。</p>
<p>例如前端项目中通常最耗时的依赖安装<code>npm install</code>，变更依赖项对于高频集成来说其实是一个较小概率的事件，因此我们可以在第一次构建时，将<code>node_modules</code>这个文件夹打包成为镜像供下次编译时调用。Dockerfile示例编写如下：</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> node:12 <span class="token keyword">AS</span> dependencies</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /ci</span>

<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>

<span class="token instruction"><span class="token keyword">ENV</span> NODE_PATH=/ci/node_modules</span>
</code></pre></div><p>我们给流水线增加一条检查缓存命中的策略：在下次编译之前，先查找是否有该镜像缓存存在。并且，为了保证本次构建的依赖没有更新，我们还必须比对本次构建与镜像缓存中的<code>package-lock.json</code>文件的md5码是否一致。若不一致，则重新安装依赖并打包新镜像进行缓存。若比对结果一致，则从该镜像中直接取到<code>node_modules</code>文件夹，从而省去大量依赖安装的时间。</p>
<p>流水线拉取镜像文件夹的方法示例如下，其中 <code>--from</code> 后跟的是之前缓存构建镜像的别名：</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">dependencies</span></span> node_modules/ .</span>
<span class="token comment"># 其他步骤执行</span>
</code></pre></div><p>同理，我们也可以将这一特性扩展到CI过程中所有更新频率不高，生成时间较长的任务中。例如Linux中环境依赖的安装、单元测试每条用例运行前的缓存、甚至是静态文件数量极多的文件夹的复制等等，都能利用Docker cache的特性达到几乎跳过步骤，减少集成时间的效果。由于原理大致相同，在此就不赘述了。</p>
<h3>分级构建</h3>
<p>众所周知，流水线的执行时间一定会随着任务数量的增多而变慢。大型项目中，随着各项指标计算的接入，各项测试用例的数量逐渐增多，运行时间迟早会达到我们难以忍受的地步。</p>
<p>但是，测试用例的数量一定程度上决定着我们项目的质量，质量检查决不能少。那么有没有一种方法既可以让项目质量得到持续保障的同时，减少开发者等待集成的时间呢？答案就是分级构建。</p>
<p>所谓分级构建，就是将CI流水线拆分为主构建和次级构建两类，其中主构建需要在每次提交代码时都要执行，并且若检查不通过无法进行下一步操作。而次级构建不会阻塞工作流，通过旁路的方式在代码合入后继续执行。但是，一旦次级构建验证失败，流水线将会立即发出通知告警，并阻塞其他所有代码的合入，直到该问题被修复为止。</p>
<p>对于某任务是否应放入次级构建过程，有如下几点原则：</p>
<ol>
<li>次级构建将包含执行时间长(如超过15分钟)、耗费资源多的任务，如自动化测试中的E2E测试。</li>
<li>次级构建应当包含用例优先级低或者出错可能性低的任务，尽量不要包含重要链路。如果自动化测试中的一些测试用例经过实践发现失败次数较高，应当考虑增加相关功能单元测试，并移入主构建过程。</li>
<li>若次级构建仍然过长，可以考虑用合适的方法分割测试用例，并行测试。</li>
</ol>
<h2>结语</h2>
<p>工欲善其事，必先利其器。腾讯文档项目高频稳定发布的背后，必定需要拥有强大基础设施的支持。</p>
<p>本篇文章仅主要介绍了持续集成阶段对项目进行的改造，持续部署、持续运营等阶段的具体改造思路将在笔者接下来的文章中详细说明。也欢迎大家多多探讨，对其中需要改进或有误的部分提出建议与斧正。</p>
<h2>参考资料</h2>
<ol>
<li>《持续交付 2.0》—— 乔梁 著</li>
<li><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener noreferrer">https://www.redhat.com/zh/topics/devops/what-is-ci-cd</a></li>
<li><a href="https://www.36kr.com/p/1218375440667012" target="_blank" rel="noopener noreferrer">https://www.36kr.com/p/1218375440667012</a></li>
</ol>
]]></content>
    <category term="前端技术研究院"/>
    <published>2021-05-11T20:37:21.000Z</published>
  </entry>
  <entry>
    <title type="text">NodeJS 服务 Docker 镜像极致优化指北</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2021-07-25.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2021-07-25.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这段时间在开发一个腾讯文档全品类通用的 HTML 动态服务，为了方便各品类接入的生成与部署，也顺应上云的趋势，考虑使用 Docker 的方式来固定服务内容，统一进行制品版本的管理。本篇文章就将我在服务 Docker 化的过程中积累起来的优化经验分享出来，供大家参考。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这段时间在开发一个腾讯文档全品类通用的 HTML 动态服务，为了方便各品类接入的生成与部署，也顺应上云的趋势，考虑使用 Docker 的方式来固定服务内容，统一进行制品版本的管理。本篇文章就将我在服务 Docker 化的过程中积累起来的优化经验分享出来，供大家参考。</p>
</div><!-- more -->
<p>以一个例子开头，大部分刚接触 Docker 的同学应该都会这样编写项目的 Dockerfile，如下所示：</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> node:14</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> . .</span>
<span class="token comment"># 安装 npm 依赖</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>

<span class="token comment"># 暴露端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"npm"</span>, <span class="token string">"start"</span>]</span>
</code></pre></div><p>构建，打包，上传，一气呵成。然后看下镜像状态，卧槽，一个简单的 node web 服务体积居然达到了惊人的 1.3 个 G，并且镜像传输与构建速度也很慢：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210709165348.png" alt="docker 镜像优化前"></p>
<p>要是这个镜像只需要部署一个实例也就算了，但是这个服务得提供给所有开发同学进行高频集成并部署环境的(实现高频集成的方案可参见我的 )。首先，镜像体积过大必然会对镜像的拉取和更新速度造成影响，集成体验会变差。其次，项目上线后，同时在线的测试环境实例可能成千上万，这样的容器内存占用成本对于任何一个项目都是无法接受的。必须找到优化的办法解决。</p>
<p>发现问题后，我就开始研究 Docker 的优化方案，准备给我的镜像动手术了。</p>
<h2>node 项目生产环境优化</h2>
<p>首先开刀的是当然是前端最为熟悉的领域，对代码本身体积进行优化。之前开发项目时使用了 Typescript，为了图省事，项目直接使用 tsc 打包生成 es5 后就直接运行起来了。这里的体积问题主要有两个，一个是开发环境 ts 源码并未处理，并且用于生产环境的 js 代码也未经压缩。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210709170819.png" alt="tsc 打包"></p>
<p>另一个是引用的 node_modules 过于臃肿。仍然包含了许多开发调试环境中的 npm 包，如 ts-node，typescript 等等。既然打包成 js 了，这些依赖自然就该去除。</p>
<p>一般来说，由于服务端代码不会像前端代码一样暴露出去，运行在物理机上的服务更多考虑的是稳定性，也不在乎多一些体积，因此这些地方一般也不会做处理。但是 Docker 化后，由于部署规模变大，这些问题就非常明显了，在生产环境下需要优化的。</p>
<p>对于这两点的优化的方式其实我们前端非常熟悉了，不是本文的重点就粗略带过了。对于第一点，使用 Webpack + babel 降级并压缩 Typescript 源码，如果担心错误排查可以加上 sourcemap，不过对于 docker 镜像来说有点多余，一会儿会说到。对于第二点，梳理 npm 包的 dependencies 与 devDependencies 依赖，去除不是必要存在于运行时的依赖，方便生产环境使用 <code>npm install --production</code> 安装依赖。</p>
<h2>优化项目镜像体积</h2>
<h3>使用尽量精简的基础镜像</h3>
<p>我们知道，容器技术提供的是操作系统级别的进程隔离，Docker 容器本身是一个运行在独立操作系统下的进程，也就是说，Docker 镜像需要打包的是一个能够独立运行的操作系统级环境。因此，决定镜像体积的一个重要因素就显而易见了：打包进镜像的 Linux 操作系统的体积。</p>
<p>一般来说，减小依赖的操作系统的大小主要需要考虑从两个方面下手，第一个是尽可能去除 Linux 下不需要的各类工具库，如 python，cmake, telnet 等。第二个是选取更轻量级的 Linux 发行版系统。正规的官方镜像应该会依据上述两个因素对每个发行版提供阉割版本。</p>
<p>以 node 官方提供的版本 node:14 为例，默认版本中，它的运行基础环境是 Ubuntu，是一个大而全的 Linux 发行版，以保证最大的兼容性。去除了无用工具库的依赖版本称为 node:14-slim 版本。而最小的镜像发行版称为 node:14-alpine。Linux alpine 是一个高度精简，仅包含基本工具的轻量级 Linux 发行版，本身的 Docker 镜像只有 4～5M 大小，因此非常适合制作最小版本的 Docker 镜像。</p>
<p>在我们的服务中，由于运行该服务的依赖是确定的，因此为了尽可能的缩减基础镜像的体积，我们选择 alpine 版本作为生产环境的基础镜像。</p>
<h3>分级构建</h3>
<p>这时候，我们遇到了新的问题。由于 alpine 的基本工具库过于简陋，而像 webpack 这样的打包工具背后可能使用的插件库极多，构建项目时对环境的依赖较大。并且这些工具库只有编译时需要用到，在运行时是可以去除的。对于这种情况，我们可以利用 Docker 的<code>分级构建</code>的特性来解决这一问题。</p>
<p>首先，我们可以在完整版镜像下进行依赖安装，并给该任务设立一个别名(此处为<code>build</code>)。</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># 安装完整依赖并构建产物</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:14 <span class="token keyword">AS</span> build</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> package*.json /app/</span>
<span class="token instruction"><span class="token keyword">RUN</span> [<span class="token string">"npm"</span>, <span class="token string">"install"</span>]</span>
<span class="token instruction"><span class="token keyword">COPY</span> . /app/</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>
</code></pre></div><p>之后我们可以启用另一个镜像任务来运行生产环境，生产的基础镜像就可以换成 alpine 版本了。其中编译完成后的源码可以通过<code>--from</code>参数获取到处于<code>build</code>任务中的文件，移动到此任务内。</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> node:14-alpine <span class="token keyword">AS</span> release</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /release</span>

<span class="token instruction"><span class="token keyword">COPY</span> package*.json /</span>
<span class="token instruction"><span class="token keyword">RUN</span> [<span class="token string">"npm"</span>, <span class="token string">"install"</span>, <span class="token string">"--registry=http://r.tnpm.oa.com"</span>, <span class="token string">"--production"</span>]</span>

<span class="token comment"># 移入依赖与源码</span>
<span class="token instruction"><span class="token keyword">COPY</span> public /release/public</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">build</span></span> /app/dist /release/dist</span>

<span class="token comment"># 启动服务</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"node"</span>, <span class="token string">"./dist/index.js"</span>]</span>
</code></pre></div><p>Docker 镜像的生成规则是，生成镜像的结果仅以最后一个镜像任务为准。因此前面的任务并不会占用最终镜像的体积，从而完美解决这一问题。</p>
<p>当然，随着项目越来越复杂，在运行时仍可能会遇到工具库报错，如果曝出问题的工具库所需依赖不多，我们可以自行补充所需的依赖，这样的镜像体积仍然能保持较小的水平。</p>
<p>其中最常见的问题就是对<code>node-gyp</code>与<code>node-sass</code>库的引用。由于这个库是用来将其他语言编写的模块转译为 node 模块，因此，我们需要手动增加<code>g++ make python</code>这三个依赖。</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># 安装生产环境依赖(为兼容 node-gyp 所需环境需要对 alpine 进行改造)</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:14-alpine <span class="token keyword">AS</span> dependencies</span>

<span class="token instruction"><span class="token keyword">RUN</span> apk add --no-cache python make g++</span>
<span class="token instruction"><span class="token keyword">COPY</span> package*.json /</span>
<span class="token instruction"><span class="token keyword">RUN</span> [<span class="token string">"npm"</span>, <span class="token string">"install"</span>, <span class="token string">"--registry=http://r.tnpm.oa.com"</span>, <span class="token string">"--production"</span>]</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk del .gyp</span>
</code></pre></div><blockquote>
<p>详情可见：<a href="https://github.com/nodejs/docker-node/issues/282" target="_blank" rel="noopener noreferrer">https://github.com/nodejs/docker-node/issues/282</a></p>
</blockquote>
<h2>合理规划 Docker Layer</h2>
<h3>构建速度优化</h3>
<p>我们知道，Docker 使用 Layer 概念来创建与组织镜像，Dockerfile 的每条指令都会产生一个新的文件层，每层都包含执行命令前后的状态之间镜像的文件系统更改，文件层越多，镜像体积就越大。而 Docker 使用缓存方式实现了构建速度的提升。<strong>若 Dockerfile 中某层的语句及依赖未更改，则该层重建时可以直接复用本地缓存</strong>。</p>
<p>如下所示，如果 log 中出现<code>Using cache</code>字样时，说明缓存生效了，该层将不会执行运算，直接拿原缓存作为该层的输出结果。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Step <span class="token number">2</span>/3 <span class="token builtin class-name">:</span> <span class="token function">npm</span> <span class="token function">install</span>
</code></pre></div>]]></content>
    <category term="前端技术研究院"/>
    <published>2021-07-25T18:26:27.000Z</published>
  </entry>
  <entry>
    <title type="text">大型前端项目 DevOps 沉思录 -- CD 篇</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2022-01-25.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2022-01-25.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p><code>DevOps</code>一词源于<code>Development</code> 和 <code>Operations</code> 的组合，即将软件交付过程中开发与测试运维的环节通过工具链打通，并通过自动化的测试与监控，减少团队的时间损耗，更加高效稳定地交付制品。</p>
<p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续部署阶段</code> 需要提供的能力，介绍大型项目应该如何稳定并高频率的迭代项目版本。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p><code>DevOps</code>一词源于<code>Development</code> 和 <code>Operations</code> 的组合，即将软件交付过程中开发与测试运维的环节通过工具链打通，并通过自动化的测试与监控，减少团队的时间损耗，更加高效稳定地交付制品。</p>
<p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续部署阶段</code> 需要提供的能力，介绍大型项目应该如何稳定并高频率的迭代项目版本。</p>
</div><!-- more -->
<p>在系列的  中，我们详细介绍了腾讯文档前端在 <code>DevOps</code> 的 <code>持续集成阶段</code> 所作出的实践与思考，介绍了在 CI 阶段项目工作流的设计及流水线的优化思路。</p>
<p>本次我们将探讨 <code>DevOps</code> 在 <code>持续部署阶段</code> 需要提供的能力，介绍大型项目应该如何稳定并高频率的迭代项目版本。</p>
<h2>正确认识持续部署</h2>
<p>我们在为一个项目搭建自动化流水线时，通常会将项目的代码检查、自动化测试、代码编译、部署环境等等环节全部放入同一条流水线，因为许多时候，这都是一条逻辑清晰且稳定的链路，能够确保发布产物一定完成了全部的自动化检查。</p>
<p>常见的项目流水线应该如下图所示，是一条大而全的串行链路：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210927171709.png" alt="ci&amp;cd pre"></p>
<p>由于这样的 CI/CD 流水线经常被各类文章列为最佳实践，于是很多时候，我们很容易将 CI/CD 流程混为一谈，甚至将其等同于构建 <code>DevOps</code> 流水线的全流程，这种认知其实是不对的。</p>
<blockquote>
<p>持续部署(Continuous deployment，缩写为 CD)，是一种软件工程方法，意指在软件开发流程中，以自动化方式，频繁而且持续性的，将软件部署到生产环境中，使软件产品能够快速的发展。</p>
</blockquote>
<p>与上一章介绍的<code>持续集成</code>不同，<code>持续部署</code>更多的是侧重在已经生成的制品如何<strong>高频</strong>且<strong>低风险</strong>的自动部署到各种测试、灰度与生产环境的。想要做到高频与稳定，我们需要彻底将<code>持续部署</code>环节从<code>持续集成</code>环节中分离出来，形成独立的流水线。</p>
<h2>解耦 CI 与 CD 环节</h2>
<h3>为何要将 CD 从 CI 中分离</h3>
<p>一个项目在发展成熟的过程中，代码将逐渐变得庞大且复杂，项目编译、代码检查和自动化测试的时间将不可避免的越变越长。但与此同时，高频部署与版本切换对于一个自动化成熟的项目来说也是一个必选项。尽管在<code>持续集成</code>阶段，我们可以用上篇文章介绍过的次级构建等方法来减少从代码推送到制品生成之间的耗时，但距离我们期望的快速版本切换来说仍然杯水车薪。</p>
<p>这个问题在现网出现致命故障回滚时暴露的尤为明显。以我们团队项目之前的实践为例，在回滚版本时，实质上是将打过<code>git tag</code>的上一版本节点抽离出分支进行一次提交，等待其执行了完整的 CI/CD 流程后在源站服务器上更新我们的 HTML 完成更新。也就是说，我们的回滚操作所需的准备时间几乎是和发布一个新版本同样长。这对于一个用户量较大的成熟项目来说是不可接受的。</p>
<p>其实，我们是被长时间的自动化构建思维带入了误区，认为发布流程不经过 CI 验证过就不是一个合格的产物。想要实现瞬间回滚其实很简单，我们只需要记录之前版本的发布产物，在需要回滚时直接进入服务器将之前记录过的某一版本发布到源站服务器即可。</p>
<p>但是这种由人工来手动选择文件并拷贝覆盖到服务器的方式显然容易出错，我们还是应该利用流水线的能力来实现这一功能，而这就是与 <code>持续集成</code> 分离后，<code>持续部署</code> 流水线的其中一个能力。</p>
<p><code>DevOps</code>中所谓<strong>持续</strong>，是指每完成一个完整的部分，就向下个环节推进，如果发现问题可以在当前环节内调整和重试，并不会影响其他环节。以回滚为例，同一个制品已经通过了<code>持续集成</code>的测试并完成交付后，就不应该再对其进行第二次 CI 环节了，而只需重新执行<code>持续部署</code>流程即可，而通常，<code>持续部署</code>的环境切换效率是极高的，这就是将 CI 与 CD 环节解耦的意义。</p>
<h3>如何分离</h3>
<p>实现思路上，我们首先要解决的，是找到一个合适的位置存储每次 CI 构建生成的产物。</p>
<p>在信息系统的设计理论中，存放唯一可信信息的地方被称为 <strong>SSOT</strong>(Single source of truth)与 <strong>SVOT</strong>(Single version of truth)，这样能确保我们获取的信息是真实可信的，具有权威性的。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220224145124.png" alt="20220224145124"></p>
<p>这里的可信包含两个方面，质量与安全。</p>
<blockquote>
<p>可信质量：指开发过程中的代码质量、测试通过率、审批结果、合规性、所属人等。</p>
<p>可信安全：指开发过程中的代码安全风险、外部依赖安全风险、动态应用安全风险等。</p>
</blockquote>
<p>每一个通过 CI 生成的制品被存入镜像仓库后，会将存放位置、代码版本、CI 各质量流程完成结果等等信息，作为一条记录存放在 SSOT 中，而可信这一概念在制品信息中的表现，则是可以通过在该条记录中添加标签或索引来实现。</p>
<p>于是我们可以得到大致这样的一条记录，表明了制品的生成时间，镜像地址，仓库分支来源，质量校验结果等等一系列的信息。制品版本的对应关系一目了然。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20211001163304.png" alt="20211001163304"></p>
<p>于是，在新思路的引导下，我们重新定义了 CI 流程的终点：</p>
<p>在经过 CI 流水线的各流程质量验证后，生成制品并存至制品仓库，同时通过各流程的检验结果为该制品设置可信标签，一并存入 SSOT 中，生成一个新的可信版本。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220224145646.png" alt="20220224145646"></p>
<p>而这条版本信息，也成为了 CD 的起点。需要部署时，只需根据标签或索引信息筛选出符合要求的最新制品信息，即可找到对应制品，部署该版本。</p>
<p>由于制品本身已完成编译且质量合格，因此能直接安全的部署在生产环境中。从而极大的缩短了部署流程的时间。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220224145913.png" alt="20220224145913"></p>
<p>该过程不仅作用在新版本发布中，热修复、灰度部署、回滚等产品常见的特殊部署场景全都可以通过 SSOT 的查询来找到可信制品来跳过 CI 步骤，仅需完成审批，就能全自动发布。</p>
<h2>前端制品的交付形态</h2>
<p>我们接下来要解决解耦过程中的另一个核心问题：我们向 SSOT 交付产物的形态是什么？</p>
<p>众所周知，前端的版本生成产物无非是 HTML、JS、CSS 等几类。我们可以简单地将前端产物划分为两类：静态资源类文件与入口类文件。</p>
<p>静态资源类文件，即如 CSS、JS 之类，处置起来较为简单，仅需带上 hash 后存放于云存储中作为源站资源，并定期同步给 CDN 即可。</p>
<p>重点在于，我们该如何交付每个版本生成的入口类产物。这个才是在持续部署过程中真正需要替换升级的部分。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220224150246.png" alt="20220224150246"></p>
<p>对于绝大多数项目来说，很容易将这一部分想的过于简单。例如直接将入口类产物封装为文件夹，统一放到某处进行存储，之后通过改变网关的路由指向(可能有些项目会利用外部的配置系统，映射路由指向，网关通过请求来动态的获取入口文件指向)，更新并重定向到新版本入口文件。</p>
<p>但实际上，这样的方式存在着一些隐患，我列举几点：</p>
<ol>
<li>
<p>直接将产物以文件形式的部署方式，其本质上是向一个或多个服务器进行产物文件上传。本质上是对产物的移动与粘贴，不方便对产物的更新历史进行追溯，无法做更精细化的版本管理。</p>
</li>
<li>
<p>以文件夹存放文件来分隔各版本产物，这样的版本组织结构过于松散。产物文件直接存储在服务器上，有被人为篡改的风险。且一旦在产物中执行修改操作能立即改变现网内容，并且这一过程不会经过任何审计，是十分危险的。</p>
</li>
<li>
<p>数据源的存储位置问题。如果数据源存储于网关本地，或是挂载硬盘，那么就需要考虑冗余备份的问题，并且数据出现故障或者需要迁移时，由于历史版本全部存于一处，数据量巨大，恢复起来会比较困难。而如果存储位置存放在云存储之类的位置，那么势必会用到额外的配置系统，网关通过来完成路由映射。而此时配置系统也成为了关键服务，如果不能保证稳定性，整个网关将会完全崩溃。</p>
</li>
</ol>
<p>总结一下，上面提到的问题有两个核心点，一是需要一个更 immutable 的方案，保证每一版本的制品能被封装为一个不可变整体，而是需要保证每一个版本都能不受外部环境依赖。</p>
<p>根据这样的特性描述，我们很容易想到 Docker 镜像。那么，前端能否利用以及如何利用好 Docker 这一形态作为交付制品呢？</p>
<h3>生产能被云原生调度的合格制品</h3>
<p>在  中曾提到，由于前端的特殊性，对于静态资源，如 js、css 等文件的网络加载时间较为敏感，同时 HTTP 请求也具备多级缓存的能力，因此这些静态资源放于源站并同步给 CDN 仍然为最优解。于是需要上云的产物便只关联用户的首次请求产物，也即 HTML 了。</p>
<p>一些同学可能会觉得，如果只是 HTML 这一个文件，完全不需要以一个这么重的方案来承载。这其实还是将前端的产物设想为文件这种简单的形式来考虑的。</p>
<p>实际上，对于稍复杂的前端项目来说，用户接收到的 HTML 返回很多都是运行时动态生成的，例如功能开关、灰度、渠道特性、SSR、ABTest 等等功能，这都是根据用户当前请求，即时地返回不同的 HTML。换言之，这里的 HTML 生成器其实是一个 Web 资源服务。</p>
<p>介绍到这里，我们会发现，这里的 Web Service 实际上是一个前端动态化能力的 BFF (Backend For Frontend) 层，为前端增加了一个承载动态化渲染逻辑的位置，从而取代掉一般项目中服务端渲染的服务层。考虑到前端同学的习惯以及相关功能的生态兼容，该 Web Service 同样可以使用 NodeJS 来承载。</p>
<p>因此，前端每次发布一个版本，就会形成一个新的微服务，用于提供服务端直出能力。这么想来，前端服务通过云原生的方式，对制品镜像进行管理是不是就合理多了？</p>
<p>当然，云原生的特性带给这个 BFF 层的特殊玩法可远不止于此。由于与持续部署流程的行文关联不大，这里我继续埋个坑，之后有空了再来介绍云原生下的 BFF 层应该如何设计。</p>
<h2>前端制品的云原生部署</h2>
<h3>自动交付与部署</h3>
<p>在合格的镜像版本存入 SSOT 之后，我们要对现有的服务进行一个更新。在这里，流水线可以定期向 SSOT 进行轮询，看是否有新的符合要求的产物被生成出来，若有则触发部署流程，更新容器。这里的情况有两种，建立新容器还是更新已有容器。</p>
<p>为了实现自动区分部署目的，我们决定利用 git 的分支名特征。在 gitOps 管理的项目中，分支名规范了代码的目标环境。例如 feature/xx 和 develop 分支属于测试环境，master 和 release/xxx 分支属于生产环境，当然在分支规范上可以自定义。</p>
<p>通过判断分支名，我们即可知晓更新行为。例如，被判断为测试环境的镜像部署时，满足同名分支环境仅保留一个的原则进行新建或更新。当被判断为生产环境的制品镜像生成时，进行制品各项审核参数校验，全部要求通过后开始推送到预发布环境等待进行灰度流转。</p>
<p>每个版本的 BFF 服务制品，通过独立打包为镜像的方式，交由 K8S 统一调度。为了按需分配不同环境下服务的硬件配置，我们参考了谷歌 GKE 的实践，使用了 Terraform 做声明式 K8S 配置管理。这样通过流水线，我们得以合理的分配各环境所占用的硬件资源。</p>
<h3>前端请求的调度</h3>
<p>在部署完成后，用户的访问请求该如何通过网关分配到目标环境中呢？</p>
<p>之前提到，我们通过 Terraform 进行了容器编排。在部署时，通过将 SSOT 中获取到的分支或灰度版本等信息等作为 metadata，通过 K8S Service 绑定关联到对应的名字服务中。</p>
<p>在用户请求时，可以通过号码包分配或者手动设置 cookie 等方式设置目标版本，作为 metadata 发送给名字服务，从而获取到正确的版本入口。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220224153041.png" alt="20220224153041"></p>
<p>那么这样一套服务化的好处在哪里呢？</p>
<p>我们可以看到，由于每个项目进行的每次构建都会部署出一个全新的服务，在链路层级上与后台微服务是平级的。</p>
<p>这样一来，业务的前端与后端的多个制品可以通过请求参数进行随意组合，通过请求头中携带相同的 metadata 信息串联起来，形成一个全新的环境，而该环境的生成本身无需任何额外的部署操作。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220412195136.png" alt="20220412195136"></p>
<p>这极大便利了前后端，甚至是多个前端之间的联调。我们无需搭建一个新的开发环境同时修改代码，甚至各服务项目之间不需要知道其他服务的存在就能实现联调能力。</p>
<p>同理，测试、预发布、发布环境在请求上只有参数上的不同，无需配置额外的 host 或入口。从而解决了联调与灰度环境配置及测试的难题。</p>
<h3>制定平滑的灰度策略</h3>
<p>产品在迭代过程中，不可避免的需要对版本进行升级，进行代码修改，而修改则意味着风险。<s>因此，只要不改代码就不会有风险。(划掉)</s> 因此，我们需要灰度机制来降低风险带来的影响范围。其中业界最普遍的实现方式便是大名鼎鼎的金丝雀 (canary) 发布。</p>
<blockquote>
<p>冷知识 -- 金丝雀发布的名称由来。</p>
<p>17 世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；</p>
<p>当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。</p>
<p>当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为瓦斯检测指标，以便在危险状况下紧急撤离。</p>
</blockquote>
<p>传统的金丝雀发布为：选用少量的固定数量的服务器作为金丝雀部署机，将一些特定的灰度用户的流量导入到该台机器上测试新版本功能，无误后再进行全量发布。</p>
<p>这里会有两个地方不够灵活，一是金丝雀部署机的机器数量较为固定，扩缩容较为困难，因此要求灰度用户的访问流量峰值必须维持在一定水平，流量少了浪费机器，多了顶不住。二是灰度用户规则是写死的，例如 QQ 的灰度用户方案是以用户 id 后两位来判断是否进入灰度的，不够随机，在某些场景下有可能无法反映真实情况。</p>
<p>而这就是为什么我们花了大力气将制品镜像化，进行云原生部署的主要原因了。</p>
<p>由于 Docker 镜像启动的服务完全一致的特性，再通过引入 K8S 进行容器管理，以上这两个问题都迎刃而解了。HPA(Horizontal Pod Autoscaler)能力，通过流量或硬件占用率等策略实现了自动扩缩容。而滚动发布、间隔发布的策略则解决了升级的平滑度，我们不再需要定义具体哪些用户，具体多少百分比进入灰度。在流水线的帮助下，一切都是缓慢且稳定进行着的。</p>
<p>当然，这样的灰度策略还远不够极限，为了对特性的开关控制进行更快速的响应，有时我们会增加运行时的特性灰度能力，不过这就涉及到 CE(持续实验)环节了，这块的知识我们先按下不表，下次有机会再开新坑。</p>
<h2>结语</h2>
<p>本文介绍了在云原生的浪潮下，大型前端项目在持续部署环节做出的一些尝试。简要介绍了包括制品可靠性、部署可靠性、灰度可靠性的自动化流程处理思路。</p>
<p>随着互联网服务的发达，为了产品的高可用，前端项目在站点可靠性(Site Reliability)上的要求也正变得越来越高。依赖云服务的弹性能力，利用流水线对镜像进行自动化部署，进而解放运维人力，实乃降本增效的一剂良药。</p>
<h2>参考资料</h2>
<ol>
<li>《持续交付 2.0》—— 乔梁 著</li>
<li><a href="https://www.kubernetes.org.cn/8114.html" target="_blank" rel="noopener noreferrer">Google Anthos 混合云 Devops 实践</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247485803&amp;idx=1&amp;sn=b967e2bdf33f933e54175dd1bdc5b07c&amp;chksm=eac52842ddb2a1541148b386b8fe17817b7eebc6f8c94c524175e926d24e909c051b593c4baf&amp;token=1841464039&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">蓝绿发布、滚动发布、灰度发布等部署方案对比与总结</a></li>
</ol>
]]></content>
    <category term="前端技术研究院"/>
    <published>2022-01-25T18:26:27.000Z</published>
  </entry>
  <entry>
    <title type="text">DWS -- 前端制品服务的云原生部署实践</title>
    <id>https://blog.realduang.com/blogs/frontend-tech-institute/2022-03-15.html</id>
    <link href="https://blog.realduang.com/blogs/frontend-tech-institute/2022-03-15.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>云原生是一个很热门的话题，它将服务高可用性上升到了一个新的台阶。站点的高可用同时也是我们前端对自己的高要求。</p>
<p>那么我们该如何设计，才能让我们的前端项目也搭上云原生的快车，实现自动化运维与部署呢？本篇文章我们就来浅谈一下这里的实践。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>云原生是一个很热门的话题，它将服务高可用性上升到了一个新的台阶。站点的高可用同时也是我们前端对自己的高要求。</p>
<p>那么我们该如何设计，才能让我们的前端项目也搭上云原生的快车，实现自动化运维与部署呢？本篇文章我们就来浅谈一下这里的实践。</p>
</div><!-- more -->
<h2>从一个后台服务的部署开始</h2>
<p>说到一个服务的部署，无论是本地起一个 Dev Server 用来做热加载，还是在某台服务器上起一个 Mock Server，用来实现数据通信，相信大家都有所实践。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20211130111445.png" alt="后台服务部署"></p>
<p>通常由我们前端开发搭建的后台服务，多以非关键链路为主，很少会去考虑稳定性和安全性的问题。遇到特性服务出现异常时，最常见的做法就是设计一个降级策略，如果出现任何问题告警，直接手动关闭该特性，把请求切换到某一个兜底的后台服务上。</p>
<p>但是，在服务宕机的这段时间内用户的异常率会上升，特性功能关闭某些后用户的体验也会下降。这样的降级策略并不优雅，甚至在某些关键链路的场景下，服务宕机会导致直接白屏，这是不可接受的。</p>
<p>工业级别的大型软件服务对稳定性有着近乎苛刻的要求。我们在网上浏览各大厂的服务架构介绍时，有一个词总是越来越频繁的出现，那就是云原生部署。</p>
<p>说到云，大家很容易想到各项云服务。有同学会说了，当前各厂都推出了公有云服务，既然这项技术已经这么发达了，我随便在腾讯云上买一台 CVM 当服务器，在上面进行服务的开发与部署，是不是就是服务的云原生部署了？事实上，云原生部署远不是单机服务上云这么简单。</p>
<p>云原生是以容器、微服务、DevOps 等技术为基础建立的一套架构思想，其核心在于利用了镜像服务的不可变特性，使得基于镜像的分布式以及自动化能力得以实现。</p>
<p>这么说可能不太好理解，我们可以换个思路，思考一个理想的服务架构应该要满足什么条件：</p>
<ol>
<li>维护服务的稳定性，在任何场景下服务不能被中断，更新及回滚时要维持服务内容的<strong>幂等性</strong>，并对运行各迭代版本的服务做好充分的<strong>容灾和备份</strong>。</li>
<li>产品版本迭代的过程要<strong>自动化</strong>且<strong>无感知</strong>，服务的部署发布复杂度不能超过旧架构。</li>
</ol>
<p>带着这两点要求，我们来思考原始的服务部署究竟有哪些问题，以及我们可以从哪些角度做出改进。</p>
<h2>服务运维模式的进化</h2>
<h3>0. 石器时代</h3>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210729172251.png" alt="石器时代"></p>
<p>让一个后台服务最快开发上线的方式，不外乎直接在物理机服务器上进行服务部署，代码变更以及服务运维全程在该服务器上进行。这也是最常见的服务部署方式，需要对服务做任何变更及版本升级时，都需要登录到服务器去操作文件内容，重启服务。在多个服务器提供负载均衡的情况下，这样的操作需要进行多次。</p>
<p>优化方案当然是有的，我们可以通过 git 仓库来管理版本，通过编写 shell 脚本来批量修改与重启。但无论如何这种直接操作服务器代码内容的方式都是十分危险的(删库跑路警告)。</p>
<p>另外，物理机不可避免的受到老化的影响，需要裁撤换新，那么无论新机器与旧机器有多么相似，架构的不同，系统版本的不同，还有一些原有系统中一些魔改的操作，都会让服务的迁移变得极为困难，有时候由于系统核心依赖的缺失而进行的迁移，其难度不亚于重写。我们需要一个与承载环境完全无关的服务来实现一处编写，随处部署的能力。</p>
<p>而这，其实就是 docker 的容器化思路。</p>
<h3>1. 青铜时代</h3>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210729202728.png" alt="青铜时代"></p>
<p>容器技术提供的是操作系统级别的进程隔离，可以让服务跑在完全隔离的环境下，无视物理机自身属性，妈妈再也不用考虑我的环境的兼容性问题啦。</p>
<p>在  中我曾简单介绍过，想要维持产物-&gt;制品服务的不可变特性，采用 docker 容器的方式包裹制品服务或许是一个最佳实践。</p>
<p>业务在执行前端源码编译后，进一步将产物放入制品服务的指定目录中，并构建为 Docker 镜像。之后对于任何架构的服务器，只需要拥有 docker 环境，则下载该镜像后一定能运行起来提供完全相同的服务，实现无视宿主机环境的 imutable 部署。</p>
<p>而最简接入的方式也很简单，只需要在项目根目录下增加 Dockerfile 的文件编写即可。</p>
<div class="language-docker" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># 安装完整依赖并构建产物</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:14 <span class="token keyword">AS</span> build</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> package*.json /app/</span>
<span class="token instruction"><span class="token keyword">RUN</span> [<span class="token string">"npm"</span>, <span class="token string">"install"</span>]</span>
<span class="token instruction"><span class="token keyword">COPY</span> . /app/</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>
</code></pre></div><p>当然优化的方式有很多，具体可以参考我的 </p>
<h3>2. 蒸汽时代</h3>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210729213313.png" alt="蒸汽时代"></p>
<p>我们的实际服务中，仅靠一个单容器可能不足以支撑所有的应用场景。拿 Web 的场景来说，我们可能会需要一个 redis 服务来做缓存优化，需要消息队列来实现与多后端服务的数据拉取。</p>
<p>这些服务并不是完全独立的，例如接口服务和数据库服务，它们需要共享同一个网络栈，挂载同一个存储卷。我们暂且将这样一个有关联依赖关系的容器集称为<code>Pod</code>。</p>
<p>想要将这样一个<code>Pod</code>作为逻辑整体来进行管理，就需要一个容器组织框架了。市面上的容器管理框架有几种，最典型的就是 docker-compose 了，它能很好的组织多个容器间的依赖关系，做到多依赖服务的批量部署。</p>
<p>常见的 docker-compose 配置形式如下，仅需声明所需的端口、环境以及依赖，即可通过 <code>docker-compose up</code> 一键启动，十分便利。</p>
<div class="language-yaml" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.4'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webserver</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> synccheng/webserver
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ConnectionString=sqlserver
    <span class="token key atrule">expose</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3306"</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"8000:80"</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> sqlserver

  <span class="token key atrule">sqlserver</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> synccheng/sqlserver
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> PASSWORD=<span class="token punctuation">[</span>PLACEHOLDER<span class="token punctuation">]</span>
    <span class="token key atrule">expose</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3306"</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"5000:3306"</span>
</code></pre></div><h3>3. 电气时代</h3>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20211117202703.png" alt="电气时代"></p>
<p><code>Pod</code>概念的提出，解决了容器之间的关联依赖关系、共享资源等问题。但对于多个<code>Pod</code>的管理，其实也有同样的问题需要解决。例如公共服务<code>Pod</code>与单个业务服务<code>Pod</code>之间也存在关联关系。</p>
<p>关联<code>Pod</code>的生命周期需要进行统一管理调度。例如当版本更新，容器需要销毁重建时，公共服务一定是最先启动，最后销毁的，这样才能保证业务层依赖服务的稳定。</p>
<p>这里根据实际需求的不同，管理调度策略有很多，例如在当前最流行的容器编排引擎 Kubernetes 中，就分为 Deployment、StatefulSet、DaemonSet、Replication 等多种。它们出现的目的，就是解决多<code>Pod</code>间的生命周期管理问题。保证多服务更新或销毁时整体的稳定性。</p>
<p>当然，Kubernetes 提供的能力远不止于此，作为编排引擎，它能够实现服务的自动化部署、设计多<code>Pod</code>的负载均衡、实现动态扩缩容(HPA)，等等。基于镜像构建的 <code>imutable</code> 特性，在资源足够的情况下，Kubernetes 能提供近乎无限的<strong>容灾和备份</strong>能力。</p>
<h3>4. 信息时代</h3>
<p>我们在 Server 的电气时代中，已经近乎完美实现了之前所要求的第一点：服务的绝对可靠。不过代价是什么呢？增加了大量的复杂度。因此这里需要一名熟悉整套流程的运维人员负责服务的维护和升级，同时他还得熟悉前端的部署流程及发布情况。这样一个角色在哪个公司恐怕都是较为稀缺的。</p>
<p>此时我们可以更进一步思考，如何实现要求的第二点，即在不增加前端同学的理解成本下，无感知地走这一套流程发布新版本，根据该制品的发布所处的不同环境或用途，自动配置好服务所需的各项容灾能力。这时，就轮到基础架构自动化编排工具————Terraform 出场了。</p>
<p>Terraform 充分利用了 Infrastructure as Code, 基础架构即代码的思想，以声明的方式，在配置文件中指定不同资源组中云上硬件资源的分配与管理。</p>
<div class="language-terraform" data-ext="terraform" data-title="terraform"><pre class="language-terraform"><code>terraform {
   required_providers {
     aws = {
       source = "aws.amazon.com/xxx"
     }
   }
   backend "http" {}
}

# 配置 provider
provider "aws" {
    version = "1.0.0"
}

# 生成资源组
resource "aws_resource_group" "deployment" {
    metadata {
      name     = "duang"
      namespace = "duang-workspace"
    }
    spec {
      container {...}
      volume {...}
      ...
    }
}
</code></pre></div><p>至此，服务从服务到软硬件的运维配置自动化链路就已全部串联起来。结合之前介绍的 ，业务开发者就能仅通过 push 业务代码的情况下，自动搭建起来一套运维完备的环境了。</p>
<h2>Dockerized Web Server 的概念</h2>
<p>一个云原生的服务架构的理论基础有了，接下来我们可以看看，这样一套架构该如何运用在前端开发的部署场景中。</p>
<p>我们可以将一次前端编译构建的产物分成两个部分，入口文件和资源文件。其中，资源文件是静态的，可以加入 hash 之后直接存放在云存储中做持久化存储，并提供 CDN 进行加速。</p>
<p>而入口文件是随着版本动态更新的，客户端访问时，仅需要找到正确版本的入口文件，则可以拉取到全部的资源文件，获取完整内容。而由于各级缓存的存在，如何让用户及时请求到正确版本的入口文件，一直是前端的一大痛点。</p>
<p>基于上面对云原生服务模式的介绍，我们知道，需要给业务的每一个前端版本制作一个不可变的服务镜像，在最基本的情况下，业务只需要自己编写一个转发服务镜像，设置好路由规则，并在指定目录位置存放好编译构建出来的入口 HTML 文件即可。</p>
<p>这样一来，每一个版本都是一个独立的服务，这样想请求到特定版本的话，向特定的容器发送请求即可。那么每一个提供版本入口的服务就可以称其为最简形式的<code>Dockerized Web Server</code>(下简称 <code>DWS</code> )。</p>
<p>此时的项目构建路径如下图所示：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20211130131512.png" alt="DWS 构建路径"></p>
<p>通过上述的结构设计，我们可以发现，这种服务能力本身是与业务无关的，可以统一建立构建模型，实现分布式部署。业务甚至都不需要了解和编写 dockerfile，仅需要接入统一的 <code>DWS</code> 框架，并将构建的产物移动到镜像内，即可借助流水线，自动完成一个 <code>DWS</code> 的打包与部署。</p>
<h2>扩展前端能力边界</h2>
<p>一些同学可能会疑惑，如果只是给 HTML 这一个入口文件，制作成镜像服务并实现云原生部署，规划一套这么重的方案来承载有些大费周章了。这是将前端的产物默认为静态文件这种简单的形式来考虑的。事实上现代前端所需要涉足的能力远不止于此。</p>
<p>举个栗子，大家都比较熟悉的 SSR。通常来说，涉及到 SSR 功能的页面都会起一个后台服务(通常是熟悉的 node 服务)来完成权限的判断、后台数据的拉取、HTML 代码片段的拼接等等操作，最后直接返回给客户端一个渲染好的首屏完整页面，以此来提高首屏速度。那么实际上，提供这个能力的后台服务其实就是 <code>DWS</code> 里<code>动态</code>的一种表现形式，可以交由 <code>DWS</code> 本地承载并实现。</p>
<p>对于不同的前端项目，除去用来做数据直出的 SSR，还有更多的需要运行时动态判断的功能存在。例如业务想在获取 HTML 之前，做一些数据的预处理，注入到 HTML 里，改变 HTML 内容，比如 A/B Test 中，设置对某个 feature 的开关；又例如，请求时根据权限判断来提前预渲染某个局部元素；甚至能够根据请求路由或参数的不同，返回不同的文件，在同一版本内起到网关的作用，等等。</p>
<p>这些功能以往都是由请求链路上多级的后台服务来分别注入，或是在首屏结束之后，由客户端向各个接口发起 ajax 请求，获取到相应的权限与状态后，去改变页面展示。</p>
<p>很显然，既然 <code>DWS</code> 能够直接与后台数据交互，且通信效率较高，又能直接从本地拿到正确版本的入口文件，那么上述的这些能力完全可以整合到同一个服务内去处理，最后一步到位地返回一个最终的服务端渲染页面。</p>
<p>这样的行为扩展了前端项目的能力边界，将前端开发的交付内容，从传统的 web 网页渲染转变到了整个网页渲染服务的开发与维护。这就是所谓的<code>前端制品即服务</code>。</p>
<h2>前端制品的微服务架构</h2>
<p>接受了<code>前端制品即服务</code>后，对于前端来说，每个迭代版本需要交付和维护的内容就从普通的 HTML 文件转移到了 <code>DWS</code> 这个<code>动态制品服务</code>中。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20211130131512.png" alt="DWS 构建路径"></p>
<p>而生成的 <code>DWS</code> 作为请求链路的终点，其在请求链路中的位置如下图所示：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20211130131833.png" alt="请求链路"></p>
<p>借助流水线，我们可以为每个项目的每一次构建都生成一个不可变的服务镜像，并随时随地部署为容器提供服务。当业务涉及到多个前端项目时，网关可以通过路由或用户特征，将流量请求到相应项目的容器中提供服务，这样就实现了前端多项目场景下的微服务架构。</p>
<p>这样的架构好处在于，项目的不同版本可以共存，不同的项目之间可以任意组装，生成独立的环境副本，不需要另起一个代理服务做转发。</p>
<p>我们可以为不同类型的请求设置一个环境 id，仅环境 id 一致的各项目服务将被响应，对未生成此环境 id 的项目将由该项目的兜底服务响应。这样，我们仅通过一个环境 id，即可串联出来一整套环境。</p>
<p>我们可以任意拼装各个项目的各个版本，任意生成全新的联调测试环境。而这一过程不需要任何代理，也不触发任何部署，仅需绑定相同的 envid 即可实现。</p>
<p>灰度发布环境本质上也是一个特殊的测试环境，因此在环境的实现上也是完全一致的。当然，灰度环境为了确定流量的环境 id，其灰度策略会比较复杂，这里与本文的介绍无关，这一 part 我先挖个坑，在之后的持续部署相关文章中再来讲述。</p>
<h2><code>DWS</code> 服务版本控制及服务能力插件化</h2>
<p>之前我们提到，有许多能力都可以集成到<code>DWS</code>中来统一调用。但作为一项通用服务框架，如果不加限制的由业务方一味地往里面加功能，必定会给服务带来很大的隐患。</p>
<p>不同业务的需求可能不同，非通用能力的加入，需要做兼容处理的情况将会非常复杂，服务的响应时间也可能因此延长。另外，业务直接修改通用服务的代码进行升级是一个很危险的行为，就算业务自身调试通过了，也可能会对其他业务造成不可预知的影响。</p>
<p>为了解决这一问题，我们提出两点改进思路。</p>
<p>第一点是给服务加上版本控制。业务使用时，必须指定好特定版本的 <code>DWS</code> 服务版本，这样就能保证业务代码不变的情况下，打包出来的动态制品服务具有一致性，不受 <code>DWS</code> 更新影响。在动态制品服务需要进行更新时，在业务代码仓库里也能有所体现，保证业务方能够被感知到，便于版本审计。</p>
<p>第二点是将能力开放出来，将每一个功能特性都视为 <code>DWS</code> 的一个能力插件，当且仅当业务需要时，才会被引入和执行。</p>
<p>参考 koa 实现中间件的思路，我们也可以将插件设计为洋葱模型，洋葱模型的最外层，即请求的最外层变量封装以及响应的最终形态由 <code>DWS</code> 内部统一控制，其余对请求与响应的任何改造都可以交由插件来修改。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/ZSZVANFQW0UWNMZSQ8LEKV.png" alt="洋葱模型"></p>
<p>插件的实现方法找到了后，现在的难点来到了，业务在接入 <code>DWS</code> 时，如何将所需的插件注入进去。</p>
<p>为了实现逻辑解耦和易于插拔这两点，我们采用声明式注册的方式。</p>
<p>在业务的配置文件中告知 <code>DWS</code> 所需插件的引用入口位置，可以为远端，也可以为本地，在镜像构建时，将读取配置文件，查询下载所有的插件，打包到 <code>DWS</code> 内，以洋葱模型规定的顺序<strong>依次</strong>调用。</p>
<p>对于存放至远端的插件，我们一般视为可以给其他业务通用的能力，可以统一收归到一处，以类似于<code>插件市场</code>的形式提供给业务方查阅取用，同时，通用插件应与 <code>DWS</code> 核心服务一样，也拥有版本控制能力，保证插件能力修改时业务方能够被感知。</p>
<p>一般来说，通用插件会根据具体需求的不同，在逻辑有一些变更，此时需要调用方根据自身项目情况传入一些特定参数。为了解决这一点，我们可以将插件做成工厂模式，接收配置文件中的 options 参数，返回出符合要求的插件，从而提升通用插件的灵活性。</p>
<p>如此一来，插件的配置文件声明格式就确定下来了。</p>
<div class="language-json" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span>
......
<span class="token property">"middlewares"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"local-plugin"</span><span class="token punctuation">,</span>
    <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"./local-plugins/index.js"</span><span class="token punctuation">,</span>
    <span class="token property">"options"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"@tencent/remote-plugin"</span><span class="token punctuation">,</span>
    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"v1.0.0"</span><span class="token punctuation">,</span>
    <span class="token property">"options"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>对于本地插件的编写，业务方自己拥有完全的控制能力，完全不需要更改动到 <code>DWS</code> 服务本身。通过插件的形式，前端在不用建立任何额外服务端的情况下，也能实现一些原先需要搭建服务端才能处理的功能了，可以基于此做很多有趣的扩展。</p>
<h2>结语</h2>
<p>本文介绍了云原生架构在增强服务稳定性以及自动化能力上的优势，并结合前端项目部署特点做出了一些通用性的实践。当然，这套体系还远不够成熟，但它的想象空间是十分巨大的，它拓展了前端的能力边界，在不需要维护新的后台服务的情况下，得以对产物进行服务端预处理。</p>
<p>这个坑很大，但也很有意思，对此感兴趣的小伙伴欢迎参与进来一起探讨，在云原生的大环境下，我们前端还能做些什么。</p>
]]></content>
    <category term="前端技术研究院"/>
    <published>2022-03-15T14:16:05.000Z</published>
  </entry>
  <entry>
    <title type="text">设计一个基于大数据的机器学习全自动记账系统(基础篇)</title>
    <id>https://blog.realduang.com/blogs/machine-learning/2023-08-21.html</id>
    <link href="https://blog.realduang.com/blogs/machine-learning/2023-08-21.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>随着近些年消费结构的改变，抵制消费主义的行为越来越流行，越来越多的年轻人开始意识到个人财务管理的重要性。与此同时，年轻人也越来越意识到，如果他们想要实现自己的财务目标，如购买房屋、投资、旅游等，就需要掌握有效的财务管理技能。因此，记账已经成为了日常生活中不可或缺的一部分。</p>
<p>但于此同时，真正尝试过记账的小伙伴很多，能年复一年坚持下来的却很少。原因在于记账是一个太过机械性的行为，且很容易因为或主观或客观的因素忘记漏记。这样记账变得枯燥乏味的同时，数据还不够可靠，无法准确地记录消费趋势，从而导致记账的动力不足。</p>
<p>那么，此时如果有一个能够完全自动化的记账系统，能够完全不需要你手动录入每一笔交易，全自动完成所有的数据清洗和分类，并自动地分析消费趋势，最终以图表等形式生成报表，直观地展示出来，你会不会觉得很方便，记账的动力也会大大增强呢？这就是我近些年来一直在思考和优化的财务管理目标。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>随着近些年消费结构的改变，抵制消费主义的行为越来越流行，越来越多的年轻人开始意识到个人财务管理的重要性。与此同时，年轻人也越来越意识到，如果他们想要实现自己的财务目标，如购买房屋、投资、旅游等，就需要掌握有效的财务管理技能。因此，记账已经成为了日常生活中不可或缺的一部分。</p>
<p>但于此同时，真正尝试过记账的小伙伴很多，能年复一年坚持下来的却很少。原因在于记账是一个太过机械性的行为，且很容易因为或主观或客观的因素忘记漏记。这样记账变得枯燥乏味的同时，数据还不够可靠，无法准确地记录消费趋势，从而导致记账的动力不足。</p>
<p>那么，此时如果有一个能够完全自动化的记账系统，能够完全不需要你手动录入每一笔交易，全自动完成所有的数据清洗和分类，并自动地分析消费趋势，最终以图表等形式生成报表，直观地展示出来，你会不会觉得很方便，记账的动力也会大大增强呢？这就是我近些年来一直在思考和优化的财务管理目标。</p>
</div><h2>记账模板展示</h2>
<p>先展示成果，以增强大家的记账动力。我使用了腾讯文档作为所有账单汇总的数据源。由于它支持多人协作，且可以随时随地在任何设备上面修改，且 UI 设计出色，非常适合作为小数据量的账单数据库使用。</p>
<p>以下在不同时期根据自身需求优化出来的财务报表，从上面可以很清晰直观地看到自己的月度消费趋势，以及各个消费类别在每个月的占比，均摊及统计变化趋势。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230725161330.png" alt="20230725161330"></p>
<p>甚至根据自身定制的需要，还可以展示使用的支付方式占比、每年各类别均摊支出及变化趋势等，都能很直观的以图表的形式展示出来。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230725161559.png" alt="20230725161559"></p>
<p>当然只展示整体的显示效果，具体的数据涉及个人隐私都打了厚码，影响美观见谅。</p>
<p>那么接下来就开始从零开始逐个讲解如何设计一个这样的自动记账系统了。</p>
<p>一个完全自动化的记账系统，大体由三个重要部分组成：数据获取、数据清洗和数据分析。我将根据这三个部分依次介绍。</p>
<h2>数据获取</h2>
<p>数据获取是一个完全自动化记账系统的第一步，也是最重要的一步。交易数据的准确性以及信息丰富度直接决定了我们后续的数据清洗和数据分析的效果。因此，我们需要尽可能选择信息量更大的数据源，以获取更多的每条交易更多的上下文信息，从而减少进一步人工标注的干预。</p>
<p>对中国大陆来说，微信和支付宝就是国民级的支付软件，它足够普及和便利，几乎不需要大多数人改变交易习惯。此外，它们的交易数据也是最丰富的。因此，我们的数据获取就以微信和支付宝为主。</p>
<p>但很不幸的是，与国外一些信用卡每月会定期发送账单邮件不同，微信和支付宝并不会主动推送交易账单，并且没有开放获取交易数据的 API，且安全性校验很复杂，也无法使用无头的爬虫来获取数据。因此我们需要通过自行操作来获取交易账单。(当然，如果由愿意折腾的小伙伴也可以考虑模拟用户的行为获取账单)</p>
<h3>微信支付账单获取</h3>
<p>微信支付账单的获取需要在移动端完成(毕竟小而美)。需要在自己的微信 APP 中，依次点击<code>我</code> =&gt; <code>服务</code> =&gt; <code>钱包</code> =&gt; <code>账单</code> =&gt; <code>常见问题</code> =&gt; <code>下载账单</code> =&gt; <code>用于个人对账</code>，输入<code>账单时间</code> 和 <code>邮箱地址</code>，即可将账单发送到你的邮箱中。下载到本地后，输入发送到微信的密码，即可获取微信支付账单。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/88ca321689b9f4f2310ec102d37132a9.png" alt="88ca321689b9f4f2310ec102d37132a9"></p>
<p>但是，微信支付的账单只能获取最近三个月的数据。因此，我们最多每三个月就需要更新下载账单。</p>
<h3>支付宝账单获取</h3>
<p>支付宝账单的获取需要在 PC 端支付宝官网完成。登录后选择 <code>我是个人用户</code> =&gt; <code>我的支付宝</code> =&gt; <code>交易记录</code>，就可以选择对应的交易时间段，选择下载账单为 <code>Excel 格式</code> ，即可获取到支付宝账单。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230725155847.png" alt="20230725155847"></p>
<h3>其他数据源</h3>
<p>当然，如果微信和支付宝不是你主要使用的交易工具。其实所有的银行 APP 都提供打印流水服务，完全可以使用你主要使用的交易工具来作为数据源。当然具体入口可能会有区别，且单条交易记录的信息丰富度可能不足，需要手动补充，在此就不加赘述了。</p>
<h2>数据清洗</h2>
<p>数据清洗是一个记账系统很重要的一步。因为这种自动化导出的账单必定是非常杂乱的，不同的数据源，其交易记录的格式都不一样，且信息丰富度也不一样。因此，我们需要对不同的数据源进行不同的数据清洗。</p>
<p>数据清洗的目的，首先是统一好来自不同数据源的格式以方便接下来的综合分析，其次是剔除掉一些我们不关心的噪声，例如我只想记录 100 元以上的大宗交易，或者我不希望个人不同账户直接的转账被计入进来等等，这部分也完全可以根据自身的需求进行定制。</p>
<blockquote>
<p>观前重要提醒：</p>
<p>如果有读者完全没有编程基础也完全不用害怕，可以在 Excel 中自行操作出一模一样的格式，再合并数据即可，使用代码只是为了提升自动化效率。当然，我之后也将开源所有脱敏的预处理与训练代码，有兴趣的小伙伴可以自行尝试。</p>
</blockquote>
<p>以下的脚本都以 <code>typescript</code> 为例，也完全可以使用任何你所熟悉的语言。</p>
<p>下面仍然以微信和支付宝为例，来介绍如何进行数据清洗。</p>
<p>首先是统一各个数据源的账单格式。如果我们打开了在上一步中获取的微信与支付宝的账单文件，会发现它们之间其实有很多信息都很相似，可以经过一定的规则合并起来。例如，它们都有交易时间、交易类型、交易对方、交易金额等信息。因此，我们可以将它们统一为一个格式：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">IBookKeepingRow</span> <span class="token punctuation">{</span>
  交易时间：Date<span class="token punctuation">;</span>
  类型：RecordType <span class="token operator">|</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token string-property property">"金额(元)"</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token string-property property">"收/支"</span><span class="token operator">:</span> <span class="token string">"支出"</span> <span class="token operator">|</span> <span class="token string">"收入"</span> <span class="token operator">|</span> <span class="token string">"/"</span><span class="token punctuation">;</span>
  支付方式：<span class="token builtin">string</span><span class="token punctuation">;</span>
  交易对方：<span class="token builtin">string</span><span class="token punctuation">;</span>
  商品名称：<span class="token builtin">string</span><span class="token punctuation">;</span>
  备注：<span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>找到了目标格式，接下来我们来看看如何将数据源进行转换。</p>
<h3>微信支付账单清洗</h3>
<p>使用记事本打开微信支付的账单 csv，会发现它的格式类似于：</p>
<div class="language-txt" data-ext="txt" data-title="txt"><pre class="language-txt"><code>微信支付账单明细，,,,,,,,
微信昵称：[Duang],,,,,,,,
起始时间：[2023-06-04 00:00:00] 终止时间：[2023-07-04 00:00:00],,,,,,,,
导出类型：[全部],,,,,,,,
导出时间：[2023-07-25 18:08:39],,,,,,,,
,,,,,,,,
共 44 笔记录，,,,,,,,
收入：3 笔 1145.14 元，,,,,,,,
支出：40 笔 2333.33 元，,,,,,,,
中性交易：1 笔 888.00 元，,,,,,,,
注：,,,,,,,,
1. 充值/提现/理财通购买/零钱通存取/信用卡还款等交易，将计入中性交易，,,,,,,,
2. 本明细仅展示当前账单中的交易，不包括已删除的记录，,,,,,,,
3. 本明细仅供个人对账使用，,,,,,,,
,,,,,,,,
</code></pre></div>]]></content>
    <category term="机器学习"/>
    <published>2023-08-21T15:23:02.000Z</published>
  </entry>
  <entry>
    <title type="text">设计一个基于大数据的机器学习全自动记账系统(AI篇)</title>
    <id>https://blog.realduang.com/blogs/machine-learning/2024-05-07.html</id>
    <link href="https://blog.realduang.com/blogs/machine-learning/2024-05-07.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>随着基于大语言模型的 AI 技术发展越来越迅猛，使用自然语言处理大数据技术来设计一个全自动记账系统已经不再是梦想。在这篇文章中，我们将会介绍如何基于自己过往消费的大数据来设计一个只属于你自己的全自动账单分类记账系统。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>随着基于大语言模型的 AI 技术发展越来越迅猛，使用自然语言处理大数据技术来设计一个全自动记账系统已经不再是梦想。在这篇文章中，我们将会介绍如何基于自己过往消费的大数据来设计一个只属于你自己的全自动账单分类记账系统。</p>
</div>]]></content>
    <category term="机器学习"/>
    <published>2024-05-07T12:40:01.000Z</published>
  </entry>
  <entry>
    <title type="text">jQuery 判断及修改 checked 状态的方法</title>
    <id>https://blog.realduang.com/blogs/others/2017-01-05.html</id>
    <link href="https://blog.realduang.com/blogs/others/2017-01-05.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>表单中经常需要使用单选框或多选框来让用户选择，而我们经常使用 jQuery 来判断或改变选项中 checked 的状态，但是由于 jQuery 版本不同，判断的方法也不太一样，这个坑点在这里记录一下。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>表单中经常需要使用单选框或多选框来让用户选择，而我们经常使用 jQuery 来判断或改变选项中 checked 的状态，但是由于 jQuery 版本不同，判断的方法也不太一样，这个坑点在这里记录一下。</p>
</div><!-- more -->
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"checked"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token comment">//1.6+返回："checked"或"undefined"; 1.5 以下返回：true/false</span>
<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">"checked"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token comment">//1.6+: true/false</span>
<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token string">":checked"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token comment">//所有版本：true/false，注意冒号</span>
</code></pre></div><p>jQuery 赋值 checked 的几种写法：</p>
<p>所有的 jQuery 版本都可以这样赋值：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#cb1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"checked"</span><span class="token punctuation">,</span><span class="token string">"checked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#cb1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"checked"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>jquery1.6+: prop 的 4 种赋值：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#cb1″).prop("</span>checked"<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">$</span><span class="token punctuation">(</span>"#cb1″<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">checked</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#cb1″).prop("</span>checked"<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//函数返回 true 或 false</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#cb1″).prop("</span>checked<span class="token string">", "</span>checked"<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>]]></content>
    <category term="其他"/>
    <published>2017-01-05T16:28:03.000Z</published>
  </entry>
  <entry>
    <title type="text">解决 github + Hexo 的博客多终端同步问题</title>
    <id>https://blog.realduang.com/blogs/others/2017-05-12.html</id>
    <link href="https://blog.realduang.com/blogs/others/2017-05-12.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>解决 github + Hexo 的博客多终端同步的思路是将博文内容相关文件放在 Github 项目中 master 中，将 Hexo 配置写博客用的相关文件放在 Github 项目的 hexo 分支上，这个是关键，多终端的同步只需要对分支 hexo 进行操作。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>解决 github + Hexo 的博客多终端同步的思路是将博文内容相关文件放在 Github 项目中 master 中，将 Hexo 配置写博客用的相关文件放在 Github 项目的 hexo 分支上，这个是关键，多终端的同步只需要对分支 hexo 进行操作。</p>
</div><!-- more -->
<p>下面是详细的步骤讲解：</p>
<h2>1. 准备条件</h2>
<p>安装了 Node.js,Git,Hexo 环境
完成 Github 与本地 Hexo 的对接
这部分大家可以参考史上 <a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener noreferrer">最详细的 Hexo 博客搭建图文教程</a></p>
<p>配置好这些，就可以捋起袖子大干一场了！</p>
<h2>2. 在其中一个终端操作，push 本地文件夹 Hexo 中的必要文件到 yourname.github.io 的 hexo 分支上</h2>
<p>在利用 Github+Hexo 搭建自己的博客时，新建了一个 Hexo 的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到 Github 项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p>
<p>git init  //初始化本地仓库
git add source //将必要的文件依次添加，有些文件夹如 npm install 产生的 node_modules 由于路径过长不好处理，所以这里没有用'git add .'命令了，而是依次添加必要文件，如下所示</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Blog Source Hexo"</span>
<span class="token function">git</span> branch hexo  //新建 hexo 分支
<span class="token function">git</span> checkout hexo  //切换到 hexo 分支上
<span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:yourname/yourname.github.io.git  //将本地与 Github 项目对接
<span class="token function">git</span> push origin hexo  //push 到 Github 项目的 hexo 分支上
</code></pre></div><p>完成之后的效果图为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/sync-hexo-01.png" alt="hexo 分支"></p>
<p>这样你的 github 项目中就会多出一个 Hexo 分支，这个就是用于多终端同步关键的部分。</p>
<h2>3. 另一终端完成 clone 和 push 更新</h2>
<p>此时在另一终端更新博客，只需要将 Github 的 hexo 分支 clone 下来，进行初次的相关配置</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> clone <span class="token parameter variable">-b</span> hexo git@github.com:yourname/yourname.github.io.git  //将 Github 中 hexo 分支 clone 到本地
<span class="token builtin class-name">cd</span>  yourname.github.io  //切换到刚刚 clone 的文件夹内
<span class="token function">npm</span> <span class="token function">install</span>    //注意，这里一定要切换到刚刚 clone 的文件夹内执行，安装必要的所需组件，不用再 init
hexo new post <span class="token string">"new blog name"</span>   //新建一个。md 文件，并编辑完成自己的博客内容
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">source</span>  //经测试每次只要更新 sorcerer 中的文件到 Github 中即可，因为只是新建了一篇新博客
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"XX"</span>
<span class="token function">git</span> push origin hexo  //更新分支
hexo d <span class="token parameter variable">-g</span>   //push 更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了 Github 中的 master
</code></pre></div><h2>4. 不同终端间愉快地玩耍</h2>
<p>在不同的终端已经做完配置，就可以愉快的分享自己更新的博客</p>
<p>进入自己相应的文件夹</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> pull origin hexo  //先 pull 完成本地与远端的融合
hexo new post <span class="token string">" new blog name"</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">source</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"XX"</span>
<span class="token function">git</span> push origin hexo
hexo d <span class="token parameter variable">-g</span>
</code></pre></div><p>本文转载自：<a href="http://blog.csdn.net/Monkey_LZL/article/details/60870891" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/Monkey_LZL/article/details/60870891</a></p>
]]></content>
    <category term="其他"/>
    <published>2017-05-12T15:51:06.000Z</published>
  </entry>
  <entry>
    <title type="text">在 Linux 下 nodejs 的安装方法大全</title>
    <id>https://blog.realduang.com/blogs/others/2017-06-11.html</id>
    <link href="https://blog.realduang.com/blogs/others/2017-06-11.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这段时间为了上线测试很多 nodejs 代码的部署，开始鼓捣云服务器。由于不是很懂运维知识，首先在安装上就踩了很多大坑，于是决定记录下来做个备忘。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这段时间为了上线测试很多 nodejs 代码的部署，开始鼓捣云服务器。由于不是很懂运维知识，首先在安装上就踩了很多大坑，于是决定记录下来做个备忘。</p>
</div><!-- more -->
<p>首先，我们可以去 <a href="https://nodejs.org/en/download/current/" target="_blank" rel="noopener noreferrer">nodejs 官网</a> 下载代码。</p>
<p>页面大概长成这样，上面有不同系统的不同位版本的下载，也可以点击上面的连接直接下载源码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/realDuang/blog-storage/images/node-install-linux-01.jpg" alt="01.jpg"></p>
]]></content>
    <category term="其他"/>
    <published>2017-06-11T01:06:46.000Z</published>
  </entry>
  <entry>
    <title type="text">github 建立 repository 并上传工程的方法</title>
    <id>https://blog.realduang.com/blogs/others/2017-07-02.html</id>
    <link href="https://blog.realduang.com/blogs/others/2017-07-02.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这不是什么新知识了，自从我用 github 以来一直就是这么用着的，但是最近有一段时间没上传过自己的 project 了，竟然手生了忘了怎么做了。想了想还是记录下来比较好，也给大家分享分享。</p>
<p>由于是给自己做的备忘，怎么注册 github 之类的新手问题我就不说了，不懂的朋友可以自行去百度相关问题，很多的。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>这不是什么新知识了，自从我用 github 以来一直就是这么用着的，但是最近有一段时间没上传过自己的 project 了，竟然手生了忘了怎么做了。想了想还是记录下来比较好，也给大家分享分享。</p>
<p>由于是给自己做的备忘，怎么注册 github 之类的新手问题我就不说了，不懂的朋友可以自行去百度相关问题，很多的。</p>
</div><!-- more -->
<h2>先 clone 再写入的方法(适用于还未开发项目时)</h2>
<p>通常最简单最无脑的办法就是现在 github 网站上创建一个 repository，可以自己任意设定名字和 readme.md。之后通过：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> clone git@github.com:username/respositoryname.git
</code></pre></div><p>克隆到本地，之后往里面写入文件文件夹就行了。</p>
<p>写完想要提交到 github 的话，就输入如下命令：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> pull
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"first commit"</span>
<span class="token function">git</span> push origin master
</code></pre></div><p>这里最好先 git pull 一下，以免有冲突导致提交不成功。</p>
<h2>对本地项目 git init 再提交(适用于项目已经成型，想要在此时进行版本控制)</h2>
<p>如果你已经写好了工程但还没有进行过 git 版本控制，或者直接是从别的地方下载好的 github 上的工程还没有进入你自己的代码库的话，可以使用这种方法：</p>
<p>首先，如果你的工程完全没有经过 git 版本控制，那么在你的工程目录中输入命令：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>    <span class="token function">git</span> init
    <span class="token function">touch</span> .gitignore
</code></pre></div><p>之后你的工程里会多出一个。git 的文件夹，之后你需要建立一个。gitignore 文件，来建立规则忽略你不想传上 github 进行版本控制的文件或文件夹(一般为依赖库、数据库或者一些隐私文件)，配置规则请百度。</p>
<p>之后的操作跟方法一大体相同，指定要提交到的远程 repository，并注意同步冲突问题，之后提交即可。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"first commit"</span>
<span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:username/respositoryname.git
<span class="token function">git</span> pull origin master
<span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master
</code></pre></div><p>其实 github 还提供了一个方法：import code from another repository，从别的版本库中导入工程，这个就不细说了，因为 git 是公认的目前最好的版本控制库，根本不需要再放在别的地方了。有历史原因的工程想导入的话完全可以先下载下来，再参照方法一二进行。</p>
]]></content>
    <category term="其他"/>
    <published>2017-07-02T23:46:32.000Z</published>
  </entry>
  <entry>
    <title type="text">git 常用命令笔记</title>
    <id>https://blog.realduang.com/blogs/others/2018-01-03.html</id>
    <link href="https://blog.realduang.com/blogs/others/2018-01-03.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>git 是现如今最火的版本控制工具，尽管已经使用了 GitHub 数年的时间了，但一直没有对 git 命令以及作用进行深入的分析和学习，对 git 的使用还仅停留在 add、commit、push、clone 上，这根本算不得掌握 git。因此，这次一得出空来就开始从头恶补 git 知识了，分享出来与大家一同学习进步。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>git 是现如今最火的版本控制工具，尽管已经使用了 GitHub 数年的时间了，但一直没有对 git 命令以及作用进行深入的分析和学习，对 git 的使用还仅停留在 add、commit、push、clone 上，这根本算不得掌握 git。因此，这次一得出空来就开始从头恶补 git 知识了，分享出来与大家一同学习进步。</p>
</div><!-- more -->
<h2>文件指针</h2>
<ol>
<li>git log 可以查看历次提交信息，其中就有每一次提交的 hash 值，这对每一次提交都是唯一的文件指针。hash 可以用短 hash 值表示，只需要在 git log 后加上--abbrev-commit 参数即可。</li>
<li>HEAD 是一个特殊的文件指针，它指向当前工作区版本的位置。</li>
<li>^和~的意思都是指向该版本的父提交，如 HEAD^与 HEAD~其实是等价的，但是~2 与^^等价，与^2 不等价，^2 指的是该版本的第二个父提交版本(因为在 merge 过后一个文件版本会有多个父版本)。</li>
</ol>
<h2>文件版本控制操作</h2>
<ol>
<li>
<p>git add &lt; file &gt;          // 将文件的修改从工作区添加至暂存区 (staged)</p>
</li>
<li>
<p>git rm &lt; file &gt;            // 将删除文件这样一个修改操作提交到暂存区</p>
</li>
<li>
<p>git commit            // 将暂存区的所有修改提交入库</p>
<p>-m 参数 填写提交内容的说明。</p>
<p>--amend 表示回退最近一次 commit 重新编写内容说明。</p>
<p>-a 相当于自动做了一次<code>git add .</code>操作。</p>
</li>
<li>
<p>git checkout -- &lt; file &gt;</p>
<p>checkout 命令有两种作用，后面加上 -- (注意两边都有空格，是一个独立参数)后的意思是，将文件同步成版本库中最新的状态。相当于取消当前工作区的所有更改。但是这个操作不会影响暂存区 (staged) 中的内容。</p>
<p>这对本地已经删除但还没有 git rm 的文件同样适用，能够恢复本地工作区的文件。需要注意的是，此操作不可逆，工作区的修改中的文件内容将无法恢复。</p>
<p>但如果要修改的文件已经在暂存区的话，无论是 git add 还是 git rm，就只能通过 git reset 恢复了，接下来介绍。</p>
<p>git checkout 的另外一种意思在下面介绍。</p>
<p>更新：git2.23 新增语法糖<code>git restore</code>命令，更语义化的本地修改撤销操作。</p>
<p><code>git restore &lt; file &gt;</code> 作用效果与<code>git checkout -- &lt; file &gt;</code>相同，都是表示将工作区的修改全部取消。</p>
<p>而若加入--staged 参数，则是表示将缓存区的文件撤销回工作区的意思，等价于<code>git reset HEAD</code>。</p>
</li>
<li>
<p>git reset &lt; hash &gt;</p>
<p>这是个功能及其强大也及其复杂的命令。它表示在本地库回滚状态。</p>
<p>它主要有三种参数，分别代表三种不同效果的回滚。</p>
<p>--hard，是 git 中少有的几个会丢失信息的操作，它代表将该版本库中的内容强制覆盖本地文件，使得暂存区和工作区的状态强制与该版本同步。该操作不可逆，会使得你正在工作区和暂存区的文件修改完全丢失。不仅如此，被你回退之前的版本将会剔除出提交树中，不会显示在版本控制信息里，版本将无法回溯。因此慎用！非要使用的话最好先 git stash 缓存一下。</p>
<p>还有一种用法，如果我们希望彻底丢掉本地修改但是又希望保留当前 branch 所指向的版本的话，直接 git reset --hard HEAD 即可。</p>
<p>(当然，非要找回还是有办法的，使用 git reflog 查找那个版本的 hash 再 git reset 回来即可)</p>
<p>--soft，它使得文件的状态与 HEAD 指针都回退到指定版本的位置，并且同时，当前处于工作区和暂存区的文件都不会做任何更改。所有的在 HEAD 节点和你重置到的那个版本之间的所有变更集都放在暂存区中。</p>
<p>--mixed，为 git reset 的默认参数，混合了--hard 与--soft 的特点，它也将文件的状态与 HEAD 指针都回退到指定版本的位置，但只将暂存区与该版本强制同步，工作区的内容不会被更改。并且它也不会剔除</p>
</li>
<li>
<p>git stash  // 修改代码的临时存储</p>
<p>对于还没有 commit 但是被 git 跟踪到了的代码，如果需要临时存储一下可以使用<code>git stash</code>命令，会建立一个栈来存储当前的修改代码。</p>
<p>需要恢复时，可以使用<code>git stash pop</code>恢复最后一次临时存储的代码。若想恢复其他时间存储过的代码，使用<code>git stash list</code>查看所有被临时存储了的代码，然后找到某一次存储的 stash id，然后使用<code>git stash drop stash@&lt; id &gt;</code>来进行恢复。</p>
<p>加入--include-untracked 参数可以存储未被加入 git 跟踪的代码。</p>
<p>使用<code>git stash clear</code>删除所有被临时存储的 stash 记录。</p>
</li>
<li>
<p>git merge &lt; branch &gt;        // 将该分支合并进当前分支</p>
<p>这里的 merge 分<code>fast-forward</code>和<code>recursive</code>等模式，但 git 都能自动匹配最佳方案，就不提了。</p>
<p>要注意的是，合并过程中可能产生文件冲突。这时，当前分支会变为名叫<code>&lt;branch&gt;|MERGING</code>的临时分支，需要手动解决后，使用<code>git merge --continue</code>，才能产生新的合并提交。若要取消这次合并，使用<code>git merge --abort</code>即可。</p>
</li>
<li>
<p>git rebase &lt; hash &gt;        // 分支历史的变基</p>
<p>这个命令是在不希望产生合并的分支历史的特殊要求下使用的，对清理出一条干净的 git 提交线非常有帮助。</p>
<p>加入-i 参数增加分布操作，能够使操作图形化，推荐使用时添加。</p>
<p>命令参数：</p>
<p>p, pick &lt;提交&gt; = 使用提交</p>
<p>r, reword &lt;提交&gt; = 使用提交，但修改提交说明</p>
<p>e, edit &lt;提交&gt; = 使用提交，进入 shell 以便进行提交修补</p>
<p>s, squash &lt;提交&gt; = 使用提交，但融合到前一个提交</p>
<p>f, fixup &lt;提交&gt; = 类似于 "squash"，但丢弃提交说明日志</p>
<p>x, exec &lt;命令&gt; = 使用 shell 运行命令(此行剩余部分)</p>
<p>b, break = 在此处停止(使用 'git rebase --continue' 继续变基)</p>
<p>d, drop &lt;提交&gt; = 删除提交</p>
<p>l, label &lt; label &gt; = 为当前 HEAD 打上标记</p>
<p>t, reset &lt; label &gt; = 重置 HEAD 到该标记</p>
<p>m, merge [-C &lt; commit &gt; | -c &lt; commit &gt;] &lt; label &gt; [# &lt; oneline &gt;] 创建一个合并提交，并使用原始的合并提交说明</p>
</li>
<li>
<p>git push &lt; remote &gt; &lt; branch &gt;        // 将本地某个分支的更新推送到远程</p>
<p>其中本地分支名可以与远程分支名不同步，将&lt; branch &gt;部分改写为<code>&lt;本地分支名&gt;:&lt;远程分支名&gt;</code>即可。</p>
<p>这里还有一个特殊操作，如果不指定本地分支名，像是<code>:&lt;远程分支名&gt;</code>这样，表示删除该远程分支。</p>
<p>比较常用的参数如下：</p>
<p>-u，指定当前推送的主机为默认主机，这样后面就可以不加任何参数使用<code>git push</code>。不带任何参数的<code>git push</code>，默认只推送当前分支。</p>
<p>-d 或--delete，删除该远程主机的该分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<p>-f 或--force，当你需要提交一个有文件冲突的版本，需要本地强制覆盖远程时，使用这个参数，它将在远程主机产生一个”非直进式”的合并 (non-fast-forward merge)。</p>
<p>--all，不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机。</p>
<p>--tags，推送时将本地的 tags 标签也推送上去(默认不推送)。</p>
</li>
<li>
<p>git pull &lt; remote &gt; &lt; branch &gt;        // 取回远程主机某个分支的更新。</p>
</li>
</ol>
<p>功能相当于同时执行了<code>git fetch</code>与<code>git merge</code>。参数大致与<code>git push</code>相同，就不多做介绍了。</p>
<ol start="11">
<li>git revert &lt; hash &gt;   // 分支的回滚操作</li>
</ol>
<p>与<code>git reset</code>的区别在于 revert 不会更改或删除原有的提交记录，反而会生成一条新的提交。对于线上代码或者多人使用的回滚来说一定要使用 revert 而不是 reset，尽量不要修改多人合作分支的时间线。</p>
<p>加入-n 参数能将多次回滚，合并成一次 commit。如果不加-n，回滚了多少条 commit 就会新生成多少条 commit。</p>
<h2>状态信息查看操作</h2>
<ol>
<li>
<p>git remote        // 列出所有远程主机。</p>
<p><code>-v</code>选项，可以参看远程主机的网址。</p>
<p>git remote add &lt;主机名&gt; &lt; git 地址 &gt;，添加远程主机。</p>
<p>git remote rm &lt;主机名&gt;，删除远程主机。</p>
</li>
<li>
<p>git branch        // 查看该版本的所有分支</p>
<p>默认只查看本地分支。<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>
<p>git branch &lt; branch &gt;</p>
<p>表示新建分支。(若分支已存在，则报错。)</p>
</li>
<li>
<p>git checkout &lt; branch &gt;</p>
<p>又是这个命令，但是注意，这一次没有<code>--</code>命令，它表示将工作区跳转到该分支上。</p>
<p>若不存在该分支，可以使用<code>-b</code>参数新建该分支并跳转到该分支上。</p>
</li>
<li>
<p>git status        // 查看当前的工作区和暂存区文件修改</p>
</li>
<li>
<p>git reflog        // 查看该分支的历史提交记录</p>
<p>到目前我发现它最有用的地方就是记录了我<code>git reset --hard</code>之前的版本 hash，可以让我恢复版本。</p>
</li>
<li>
<p>git log             // 查看该分支的提交记录</p>
<p>如果跟我一样不太喜欢用 gitk 这样的 GUI 的话，我提供几个常用参数作参考。参数对 gitk 也适用。</p>
<p>--oneline 给我的感觉相当于--pretty=oneline 与--abbrev-commit 的结合，只显示提交 ID 和提交信息的第一行。</p>
<p>--all 显示所有分支的信息。</p>
<p>--decorate 标记让 git log 显示指向这个提交的所有引用(比如说分支、标签等)。</p>
<p>--graph 选项绘制一个 ASCII 图像来展示提交历史的分支结构。</p>
<p>-[number]，表示只显示最后提交的若干列信息。</p>
</li>
<li>
<p>gitk                  // git log 的图形化界面版本</p>
</li>
</ol>
]]></content>
    <category term="其他"/>
    <published>2018-01-03T16:53:25.000Z</published>
  </entry>
  <entry>
    <title type="text">中文输入法中光标跟随能力触发的浏览器事件探究</title>
    <id>https://blog.realduang.com/blogs/others/2021-02-01.html</id>
    <link href="https://blog.realduang.com/blogs/others/2021-02-01.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在着手腾讯文档的输入体验优化，在其中有一个不起眼的小需求引起了我的注意，并顺便研究了一些事件监听机制相结合的特点，特此记录一下填坑过程。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近在着手腾讯文档的输入体验优化，在其中有一个不起眼的小需求引起了我的注意，并顺便研究了一些事件监听机制相结合的特点，特此记录一下填坑过程。</p>
</div><!-- more -->
<h2>模拟光标跟随</h2>
<p>大部分的主流输入法都有这样一个特性，在输入中文时，可以通过左右方向键控制光标，移动至输入区中任意两个字符之间的位置，用户接下来的字符输入将在光标处直接插入。</p>
<p>由于腾讯文档的渲染的画布是完全自主实现的，为了在体验上与普通可编辑画布保持一致，我们需要自己来模拟这一光标的移动行为。</p>
<p>首先，我们需要确定的是输入法中的模拟光标进行更新的时机。经试验，用户在进行中文输入时，若使用了<em>方向键</em>移动光标，将会触发光标的移动行为。因此，首先要解决的是使用合适的事件监听来捕获这一行为，从而进行更新。既然是对输入框的行为进行模拟，自然而然的，我们首先想到的是输入框触发的监听器。</p>
<h2>浏览器输入框对输入的监听机制</h2>
<p>在浏览器对键盘的输入规范中，将键盘输入分为了直接输入与间接输入两种。直接输入将会触发输入框的 <code>onInput</code> 事件 (IE9 之前不支持该事件，只能用 <code>onKeyUp</code> 等键盘事件作为降级选择)。而对于间接输入，规范将事件监听分为了 <code>onCompositionStart</code>, <code>onCompositionUpdate</code>, <code>onCompositionEnd</code> 三个部分。</p>
<p>而间接输入的同时，中间态的写入也会导致输入框内容的变化，从而也会触发 <code>onInput</code> 事件。因此在间接输入中，事件的触发次序为：<code>onCompositionStart</code>, <code>onCompositionUpdate</code>, <code>onInput</code>, <code>onCompositionEnd</code>。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210203173000.png" alt="20210203173000"></p>
<p>需要注意的是，若输入完成时，输入框的内容没有发生变化，则 <code>onChange</code> 事件与 <code>onCompositionEnd</code> 事件都将不会被触发。</p>
<p>中文输入法在键入选词的过程属于间接输入情况，此时中间文本不会直接落盘在输入框内。而通过回车等按键退出中文输入选词后，中文文字将会落盘到输入框，此时属于直接输入情况。</p>
<p>而我们需要关注的光标事件显然是在间接输入中获取到的。在输入法选词光标左右移动时，由于内容不变，此时并不会触发 <code>onInput</code> 事件，但是会触发一次 <code>onCompositionUpdate</code> 事件，我们可以通过这个事件来判断光标位置，重置画布的光标位置。但最终我们并未使用这个事件做判断器，原因在下面会讲到。</p>
<h2>判断当前光标的位置</h2>
<p>解决了了光标的重置时机，接下来就该解决光标的位置判定了。由于 DOM 标准中并没有直接获取光标位置的方法，因此这一块也需要我们自主实现。我的思路是，通过选取光标到输入起始位置的字符串，判断选中的字符串长度，即可知道光标当前位置相对于起始位置的偏移量，从而确定光标位置。</p>
<p>对于普通的 input 输入框来说起始比较简单，输入框提供了 <code>inputElement.selectionStart</code> 属性作为当前光标位置距离输入起始点的偏移量，我们直接使用就可以了。但是对于 <code>contentEditable=true</code> 的 div 节点来说是没有这一属性的，我们得另想办法。</p>
<p>根据之前写 E2E 测试得来的灵感，我们可以模拟创建一个从当前光标位置到输入起始位置的选区，通过判断该选区的字符串长度即光标所在位置的偏移量。通过 <code>window.getSelection()</code> 方法能够得到 Selection 对象，这是一个表示当前文本选区的对象，由于我们正处在输入状态中，因此该选区位置就在当前的输入框中，从而能获取到上面所需的偏移量。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> selection <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确定输入框在输入态，存在选区</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>selection<span class="token punctuation">.</span>rangeCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> range <span class="token operator">=</span> selection<span class="token punctuation">.</span><span class="token function">getRangeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> range<span class="token punctuation">.</span>endOffset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>获取完光标位置，还需要在我们的画布上重新设置回去。设置的思路其实是类似的，通过使用<code>document.createRange</code>方法新建一个选区范围，其起始位置设置为需要移动的目标位置，然后移除选区，即可使光标落在目标位置了。</p>
<h2>性能优化</h2>
<p>之前说到在光标移动时的确会触发一次<code>onCompositionUpdate</code> 事件。但是，<code>onCompositionUpdate</code> 事件是一个高频的操作，每一次间接输入时都会触发，这会导致光标不断地重置位置，带来不必要的性能损失。</p>
<p>并且，<code>onCompositionUpdate</code> 事件的入参只有更新的中间字符串值，只能用来判断输入中间字符串是否发生变化。移动光标行为本身并不会导致字符串发生改变，但反过来，使字符串不发生改变的操作一定是移动光标操作这一说法并不成立。因此，尽管移动光标会触发该事件，但我们仍然没有有效的手段去判断是输入法中的光标移动导致的事件触发。</p>
<p>那么，之前用很大篇幅讲过光标变动的本质实际上是选区变化，那么，输入法触发的光标移动会不会给输入框发出选区变更通知呢？很不幸，目前绝大多数的输入法都是不支持的。并且由于光标移动被视为输入法内部的行为，因此在输入框中光标所进行的移动，不会有事件主动抛出。因此，输入框中的选区变更事件 <code>onSelectionChange</code> 事件也无法被触发。</p>
<p>既然输入框中的事件监听无法准确判断光标的移动，我们只能退而求其次，从更低层次的逻辑，通过监听键盘的按键输入来尝试还原这一行为了。优化思路是这样的，触发光标跟随的时机规则为：用户输入时，若使用了<em>左方向键</em>移动光标，将会开启光标跟随的能力，随着输入不断更新的光标位置，直到光标再次被移动到末尾位置结束。由于中文输入时按下<em>左方向键</em>的行为是一个低频操作，这样一来，大部分的输入操作都不需要执行判断并重置光标，提高普通输入下的性能表现。</p>
<p>附上最终的判断逻辑吧：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210207174544.png" alt="20210207174544"></p>
<p>那么，如何获取并判断用户输入时的按键信息呢？当然是使用更第一层级的事件接口 KeyboardEvent 了。</p>
<h2>键盘输入事件对中文输入法的支持</h2>
<p>KeyboardEvent 在低层级下提示用户与一个键盘按键的交互是什么，不涉及这个交互的上下文含义。一般来说当你需要处理文本输入的时候，应当使用上节所说的输入框监听事件代替。例如当用户使用其他方式输入文本时，如平板电脑的手写系统等，键盘事件可能不会触发。</p>
<blockquote>
<p>KeyboardEvent 对象描述了用户与键盘的交互。 每个事件都描述了用户与一个按键(或一个按键和修饰键的组合)的单个交互；事件类型 keydown，keypress 与 keyup 用于识别不同的键盘活动类型。</p>
</blockquote>
<p>键盘输入事件的设计思路与间接输入的钩子类似，浏览器中对于键盘输入同样分为 <code>onKeyDown</code>, <code>onKeyPress</code>, <code>onKeyUp</code> 三个阶段的事件触发，分别对应按键不同的行为触发时机。(注：<code>onKeyPress</code> 事件高度依赖设备支持，所以尽量不要使用该钩子)</p>
<p>这三个事件都传入了 KeyboardEvent 入参，帮助我们了解当前执行该事件时触发的按键信息。MDN 上该入参具有如下属性支持：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210203204752.png" alt="20210203204752"></p>
<p>在文档规范中，我们可以发现许多对问题的解决十分有用的新属性，例如 <code>event.isComposing</code> 属性用于判断当前是否会触发 <code>onCompositionUpdate</code> 事件，<code>event.code</code> 用于判断与键盘布局与输入状态无关的当前按键输入，获取中文输入中的按键轻而易举。我们可以利用这两个状态帮助我们完成按键监听与事件触发。</p>
<h2>兜底方案支持</h2>
<p>之前说过， KeyboardEvent 是一个十分依赖软硬件支持的事件，不仅需要浏览器的能力支持，与输入法甚至键盘类型都有关系。经试验后发现，这些新属性在许多浏览器与输入法的组合中都无法通过<code>onKeyDown</code>正确获取，在 Windows 下部分中文输入法甚至都无法支持 <code>event.key</code> 属性。为了达到最大的兼容性，在兜底的方法下，仅能用 <code>event.keyCode</code> 这种已经被 deprecated 的方法来勉强替代使用了。</p>
<p>兜底方案的使用问题就此解决了吗？并没有。中文拼音的输入中间字符是系统无法识别的。在 Windows 桌面应用程序对键盘输入规范中，我们发现 Windows 将所有未识别的设备输入都设置为 <code>VK_PROCESSKEY 229</code>，浏览器的 <code>event.keyCode</code> 复用了这一规范，因此在中文输入过程中，无论按下什么按键，返回的 <code>event.keyCode</code> 永远是 229。</p>
<p>网上对于该问题的解决方案都是建议使用 <code>onKeyUp</code> 代替 <code>onKeyDown</code>。但首先，这不满足对于一个要求实时体现输入的光标移动操作要求。第二，使用 <code>onKeyUp</code> 会有更多的问题，在 Windows 下进行中文输入时，由于不同的输入法回调 <code>onKeyUp</code> 的实现不同，该事件可能会被触发一次或两次，要么全为 229，要么一次为 229，另一次为正确的 key(对，说的就是你，搜狗)。为了避免我们去不断去填五花八门的第三方输入法实现的坑，兜底方案采用了当检测到输入了未识别的按键时，也启用光标跟随能力。</p>
<h2>结语</h2>
<p>一套操作下来，这套中文输入法下光标跟随的功能算是完美实现了。回顾一下我们解决这个问题所趟过的坑，实际上也反映着浏览器 JS DOM 标准在不断进化，不断补足历史遗留的坑点。当然，它还远远称不上完美，仍然存在大量的能力缺失，如我们在这个问题中遇到的判断光标偏移量的解决方案，本质上还是一种 hack。而扩展 JS 的能力边界，使其变得更强大，更好用，这正是我们作为前端开发人员需要努力的方向。</p>
]]></content>
    <category term="其他"/>
    <published>2021-02-01T20:30:38.000Z</published>
  </entry>
  <entry>
    <title type="text">优雅地管理与同步个人工作环境 -- dotfiles manager</title>
    <id>https://blog.realduang.com/blogs/others/2021-03-13.html</id>
    <link href="https://blog.realduang.com/blogs/others/2021-03-13.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>实现一个完美个性化标准的目标是：一个统一管理及备份所有应用配置方式。而本篇文章带来的，就是为了满足这个目标而诞生的最佳解决方案 Dotfiles manager。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>实现一个完美个性化标准的目标是：一个统一管理及备份所有应用配置方式。而本篇文章带来的，就是为了满足这个目标而诞生的最佳解决方案 Dotfiles manager。</p>
</div><!-- more -->
<p>若想提高自己的开发效率，得心应手的工具是必不可少的。而各软件的配置种类繁多且各不相同，这需要我们花费大量的时间去学习和记忆。这给穿插使用各种工具的我们带来了较大的记忆成本，而为了减少这种记忆成本，我们会想办法统一一个个性化标准，然后在每个软件中进行设置，以尽量匹配这一标准。</p>
<p>而实现一个完美个性化标准的目标是：一个统一管理及备份所有应用配置方式。而本篇文章带来的，就是为了满足这个目标而诞生的最佳解决方案 Dotfiles manager。</p>
<h2>什么是dotfiles</h2>
<p>Dotfiles manager，实际上就是管理dotfiles的命令管理器。而所谓dotfiles，是指文件名称以 . 为前缀的文件或文件夹的统称。对于unix-based的系统来说，这样的文件名称在文件列表中处于不可见状态，即所谓的隐藏文件，需要通过-a的方式才能查看到。</p>
<p>这些文件多出现在用户的根目录下，通常是给该系统用户以及其所使用的软件存储一些个性化的配置，从而达到个人使用起来更贴合习惯，从而大幅提升工作效率。如常见的terminal个性化配置.bashrc或.bash_profile, vim个性化配置.vimrc等等，都属于dotfiles的范畴。</p>
<h2>为什么需要Dotfiles manager</h2>
<p>工具的使用的原则应该是：让工具适应我们，而不是让我们习惯工具。因此，我们会需要对工具进行符合自己使用习惯的改造。小到各软件快捷键及alias的配置统一，大到设置一键执行的多应用联动的工具化脚本。当许多或常用，或便利的配置被添加完毕之后，给自己带来的效率提升是无与伦比的。</p>
<p>而这样一来，软件配置将是一个高度定制化的东西，任何一个工具都需要时间进行深度地打磨来符合自己的使用习惯。问题还会越来越多，你会发现随着高度的定制化，尽管摆脱了特定软件特定操作对你的束缚，但又似乎被固定的设备深度绑定了，因为大量杂乱的配置使得你在更换新的开发环境的时候显得尤为艰难，需要手动对每一个软件重新进行一遍设置。由此一来，配置的更新及多设备同步也是一大难题。</p>
<p>之前说到，一个完美的个性化标准有两点：极为方便的</p>
<p>这时候，就急需一个能统一管理及备份所有应用配置的方式来帮助我们完成这一目标。而对于支持文件或命令行配置的应用来说，这一目标的最佳解决方案就是Dotfiles manager。</p>
<h2>有哪些软件能够被dotfiles manager支持</h2>
<p>从理论上来说，一切支持文件配置或命令行配置的应用及系统都一定能被Dotfiles manager支持。对于Linux来说，这几乎包括一切软件。</p>
<p>对于我日常使用环境来说，目前需要用到dotfiles manager来管理配置的主要有如下一些功能：</p>
<img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/image-20210120174747924.png" alt="image-20210120174747924" style="zoom:50%;">
]]></content>
    <category term="其他"/>
    <published>2021-03-13T16:06:27.000Z</published>
  </entry>
  <entry>
    <title type="text">Unreal Engine 5 逆向工程与游戏开发 - 黑神话悟空</title>
    <id>https://blog.realduang.com/blogs/others/black-myth-ue5-reverse-engineering.html</id>
    <link href="https://blog.realduang.com/blogs/others/black-myth-ue5-reverse-engineering.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240925152320.png" alt="20240925152320"></p>
<hr>
<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>本文将以 <strong>黑神话：悟空</strong> 为例，介绍如何对基于虚幻 5 引擎的游戏进行逆向工程。包括游戏解包、文件导出、资产制作、替换和打包，以及 mod 的安装和运行参数设置。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240925152320.png" alt="20240925152320"></p>
]]></content>
    <category term="其他"/>
    <published>2024-09-25T17:21:22.000Z</published>
  </entry>
  <entry>
    <title type="text">VS Code For Web 深入浅出 -- 导读篇</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/0.introductory.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/0.introductory.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>下一代 IDE 的形态究竟是什么呢？VS Code For Web 试图回答这个问题。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>下一代 IDE 的形态究竟是什么呢？VS Code For Web 试图回答这个问题。</p>
</div><!-- more -->
<h2>背景</h2>
<p>众所周知，VS Code 是当前工业界最优秀的代码编辑器之一。它由《设计模式》的作者 Erich Gamma 领导开发，因此，它的设计架构在很多地方十分精妙，近些年已经成为了各家竞相模仿学习的对象。</p>
<p>尽管 VSCode 作为桌面端应用十分优秀，但由于它基于 Electron，相当于在 Chromium 外套了一层壳，使得它的打包体积非常大，且无法直接安装在云端环境中，这就导致了它的使用场景非常有限。</p>
<p>2019 年，微软在 PyCon 2019 大会上发布了 <code>VSCode Remote</code> 扩展，支持了远程开发，这个扩展的出现，使得 VSCode 成为了一款真正的跨平台 IDE，不再局限于本地开发，可以通过 SSH 连接到远程服务器，然后在远程服务器上开发。</p>
<p>2020 年，<code>Github Codespaces</code> 又将 Web IDE 的进展向前迈进了一步，它允许用户访问 Github 上托管的所有项目来直接进行编辑与提交，而无需自己搭建服务器，实现了一个全托管的远程开发解决方案。但微软当时并未将其 Server 部分开源，由 Github 集中运营。</p>
<p>而在最近的 2022 年 7 月，微软公开并发布了 <code>private preview</code> 版本的 <code>VS Code Server</code>。这是一个<code>可私有化的</code>，可以在<code>远程</code>开发机器上运行的独立服务端。与 <code>Github Codespaces</code> 相同，它允许用户直接通过 URL，在浏览器中安全地链接到远程开发机，且同时支持了 <code>HTTP</code> 与 <code>Web Socket</code> 协议。在此过程中不需要进行任何前期的 SSH 或 HTTPS 设置。</p>
<p>官方基于此制作了基于 <code>VS Code Server</code> 的 <code>Web IDE</code>，可以直接通过浏览器访问 <a href="https://vscode.dev/" target="_blank" rel="noopener noreferrer">https://vscode.dev/</a> 进行体验。可以预见，这就是下一代 IDE 的形态，<code>Serverless, and Run Anywhere</code>。</p>
<p>注：本文基于 VSCode v1.71 版本。</p>
<h2>VS Code For Web 代码架构</h2>
<p>注意，在了解 <code>VS Code For Web</code> 的架构之前，我们最好对 VS Code 的组织架构有一定的了解。（详细内容可自行参考 <a href="https://github.com/microsoft/vscode/wiki/Source-Code-Organization" target="_blank" rel="noopener noreferrer">VSCode 的官方文档</a>。)</p>
<p>从设计上说，VS Code 是一个多进程架构的应用程序，它主要由客户端与服务端 2 个应用程序组成。</p>
<p>其中，客户端是一个 Electron 应用程序，它负责 UI 的渲染，以及与服务端的通信。而服务端则是一个 Node.js 应用程序，它负责处理客户端的请求，以及提供一些基础的功能。</p>
<p>而在 <code>VS Code For Web</code> 中，得益于使用 TS 语言，其客户端可以几乎无缝扩展到浏览器中。因此，主要的改动点在于 <code>VS Code Server</code> 的实现。</p>
<p>在 VSCode 的设计中， <code>VS Code Server</code> 是 VSCode 服务端的一个子集，它只实现了 VSCode 的本地服务端的一部分功能，它的主要目的是为了提供一个更轻量级的服务端，以便于在云端环境中运行。</p>
<p><code>VS Code For Web</code> 的架构分为了两个部分：</p>
<ol>
<li>Web Workbench，即 VSCode 的 Web 客户端，此处为浏览器各项服务配置的入口点，处理如何与后端建联，解析资源，以及加载 WebView 等。</li>
<li>Remote Server，为客户端提供 Terminal，File system，Debugger 等服务的访问能力。</li>
</ol>
<p>接下来，我们可以对照着 VSCode 的主要源码 <a href="https://github.com/microsoft/vscode/tree/main/src/vs" target="_blank" rel="noopener noreferrer">src/vs</a>，来直观的理解代码架构。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221013134251.png" alt="20221013134251"></p>
<p>其中，base 文件夹提供通用的基础依赖能力，如通用 UI 组件库，woker 通信能力，IPC 通信能力等。platform 文件夹更上一层，提供依赖注入能力、以及剪切板、文件处理等基础能力 Service。editor 文件夹即为代码编辑器 monaco，处理核心编辑区相关的内容。最外层的 workbench 文件夹则负责 view 层除了编辑器之外的工作区的 UI 布局与渲染。</p>
<p>而剩余部分即为启动客户端的支持能力。其中，code 文件夹为客户端启动的入口，包括从 web 端启动与桌面端启动。而 server 文件夹则是 <code>VS Code Server</code> 的主要位置，负责运行服务端程序的 <a href="https://github.com/microsoft/vscode/tree/main/src/vs/server" target="_blank" rel="noopener noreferrer">entrypoint</a>。</p>
<p>其代码组织如下图所示：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221017142530.png" alt="vscode code architecture"></p>
<p>从架构设计上可以看出，VSCode 采用从 view 到 infrastructure 的分层思想，使得数据与事件流单向流动。</p>
<p>从这里也可以看到，VSCode 的客户端与服务端采用了同构的设计思路，使得客户端与服务端提供服务形式的切换变得更加容易，从架构上就兼顾到了 Web IDE 的可行性。</p>
<h2>VSCode For Web 职责分工</h2>
<p>VSCode Server 与客户端运行的 VSCode 的架构职责区分如下图所示：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009135447.png" alt="20221009135447"></p>
<p>我们知道 VSCode 是一个多进程项目，从这张图中我们可以看出，VSCode 将几乎所有的运算进程都交给了服务端。由于机能的限制，实际上，属于客户端处理的除了主进程外，只有 UI 绘制相关的进程，以及与插件服务与本地服务间的通信进程（语言相关的 service 除外，为了在 web 端也能拥有不错的开发体验，language server 是使用了 worker thread 旁路执行的）。</p>
<p>因此 VSCode Server 除了负责启动服务的 Running App 进程外，还需要处理如 Terminal，File system，Debugger、Search 等等进程。它们的生命周期都是由 VSCode Server 管理的。</p>
<h2>结语</h2>
<p>本篇文章为导读篇，主要介绍了 <code>VSCode For Web</code> 的设计背景，并简单介绍了 <code>VSCode For Web</code> 的架构设计，以及前后端的职责分工。在下一篇文章中，我们将会着重介绍 <code>VSCode For Web</code> 的前后端通信机制。</p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2022-10-12T14:22:04.000Z</published>
  </entry>
  <entry>
    <title type="text">VS Code For Web 深入浅出 -- 进程间通信篇</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/1.inter-process-communication.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/1.inter-process-communication.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在上一篇中，我们一起分析了 VS Code 整体的代码架构，了解了 VS Code 是由前后端分离的方式开发的。且无论前端是基于 electron 还是 web，后端是本地还是云端，其调用方式并无不同。</p>
<p>这样的架构下，前后端的通信方式是如何实现的呢？本篇我们将一起来探究 VS Code For Web 的进程间通信方式。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在上一篇中，我们一起分析了 VS Code 整体的代码架构，了解了 VS Code 是由前后端分离的方式开发的。且无论前端是基于 electron 还是 web，后端是本地还是云端，其调用方式并无不同。</p>
<p>这样的架构下，前后端的通信方式是如何实现的呢？本篇我们将一起来探究 VS Code For Web 的进程间通信方式。</p>
</div><!-- more -->
<h2>进程通信与调用方式</h2>
<h3>进程间通信协议</h3>
<p>对于多进程架构的项目，进程之间的通信会通过进程间调用 (Inter Process Calling, IPC)。VSCode 中自己设计了专门的 IPC 模块来实现通信。代码位于 <a href="https://github.com/microsoft/vscode/blob/main/src/vs/base/parts/ipc" target="_blank" rel="noopener noreferrer">src/vs/base/parts/ipc</a>。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token keyword">enum</span> RequestType <span class="token punctuation">{</span>
    <span class="token builtin">Promise</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
    PromiseCancel <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">,</span>
    EventListen <span class="token operator">=</span> <span class="token number">102</span><span class="token punctuation">,</span>
    EventDispose <span class="token operator">=</span> <span class="token number">103</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从 enum type 可以看出，VSCode 的 IPC 模块同时支持两种调用方式，一种是基于 Promise 的调用实现， 另一种是通过 Event Emitter/Listener 的那一套事件监听机制来实现。</p>
<p>以事件监听机制为例，VSCode 中采用 <code>vscode-jsonrpc</code> 这个包来封装实现，调用方式如下：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> cp <span class="token keyword">from</span> <span class="token string">'child_process'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> rpc <span class="token keyword">from</span> <span class="token string">'vscode-jsonrpc/node'</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> childProcess <span class="token operator">=</span> cp<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Use stdin and stdout for communication:</span>
<span class="token keyword">let</span> connection <span class="token operator">=</span> rpc<span class="token punctuation">.</span><span class="token function">createMessageConnection</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">rpc</span><span class="token punctuation">.</span><span class="token function">StreamMessageReader</span><span class="token punctuation">(</span>childProcess<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">rpc</span><span class="token punctuation">.</span><span class="token function">StreamMessageWriter</span><span class="token punctuation">(</span>childProcess<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> notification <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">rpc</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">NotificationType</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'testNotification'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

connection<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

connection<span class="token punctuation">.</span><span class="token function">sendNotification</span><span class="token punctuation">(</span>notification<span class="token punctuation">,</span> <span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>服务端调用也采用类似的包装：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> rpc <span class="token keyword">from</span> <span class="token string">'vscode-jsonrpc/node'</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> connection <span class="token operator">=</span> rpc<span class="token punctuation">.</span><span class="token function">createMessageConnection</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">rpc</span><span class="token punctuation">.</span><span class="token function">StreamMessageReader</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">rpc</span><span class="token punctuation">.</span><span class="token function">StreamMessageWriter</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> notification <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">rpc</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">NotificationType</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'testNotification'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
connection<span class="token punctuation">.</span><span class="token function">onNotification</span><span class="token punctuation">(</span>notification<span class="token punctuation">,</span> <span class="token punctuation">(</span>param<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This prints Hello World</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

connection<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>进程间通信单元</h3>
<p>为了实现客户端与服务端之间的点对点通信，我们需要一个最小单元来实现消息的调用与监听。在 VSCode 中，这个最小单元即为 <code>Channel</code>。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">/**
 * An `IChannel` is an abstraction over a collection of commands.
 * You can `call` several commands on a channel, each taking at
 * most one single argument. A `call` always returns a promise
 * with at most one single return value.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IChannel</span> <span class="token punctuation">{</span>
    <span class="token generic-function"><span class="token function">call</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>command<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> cancellationToken<span class="token operator">?</span><span class="token operator">:</span> CancellationToken<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">listen</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>event<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> Event<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每次通信过程，需要客户端与服务端处于同一个 <code>Channel</code> 中。</p>
<h3>进程间通信建连</h3>
<p>在 VSCode 中，客户端与服务端之间的通信建立是通过 <code>Connection</code> 类来建立，通过传入客户端与服务端的 <code>Channel</code> ，即 <code>ChannelClient</code> 与 <code>ChannelServer</code> 来实例化连接。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Connection<span class="token operator">&lt;</span>TContext<span class="token operator">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Client<span class="token operator">&lt;</span>TContext<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">readonly</span> channelServer<span class="token operator">:</span> ChannelServer<span class="token operator">&lt;</span>TContext<span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token keyword">readonly</span> channelClient<span class="token operator">:</span> ChannelClient<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它们之间的区别是，由于服务端可以同时对多个客户端服务，因此支持多个 <code>Channel</code> 的获取，而<code>ChannelClient</code> 为一对一连接。</p>
<p>综上，我们就梳理清楚了 VSCode 中 IPC 模块的基本架构，了解了进程间的通信细节。</p>
<p>用一张图总结梳理一下知识点：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221010150243.png" alt="20221010150243"></p>
<p>由于 VSCode 的 IPC 模块天然支持异步能力，因此事实上它并不区分进程是本地进程还是远端进程，只要是通过 <code>Channel</code> 通信的，都可以被认为是进程间通信，都可以复用相同的代码编写。</p>
<h2>参考</h2>
<p><a href="https://github.com/microsoft/vscode/wiki/Source-Code-Organization" target="_blank" rel="noopener noreferrer">VSCode 的官方文档</a></p>
<p><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations" target="_blank" rel="noopener noreferrer">VSCode API</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/195472626" target="_blank" rel="noopener noreferrer">VSCode 源码解读--IPC 通信机制</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/360106947" target="_blank" rel="noopener noreferrer">vscode 源码解析 - 进程间调用</a></p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2022-10-20T23:13:52.000Z</published>
  </entry>
  <entry>
    <title type="text">VS Code For Web 深入浅出 -- Server 模块设计篇</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/2.server-module-design.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/2.server-module-design.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在了解了 VS Code 的通信机制后，我们可以着手分析 VS Code Server 中各模块的实现以及设计思路了。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在了解了 VS Code 的通信机制后，我们可以着手分析 VS Code Server 中各模块的实现以及设计思路了。</p>
</div><!-- more -->
<h2>VSCode Server 模块设计</h2>
<p>通过之前的介绍我们可以了解到，VS Code 的能力是前后端分离的，这使得 <code>remote server</code> 的改造实现变得简单。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009135447.png" alt="20221009135447"></p>
<p>通过这一张架构图，我们可以直观的看到在 VS Code 中，前后端能力职责的划分。</p>
<p>可以看出，除了少数的一些像本地文件上传，语法高亮、主题设置等能力，一些重依赖多进程通信、OS支持，语言编译的能力都被设计在了 Server 端中，以保证 Client 端足够的轻量简洁，可以运行在 Web 这样的轻环境中。</p>
<p>在本篇中，我来带大家浅要分析 Server 端的几个重要模块的设计思路与实现。</p>
<h2>Remote File System 设计</h2>
<p><code>Remote File System</code> 负责处理文件系统的读写操作，同时还需要处理文件系统的变化事件，以便于客户端能够实时更新文件系统的变化。在 VSCode 中，它封装了一层 <code>Virtual file system</code> 来实现对不同文件系统的兼容控制。</p>
<p>这一部分是 VSCode Server 的核心中最容易实现的部分。它本质上就是使依赖现代浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API" target="_blank" rel="noopener noreferrer">File_System_Access_API</a> 来实现的(强制在 HTTPS 下使用)。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getTheFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// open file picker</span>
  <span class="token punctuation">[</span>fileHandle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> window<span class="token punctuation">.</span><span class="token function">showOpenFilePicker</span><span class="token punctuation">(</span>pickerOpts<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// get file contents</span>
  <span class="token keyword">const</span> fileData <span class="token operator">=</span> <span class="token keyword">await</span> fileHandle<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>具体的代码声明位置见 <a href="https://github.com/microsoft/vscode/blob/dc8bd9cd7e5231745549ac6218266c63271f48cd/src/vs/vscode.d.ts#L7038" target="_blank" rel="noopener noreferrer">FileSystemProvider</a>。</p>
<p>这里使用 <code>vscode-vfs</code> 这个库来实现虚拟文件系统。这是一个 URI 方案，它注册了 <code>File System Provider</code>，并且该文件系统上的资源将由使用该模式的 URI 表示(例如<code>vscode-vfs://vscode/package.json</code>)。</p>
<p>因此，直接打开远程存储库也得以实现，例如 <code>Github Codespaces</code> 的打开就是这样实现的。</p>
<p>使用 <code>vscode-vfs://github/microsoft/vscode</code>， 通过访问 <code>https://github.com/microsoft/vscode</code>，就能够在不进行 <code>git clone</code>的情况下，直接打开项目文件夹了。</p>
<p>实例化后，全局都可以通过传入 <code>RuntimeEnvironment</code>，通过 <code>runtime.fs</code> 来访问与调用。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token function">stat</span><span class="token punctuation">(</span>uri<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>FileStat<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fileFs <span class="token operator">&amp;&amp;</span> uri<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> fileFs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> connection<span class="token punctuation">.</span><span class="token function">sendRequest</span><span class="token punctuation">(</span>FsStatRequest<span class="token punctuation">.</span>type<span class="token punctuation">,</span> uri<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">readDirectory</span><span class="token punctuation">(</span>uri<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> FileType<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fileFs <span class="token operator">&amp;&amp;</span> uri<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> fileFs<span class="token punctuation">.</span><span class="token function">readDirectory</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> connection<span class="token punctuation">.</span><span class="token function">sendRequest</span><span class="token punctuation">(</span>FsReadDirRequest<span class="token punctuation">.</span>type<span class="token punctuation">,</span> uri<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然，对于不支持这套 API 的浏览器来说，打开时会检测接口，弹出警告。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009144016.png" alt="20221009144016"></p>
<p>至于解决方式，之前说过，VSCode 的 server 端是同构的，server 自然也能提供本地文件系统支持，仍可以通过浏览器的上传 API 来实现。</p>
<h2>Remote Terminal Process 设计</h2>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009181331.png" alt="20221009181331"></p>
<p>这里实际上是复用了VSCode 之前推出的 <code>Remote-Server extension</code> 能力，通过 SSH 隧道的方式，将终端的输入输出流转发到远程服务器上。(再一次说明了为什么强制要求在HTTPS下使用)</p>
<p>还记得我们之前提到过的，<code>Channel</code> 为通信的最小单元吗？<code>VSCode Server</code> 的 <code>Remote Terminal</code> 就是通过一个 <code>RemoteTerminalChannel</code> 来实现的。</p>
<p>通过监听与触发不同的事件(如<code>onExecuteCommand</code>, <code>sendCommandResult</code>)，来实现对 <code>Remote Terminal</code> 的不同行为的信息同步。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code>    <span class="token keyword">async</span> <span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> RemoteAgentConnectionContext<span class="token punctuation">,</span> command<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> args<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'$restartPtyHost'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>restartPtyHost<span class="token operator">?.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">'$createProcess'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> uriTransformer <span class="token operator">=</span> <span class="token function">createURITransformer</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>remoteAuthority<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createProcess</span><span class="token punctuation">(</span>uriTransformer<span class="token punctuation">,</span> <span class="token operator">&lt;</span>ICreateTerminalProcessArguments<span class="token operator">&gt;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">case</span> <span class="token string">'$attachToProcess'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">attachToProcess</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$detachFromProcess'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">detachFromProcess</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">'$listProcesses'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">listProcesses</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$orphanQuestionReply'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">orphanQuestionReply</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$acceptPtyHostResolvedVariables'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>acceptPtyHostResolvedVariables<span class="token operator">?.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">'$start'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$input'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$acknowledgeDataEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">acknowledgeDataEvent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$shutdown'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$resize'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getInitialCwd'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">getInitialCwd</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getCwd'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">getCwd</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">'$processBinary'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">processBinary</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">'$sendCommandResult'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_sendCommandResult</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$installAutoReply'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">installAutoReply</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$uninstallAllAutoReplies'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">uninstallAllAutoReplies</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getDefaultSystemShell'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_getDefaultSystemShell</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getProfiles'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_getProfiles</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getEnvironment'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getWslPath'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_getWslPath</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getTerminalLayoutInfo'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">getTerminalLayoutInfo</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>IGetTerminalLayoutInfoArgs<span class="token operator">&gt;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$setTerminalLayoutInfo'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">setTerminalLayoutInfo</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ISetTerminalLayoutInfoArgs<span class="token operator">&gt;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$serializeTerminalState'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">serializeTerminalState</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$reviveTerminalProcesses'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">reviveTerminalProcesses</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$getRevivedPtyNewId'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">getRevivedPtyNewId</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$setUnicodeVersion'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">setUnicodeVersion</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$reduceConnectionGraceTime'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_reduceConnectionGraceTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$updateIcon'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">updateIcon</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$updateTitle'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">updateTitle</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$updateProperty'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">updateProperty</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$refreshProperty'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">refreshProperty</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$requestDetachInstance'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">requestDetachInstance</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$acceptDetachedInstance'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span><span class="token function">acceptDetachInstanceReply</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$freePortKillProcess'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>freePortKillProcess<span class="token operator">?.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">IPC Command </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>command<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> not found</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">listen</span><span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> event<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> Event<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'$onPtyHostExitEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onPtyHostExit <span class="token operator">||</span> Event<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onPtyHostStartEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onPtyHostStart <span class="token operator">||</span> Event<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onPtyHostUnresponsiveEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onPtyHostUnresponsive <span class="token operator">||</span> Event<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onPtyHostResponsiveEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onPtyHostResponsive <span class="token operator">||</span> Event<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onPtyHostRequestResolveVariablesEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onPtyHostRequestResolveVariables <span class="token operator">||</span> Event<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onProcessDataEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onProcessData<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onProcessReadyEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onProcessReady<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onProcessExitEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onProcessExit<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onProcessReplayEvent'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onProcessReplay<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onProcessOrphanQuestion'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onProcessOrphanQuestion<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onExecuteCommand'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onExecuteCommand<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onDidRequestDetach'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onDidRequestDetach <span class="token operator">||</span> Event<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'$onDidChangeProperty'</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_ptyService<span class="token punctuation">.</span>onDidChangeProperty<span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Not supported'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2>Extension Processes 设计</h2>
<h3>存储位置</h3>
<p>VSCode Server 会将通过 <code>code-server --install-extension &lt;extension id&gt;</code> 命令安装的 extensions 存储在 <code>$XDG_DATA_HOME/code-server/extensions</code> 下。</p>
<p>用户配置信息存储在本地的<code>~/.vscode</code> 下，使用官方的 <a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener noreferrer">Settings Sync</a> 插件进行配置漫游。</p>
<h3>插件分类</h3>
<p>VSCode 将插件分为了 <code>UI Extension</code> 与 <code>Workspace Extension</code> 两种，通过 <code>extensionKind</code> 字段进行指定。</p>
<p>如果不涉及到 Node.js 调用的简单插件，是纯声明性质的代码的话(例如 Themes、key-binding，或者能直接利用<a href="https://code.visualstudio.com/api/references/vscode-api" target="_blank" rel="noopener noreferrer">客户端 API</a> 能覆盖能力的插件等)，则可以定义为 <code>UI Extension</code>，直接在客户端中执行，服务端只保存插件的配置信息，无需进行通信。</p>
<p>这也是为什么 vscode.dev 中(截至目前位置，该网页不包含 Server 能力)，所有的主题、包括例如 TS、Python、Markdown、HTML 等语言的文件补全、语法高亮、括号着色都是可以正常使用的原因。因为在架构上，这些能力都是由客户端的内置插件(语言补全等相关特性是通过专门编写的 web worker thread 旁路执行)提供的，通过 <a href="https://code.visualstudio.com/api/references/vscode-api" target="_blank" rel="noopener noreferrer">VSCode API</a> 直接进行调用。</p>
<p>但如果功能涉及到运行时的系统级调用，则需要被定义为<code>Workspace Extension</code>，它可以完全访问源码、文件系统、以及大部分 <code>OS API</code>。</p>
<p><code>Workspace Extension</code> 需要安装在服务端，并需要在插件中显式声明。</p>
<p>体现在编码规范上，我们需要为插件项目的 <code>package.json</code> 文件中添加 <code>main</code> 的 entrypoint，以执行服务端插件调用，而 <code>UI Extension</code> 的 entrypoint 使用 <code>browser</code> 表示。</p>
<div class="language-json" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    ...
    <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"./dist/node/extension.js"</span><span class="token punctuation">,</span>
    <span class="token property">"browser"</span><span class="token operator">:</span> <span class="token string">"./dist/browser/extension.js"</span><span class="token punctuation">,</span>
    <span class="token property">"capabilities"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"virtualWorkspaces"</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    ...
<span class="token punctuation">}</span>
</code></pre></div><p>逻辑上，插件需要根据 web 端与 server 端分开编写，并自行做好兼容。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221010111137.png" alt="20221010111137"></p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2022-11-02T20:49:33.000Z</published>
  </entry>
  <entry>
    <title type="text">VS Code For Web 深入浅出 -- 依赖注入设计</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/3.dependency-injection-design.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/3.dependency-injection-design.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在阅读 VSCode 代码的过程中，我们会发现每一个模块中都有大量装饰器的使用，用来装饰模块以及其中依赖的模块变量。这样做的目的是什么呢？在这一篇中我们来详细分析一下。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在阅读 VSCode 代码的过程中，我们会发现每一个模块中都有大量装饰器的使用，用来装饰模块以及其中依赖的模块变量。这样做的目的是什么呢？在这一篇中我们来详细分析一下。</p>
</div><!-- more -->
<h2>依赖注入介绍</h2>
<p>如果有这样一个模块 A，它的实现依赖另一个模块 B 的能力，那么应该如何设计呢？很简单，我们可以在 A 模块的构造函数中实例化模块 B，这样就可以在模块 A 内部使用模块 B 的能力了。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是这样做有两个问题，一是模块 A 的实例化过程中，需要手动实例化模块 B，而且如果模块 B 的依赖关系发生变化，那么也需要修改模块 A 的构造函数，导致代码耦合。</p>
<p>二是在复杂项目中，我们在实例化模块 A 时，难以判断模块 B 是否被其他模块依赖而已经实例化过了，从而可能将模块 B 多次实例化。若模块 B 较重或者需要为单例设计，这将带来性能问题。</p>
<p>因此，更好的方式是，将所有模块的实例化交给外层框架，由框架统一管理模块的实例化过程，这样就可以解决上述两个问题。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种将依赖对象通过外部注入，避免在模块内部实例化依赖的方式，称为依赖注入 (Dependencies Inject, 简称 DI)。这在软件工程中是一种常见的设计模式，我们在 Java 的 Spring，JS 的 Angular，Node 的 NestJS 等框架中都可以看到这种设计模式的应用。</p>
<p>当然，在实际应用中，由于模块众多，依赖复杂，我们很难像上面的例子一样，规划出来每个模块的实例化时机，从而编写模块实例化顺序。并且，许多模块可能并不需要第一时间被创建，需要<strong>按需实例化</strong>，因此，粗暴的统一实例化是不可取的。</p>
<p>因此我们需要一个统一的框架来分析并管理所有模块的实例化过程，这就是依赖注入框架的作用。</p>
<p>借助于 TypeScript 的装饰器能力，VSCode 实现了一个极为轻量化的依赖注入框架。我们可以先来简单实现一下，解开这个巧妙设计的神秘面纱。</p>
<h2>最简依赖注入框架设计</h2>
<p>实现一个依赖注入框架只需要两步，一个是将模块声明并注册到框架中进行管理，另一个是在模块构造函数中，声明所需要依赖的模块有哪些。</p>
<p>我们先来看模块的注册过程，这需要 TypeScript 的类装饰器能力。我们在注入时，只需要判断模块是否已经注册，如果没有注册，将模块的 id(这里简化为模块 Class 名称)与类型传入即可完成单个模块的注册。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>Target<span class="token operator">:</span> Class<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collection<span class="token punctuation">.</span>providers<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>Target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      collection<span class="token punctuation">.</span>providers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Target<span class="token punctuation">.</span>name<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>之后我们再来看看模块是如何声明依赖的，这需要 TypeScript 的属性装饰器能力。我们在注入时，先判断依赖的模块是否已经被实例化，如果没有，则将依赖模块进行实例化，并存入框架中管理。最终返回已经被实例化完成的模块实例。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Inject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> Property<span class="token punctuation">,</span> propertyKey<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> instance <span class="token operator">=</span> collection<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> DependencyProvider<span class="token operator">:</span> Class <span class="token operator">=</span> collection<span class="token punctuation">.</span>providers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
      collection<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DependencyProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    target<span class="token punctuation">[</span>propertyKey<span class="token punctuation">]</span> <span class="token operator">=</span> collection<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后只需要保证框架本身在项目运行前完成实例化即可。(在例子中表示为 injector)</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ServiceCollection</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> providers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> dependencies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> collection<span class="token punctuation">;</span>
</code></pre></div><p>这样，一个最简化的依赖注入框架就完成了。由于保存了模块的类型与实例，它实现了模块的按需实例化，无需在项目启动时就初始化所有模块。</p>
<p>我们可以尝试调用它，以上面举出的例子为例：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>无需知晓模块 A，B 的实例化时机，直接初始化任何一个模块，框架会自动帮你找到并实例化好所有依赖的模块。</p>
<h2>VSCode 的依赖收集实现</h2>
<p>上面介绍了一个依赖注入框架的最简实现。但当我们真正阅读 VSCode 的源码时，我们发现 VSCode 中的依赖注入框架貌似并不是这样消费的。</p>
<p>例如在下面这段鉴权服务中，我们发现该类并没有<code>@injectable()</code>作为类的依赖收集，并且依赖服务也直接用其类名作为修饰器，而不是<code>@inject()</code>。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// src\vs\workbench\services\authentication\browser\authenticationService.ts</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthenticationService</span> <span class="token keyword">extends</span> <span class="token class-name">Disposable</span> <span class="token keyword">implements</span> <span class="token class-name">IAuthenticationService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IActivityService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> activityService<span class="token operator">:</span> IActivityService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IExtensionService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> extensionService<span class="token operator">:</span> IExtensionService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IStorageService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> storageService<span class="token operator">:</span> IStorageService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IRemoteAgentService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> remoteAgentService<span class="token operator">:</span> IRemoteAgentService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IDialogService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> dialogService<span class="token operator">:</span> IDialogService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IQuickInputService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> quickInputService<span class="token operator">:</span> IQuickInputService
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实这里的修饰符并不是真正指向类名，而是一个同名的资源描述符 id(VSCode 中称之为 <code>ServiceIdentifier</code>)，通常使用字符串或 Symbol 标识。</p>
<p>通过 <code>ServiceIdentifier</code> 作为 id，而不是简单粗暴地通过类名称作为 id 注册 Service，有利于处理项目中一个 interface 可能存在多态实现，需要同时多个同名类实例的问题。</p>
<p>此外，在构造 <code>ServiceIdentifier</code> 时，我们便可以将该类声明注入框架，而无需<code>@injectable()</code>显示调用了。</p>
<p>那么，这样一个 <code>ServiceIdentifier</code> 该如何构造呢？</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// src\vs\platform\instantiation\common\instantiation.ts</span>
<span class="token comment">/**
 * The *only* valid way to create a {{ServiceIdentifier}}.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">createDecorator</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>serviceId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ServiceIdentifier<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>_util<span class="token punctuation">.</span>serviceIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> _util<span class="token punctuation">.</span>serviceIds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'@IServiceName-decorator can only be used to decorate a parameter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">storeServiceDependency</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> target<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  id<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> serviceId<span class="token punctuation">;</span>

  _util<span class="token punctuation">.</span>serviceIds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 被 ServiceIdentifier 装饰的类在运行时，将收集该类的依赖，注入到框架中。</span>
<span class="token keyword">function</span> <span class="token function">storeServiceDependency</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> target<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_TARGET</span><span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_DEPENDENCIES</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> index <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_DEPENDENCIES</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> index <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_TARGET</span><span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们仅需通过<code>createDecorator</code>方法为类创建一个唯一的<code>ServiceIdentifier</code>，并将其作为修饰符即可。</p>
<p>以上面的 AuthenticationService 为例，若所依赖的 ActivityService 需要变更多态实现，仅需修改 <code>ServiceIdentifier</code> 修饰符确定实现方式即可，无需更改业务的调用代码。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> IActivityServicePlanA <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createDecorator</span><span class="token generic class-name"><span class="token operator">&lt;</span>IActivityService<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"IActivityServicePlanA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IActivityServicePlanB <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createDecorator</span><span class="token generic class-name"><span class="token operator">&lt;</span>IActivityService<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"IActivityServicePlanB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IActivityService</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthenticationService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IActivityServicePlanA</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> activityService<span class="token operator">:</span> IActivityService<span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>循环依赖问题</h2>
<p>模块之间的依赖关系是有可能存在循环依赖的，比如 A 依赖 B，B 依赖 A。这种情况下进行两个模块的实例化会造成死循环，因此我们需要在框架中加入循环依赖检测机制来进行规避。</p>
<p>本质上，一个健康的模块依赖关系就是一个有向无环图(DAG)，我们之前介绍过有向无环图在 excel 表格函数中的应用，放在依赖注入框架的设计中也同样适用。</p>
<p>我们可以通过深度优先搜索(DFS)来检测模块之间的依赖关系，如果发现存在循环依赖，则抛出异常。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// src/vs/platform/instantiation/common/instantiationService.ts</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> roots <span class="token operator">=</span> graph<span class="token punctuation">.</span><span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// if there is no more roots but still</span>
  <span class="token comment">// nodes in the graph we have a cycle</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>roots<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">throwCycleError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> root <span class="token keyword">of</span> roots<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// create instance and overwrite the service collections</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createInstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">.</span>desc<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_services<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">.</span>id<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该方法通过获取图节点的出度，将该类的全部依赖提取出来作为roots，然后逐个实例化，并从途中剥离该依赖节点。由于依赖树的构建是逐层依赖的，因此按顺序实例化即可。当发现该类的所有依赖都被实例化后，图中仍存在节点，则认为存在循环依赖，抛出异常。</p>
<h2>总结</h2>
<p>本篇文章简要介绍并实现了一个依赖注入框架，并解析了VSCode在实际问题上做出的一些改进。</p>
<p>实际上 VSCode 的依赖注入能力还有很多细节需要处理。例如异步实例化能力支持，通过封装 Deferred 类取得Promise执行状态，等等，在此就不一一展开了。感兴趣的同学可以参考 VSCode 源码：<a href="src/vs/platform/instantiation/common/instantiationService.ts">src/vs/platform/instantiation/common/instantiationService.ts</a>，做更进一步的学习。</p>
<h2>附录</h2>
<p>最简 DI 框架完整 demo：<a href="https://github.com/realDuang/dependencies-injector-demo" target="_blank" rel="noopener noreferrer">https://github.com/realDuang/dependencies-injector-demo</a></p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2022-11-15T12:23:56.000Z</published>
  </entry>
  <entry>
    <title type="text">VSCode For Web 深入浅出 -- 插件加载机制</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/4.extension-loading-mechanism.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/4.extension-loading-mechanism.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近我在浏览 VSCode for web 的 repo，在最近更新的一些 commit 中发现了一个新的 VSCode 插件特性支持，名为 <code>webOpener</code>，它的作用是什么呢？又是如何影响插件加载的呢？在这一篇中我们结合 VSCode For Web 的插件加载机制来详细分析一下。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近我在浏览 VSCode for web 的 repo，在最近更新的一些 commit 中发现了一个新的 VSCode 插件特性支持，名为 <code>webOpener</code>，它的作用是什么呢？又是如何影响插件加载的呢？在这一篇中我们结合 VSCode For Web 的插件加载机制来详细分析一下。</p>
</div><!-- more -->
<h2>VSCode for web 的插件加载机制</h2>
<p>我们知道，由于 VSCode for web 运行在浏览器上，因此，它的插件加载机制与 VSCode for desktop 有所不同。</p>
<p>在 VSCode for desktop 中，插件是以 vsix 包的形式存在的，因此，VSCode for desktop 可以直接通过 vsix 包的形式加载插件。而在 VSCode for web 中，由于浏览器的安全机制，不能直接加载 vsix 包。</p>
<p>因此，VSCode for web 采用了一种特殊的插件加载机制。发布 VSCode for web 插件时，发布系统会直接将项目编译，并发布到 CDN 节点上。当用户加载插件时，通过向该目标 url 发送请求，拉取远端(也可以是本地)的 <code>extension.js</code> 文件。并利用 web worker 加载机制，为每个插件分配独立线程加载与执行。</p>
<p>在生产环境中，对每个进入 VSCode 插件商店的插件，VSCode for web 会将支持 web 环境的插件的 <code>package.json</code> 与 <code>extension.js</code> 等文件打包成一个 zip 包，然后根据 publisher 分配合适的二级域名，通过 CDN 分发。</p>
<p>以我在使用的<code>One Dark Pro</code>主题为例：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230508145433.png" alt="20230508145433"></p>
<p>而在调试模式中，我们可以通过 <code>Install extension from location...</code>命令，指定编译后插件的 url，从而加载插件。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230508143115.png" alt="20230508143115"></p>
<p>我们使用本地服务器，指定一个已编译好的 VSCode web extension，并填入本地服务器地址 (<a href="https://localhost:5000" target="_blank" rel="noopener noreferrer">https://localhost:5000</a>)，并刷新页面，那么从 Chrome 的 Network 中可以看到 VSCode 向目标位置请求了<code>package.json</code> 与 <code>extension.js</code>，并看到插件已经被成功加载了。</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230508144906.png" alt="20230508144906"></p>
<p>通过这样的方式，VSCode for web 在每次页面打开后，完成了对用户自定义的插件管理与加载。并由于<code>web worker</code>的特性，每个插件的执行环境都是独立且相互隔离的。</p>
<h2>通过特殊 url 路由的方式的插件加载机制</h2>
<p>VSCode for web 最突出的特点是它是运行在浏览器上的，因此，我们可以利用 url，来实现一些奇妙的新特性。例如，通过特殊的 url 路由，免安装地加载插件。</p>
<p>目前，vscode.dev 可以使用这样的方式加载插件：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>https://vscode.dev/+publisher.name
</code></pre></div><p>例如，在浏览器中输入 <code>https://vscode.dev/+ms-vscode.onedrive-browser</code> 将加载 OneDrive 浏览器扩展。</p>
<p>当然，我们也可以使用同样的方式加载本地编译的插件。由于 vscode.dev 强制要求 <code>secure context</code> ，因此，我们需要在本地启动一个 <code>https</code> 的服务器，并对 url 进行 base64 编码，才能正常访问。</p>
<p>访问<code>https://vscode.dev/+aHR0cHM6Ly9sb2NhbGhvc3Q6MzAwMA==</code>即可。(后面那一段为"<a href="https://localhost:3000" target="_blank" rel="noopener noreferrer">https://localhost:3000</a>") 的 base64 编码)</p>
<h2>webOpener 特性介绍</h2>
<p>有开发过 VSCode for desktop 的插件的同学应该知道，vscode 插件的所有能力都是在 <code>package.json</code> 中声明的，这也是为什么 VSCode 除了需要加载入口的 <code>extension.js</code> 外，还一定要加载插件的 <code>package.json</code> 的原因。</p>
<p>在插件 <code>package.json</code> 的 <code>contributes</code> 字段中，我们可以声明插件的各种能力，例如，命令、菜单、快捷键、主题、语言、调试器等等。</p>
<p>对于 vscode for web 版本的插件来说，我们还可以声明 <code>webOpener</code> 能力，其所有属性都是可选的。声明如下：</p>
<div class="language-json" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"onedrive-browser"</span><span class="token punctuation">,</span>
  <span class="token property">"contributes"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"webOpener"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"scheme"</span><span class="token operator">:</span> <span class="token string">"onedrive"</span><span class="token punctuation">,</span>
      <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"webOpener.js"</span><span class="token punctuation">,</span>
      <span class="token property">"runCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"hello-world"</span><span class="token punctuation">,</span> <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"$url"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    ...
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>webOpener.scheme</h3>
<p>默认情况下，<code>vscode.dev/+publisher.name</code> 路由将直接打开默认的 VSCode 示例工作区。但是，如果提供了 scheme path，则 VSCode 将根据路由参数打开一个以该协议打开 url 中后续 path 指向的文件夹，格式如下：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 当 scheme 设置为 onedrive</span>
https://vscode.dev/+publisher.name/remoteAuthority/path/segments/<span class="token punctuation">..</span>.
</code></pre></div><p>例如，当插件 webOpener 的 scheme 设置为 onedrive 时，访问 <code>https://vscode.dev/+ms-vscode.onedrive-browser/myPersonalDrive/cool/folder</code> ，此时访问 url 将重定向为 <code>onedrive:///myPersonalDrive/cool/folder</code>。</p>
<p>若此协议不在 VSCode 的内置协议中，我们可以在插件中通过 <code>vscode.workspace.registerFileSystemProvider</code> 这个 API 注册自定义的 FileSystemProvider，从而实现对自定义协议的 FileSystem 支持。</p>
<p>本质上，它打开的方式与 VSCode for web 的 <code>vscode.open</code> 命令也是一致的。</p>
<h3>webOpener.runCommands</h3>
<p>当 VSCode 的主 workbench 加载完毕后，会触发 <code>webOpener</code> 的 <code>onDidCreateWorkbench</code> 的钩子，并执行此处声明的命令集。</p>
<p>这将传入一个命令数组，例如：<code>[{ "command": "test-extension.hello-world", "args": ["$url"] }]</code>，此时将可以执行自定义插件 <code>test-extension</code> 的相关命令。</p>
<p>其中，<code>$url</code> 指代当前页面 url。如果插件的初始化依赖来自 url 的 query/path 等等信息，这将很有用。</p>
<h3>webOpener.import</h3>
<p>这里定义了 webOpener 加载的入口点。它是一个相对于插件 package.json 的 ES Module 路径，例如：<code>webOpener.js</code>。</p>
<p>它与 <code>extension.js</code> 一样，默认导出一个 <code>doRoute</code> 函数，该函数将获取 route 与 workbench 等信息(workbench 这个实例中提供了当前 vscode for web 的命令、日志、环境、window、workspace 等多种能力支持)。由于 <code>webOpener.js</code> 运行在主线程中，因此它能做到的事情要比处于 web worker 下的 vscode for web 插件更多。</p>
<p>举一个例子，这是一个简单的 webOpener 贡献 onedrive-browser：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">doRoute</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// If we're not already opening a OneDrive, show the picker immediately</span>
  <span class="token comment">// when the user hits `vscode.dev/+ms-vscode.onedrive-browser`.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>route<span class="token punctuation">.</span>workspace<span class="token punctuation">.</span>folderUri<span class="token operator">?.</span>scheme <span class="token operator">!==</span> <span class="token string">'onedrive'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    route<span class="token punctuation">.</span>onDidCreateWorkbench<span class="token punctuation">.</span>runCommands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      command<span class="token operator">:</span> <span class="token string">'onedrive-browser.openOneDrive'</span><span class="token punctuation">,</span>
      args<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它将在 workbench 加载完毕后，判断当前的 workspace 是否为 onedrive，如果不是，则执行 <code>onedrive-browser.openOneDrive</code> 命令，从而打开 onedrive 文件夹。</p>
<h2>webOpener 与插件的通信机制</h2>
<p>在了解了 webOpener 的基本特性之后，我们来看看该如何利用这些特性，与我们的 web 插件进行通信，从而扩展插件能力。</p>
<p>我们可以看出，由于 webOpener 加载在主线程，且 doRoute 方法的执行时机在主线程 workbench 加载完毕之后，在请求远端插件并执行之前。因此，我们可以有两种方式来传递信息，与处于 web worker 下，与宿主隔离的插件进行通信。</p>
<p>第一种即为在 runCommands 中介绍的，通过执行 command 并传递 url 的方式传递初始化信息。该方式也是 webOpener 与插件通信的常用方式之一，用于为初始化插件时提供部分依赖参数。</p>
<p>第二种则是通过 doRoute 方法，捕获此时的请求信息，并根据请求信息的不同对插件能力进行不同的变更，但本质上还是通过 command 的方式给插件发送 args 来实现的。</p>
<p>我在当前最新版本的 vscode-dev 代码库中(1.79.0)，并未发现直接通过 webOpener 暴露类似 postMessage 的与插件通信的方法，因此到目前为止，我们只能通过给插件的 command 方式触发 trigger 与传入参数这一种方式来实现与插件的通信。这导致了在 web 下插件的能力其实相当受限。</p>
<h2>总结</h2>
<p>本篇文章解析了在 VSCode for web 中的插件加载机制，以及如何通过 webOpener 特性来扩展插件的能力。</p>
<p>我们可以看出，在现阶段的 VSCode for web 中，插件的加载机制也仅仅只是做到了可用状态。由于 web worker 天然的与主线程隔离的特性，desktop 的很多好用的功能性插件(即除了 theme/key-binding 这种不需要执行逻辑的插件之外)在 web 端的支持还是会遇到很多问题，并不能无缝迁移。这点也是我在尝试开发 VSCode for web 插件时最大的痛点。</p>
<p>不过，随着 VSCode for web 项目仍在进行高频的开发与完善，希望未来的 VSCode for web 能在插件开发与使用上尽可能对齐甚至兼容 desktop 的体验。</p>
<h2>参考资料</h2>
<ul>
<li><a href="https://github.com/microsoft/vscode-dev" target="_blank" rel="noopener noreferrer">VSCode dev Repository</a> (目前是私有仓库，需要向 Microsoft 申请权限，未来功能完善后或将开放)</li>
<li><a href="https://code.visualstudio.com/docs/editor/vscode-web" target="_blank" rel="noopener noreferrer">VSCode for the Web Introduction</a></li>
</ul>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2023-05-08T18:54:33.000Z</published>
  </entry>
  <entry>
    <title type="text">浅析依赖注入框架的生命周期(以 InversifyJS 为例)</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/di-framework-life-cycle.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/di-framework-life-cycle.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在上一篇介绍了 VSCode 的依赖注入设计，并且实现了一个简单的 IOC 框架。但是距离成为一个生产环境可用的框架还差的很远。</p>
<p>行业内已经有许多非常优秀的开源 IOC 框架，它们划分了更为清晰地模块来应对复杂情况下依赖注入运行的正确性。</p>
<p>这里我将以 InversifyJS 为例，分析它的生命周期设计，来弄清楚在一个优秀的 IOC 框架中，完成一次注入流程到底是什么样的。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在上一篇介绍了 VSCode 的依赖注入设计，并且实现了一个简单的 IOC 框架。但是距离成为一个生产环境可用的框架还差的很远。</p>
<p>行业内已经有许多非常优秀的开源 IOC 框架，它们划分了更为清晰地模块来应对复杂情况下依赖注入运行的正确性。</p>
<p>这里我将以 InversifyJS 为例，分析它的生命周期设计，来弄清楚在一个优秀的 IOC 框架中，完成一次注入流程到底是什么样的。</p>
</div><!-- more -->
<h2>InversifyJS 的生命周期</h2>
<p>在激活 InversifyJS 后，框架通常会监听并经历五个阶段，分别是：</p>
<ol>
<li>Annotation 注释阶段</li>
<li>Planning 规划阶段</li>
<li>Middleware (optional) 中间件钩子</li>
<li>Resolution 解析执行阶段</li>
<li>Activation (optional) 激活钩子</li>
</ol>
<p>本篇文章将着重介绍其中的<strong>三个必选阶段</strong>。旨在解释框架到底是如何规划模块实例化的先后顺序，以实现依赖注入能力的。</p>
<p>接下来的解析将围绕如下例子：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token keyword">implements</span> <span class="token class-name">FooBarInterface</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> foo<span class="token operator">:</span> FooInterface<span class="token punctuation">;</span>
  <span class="token keyword">public</span> bar<span class="token operator">:</span> BarInterface<span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token string">"FooInterface"</span><span class="token punctuation">)</span> foo<span class="token operator">:</span> FooInterface<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token string">"BarInterface"</span><span class="token punctuation">)</span> bar<span class="token operator">:</span> BarInterface
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> foo<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> bar<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> container <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Container</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> foobar <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>FooBarInterface<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"FooBarInterface"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>Annotation 注释阶段</h2>
<p>在此阶段中，框架将通过装饰器为所有接入框架的对象打上标记，以便规划阶段时进行管理。</p>
<p>在这个阶段中，最重要的 API 就是 <code>injectable</code> 。它使用 Reflect metadata，对 Class 构造函数中通过 <code>inject</code> API 注入的 property 进行标注，并挂在在了该类的 <code>metadataKey</code> 上。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">hasOwnMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">PARAM_TYPES</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token constant">ERRORS_MSGS</span><span class="token punctuation">.</span><span class="token constant">DUPLICATED_INJECTABLE_DECORATOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> types <span class="token operator">=</span>
      Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">DESIGN_PARAM_TYPES</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">PARAM_TYPES</span><span class="token punctuation">,</span> types<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>Planning 规划阶段</h2>
<p>本阶段时该框架的核心阶段，它真正生成了在一个 Container 中，所有类模块的依赖关系树。因此，在 Container 类进行实例化时，规划阶段就开始了。</p>
<p>在实例化时，根据传入的 id 与 scope 可以确定该实例容器的作用域范围，生成一个 context，拥有对内左右模块的管理权。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token keyword">implements</span> <span class="token class-name">interfaces</span><span class="token punctuation">.</span>Context <span class="token punctuation">{</span>
  <span class="token keyword">public</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> container<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Container<span class="token punctuation">;</span>
  <span class="token keyword">public</span> plan<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Plan<span class="token punctuation">;</span>
  <span class="token keyword">public</span> currentRequest<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Request<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span>container<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// generate a unique id</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>container <span class="token operator">=</span> container<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">addPlan</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Plan<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>plan <span class="token operator">=</span> plan<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">setCurrentRequest</span><span class="token punctuation">(</span>currentRequest<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>currentRequest <span class="token operator">=</span> currentRequest<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以注意到，这个 context 中包含一个空的 plan 对象，这是 planning 阶段的核心，该阶段就是为生成的容器规划好要执行的任务。</p>
<p>plan 对象中将包含一个 request 对象，request 是一个可递归的属性结构，它包含了要查找的 id 外，还需要 target 参数，即规定找到依赖实例后将引用赋值给哪个参数。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Request</span> <span class="token keyword">implements</span> <span class="token class-name">interfaces</span><span class="token punctuation">.</span>Request <span class="token punctuation">{</span>
    <span class="token keyword">public</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> serviceIdentifier<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>ServiceIdentifier<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 被修饰类 id</span>
    <span class="token keyword">public</span> parentContext<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Context<span class="token punctuation">;</span>
    <span class="token keyword">public</span> parentRequest<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Request <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 树形结构的 request，指向父节点</span>
    <span class="token keyword">public</span> bindings<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Binding<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> childRequests<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Request<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 树形结构的 request，指向子节点</span>
    <span class="token keyword">public</span> target<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Target<span class="token punctuation">;</span> <span class="token comment">// 指向赋值目标参数</span>
    <span class="token keyword">public</span> requestScope<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>RequestScope<span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以篇头的例子为例。在容器执行 get 函数后，框架生成了一个新的 plan，该 plan 的生成过程中将执行_createSubRequests 方法，从上而下创建 Request 依赖树。</p>
<p>创建完成后的 plan 对象生成的 request 树将包含有请求目标为 null 的根 request 与两个子 request：</p>
<p>第一个子 request 指向 FooInterface 接口，并且请求结果的 target 赋值给构造函数中的参数 foo。第二个子 request 指向 BarInterface 接口，并且请求结果的 target 赋值给构造函数中的参数 bar。</p>
<p>注意，此处的依赖树生成仍在 interface 层面，没有任何类被实例化。</p>
<p>用一张图来更直观地表现该阶段中各对象的生成调用过程：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230209165944.png" alt="20230209165944"></p>
<p>这样，每一个类与其依赖项之间的请求关系就构造完毕了。</p>
<h2>Resolution 解析执行阶段</h2>
<p>该阶段便是执行在规划阶段中生成的 request 依赖树，从无依赖的叶子节点开始，自下而上实例化每一个依赖类，到根 request 结束时，即最终完成 <code>FooBar</code> 自身的实例化。</p>
<p>且该解析过程可以选择同步或异步执行，在复杂情况下，使用异步懒加载的方式执行解析，有助于提高性能。</p>
<p>至此，一次完整的具有依赖的类的实例化就完成了。我们可以通过打印依赖树，清晰地观察到该实例依赖了哪些实例，从而避免了一切可能的循环依赖，与多次构造依赖带来的内存泄露等很多难以排查的问题。</p>
<h2>参考资料</h2>
<p><a href="https://github.com/inversify/InversifyJS/blob/master/wiki/architecture.md" target="_blank" rel="noopener noreferrer">InversifyJS Architecture Overview</a></p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2023-02-09T17:39:42.000Z</published>
  </entry>
  <entry>
    <title type="text">在 VSCode 中实现 Jupyter Debug Adapter</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/implementing-jupyter-debug-adapter-in-vscode.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/implementing-jupyter-debug-adapter-in-vscode.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>说起 VSCode 中广受好评的功能，必须算上其优秀的调试（debug）功能，它拥有丰富的功能和直观的用户界面。</p>
<p>更为难得的是，VSCode 为这套调试架构实现的插件化机制，使得我们可以很方便地为不同的自定义语言和框架实现调试功能，并具有统一且通用的用户界面。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>说起 VSCode 中广受好评的功能，必须算上其优秀的调试（debug）功能，它拥有丰富的功能和直观的用户界面。</p>
<p>更为难得的是，VSCode 为这套调试架构实现的插件化机制，使得我们可以很方便地为不同的自定义语言和框架实现调试功能，并具有统一且通用的用户界面。</p>
</div><p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240625155834.png" alt="20240625155834"></p>
<p>本文将以 Jupyter 接入 VSCode 调试的功能为例，介绍如何在 VSCode 中实现 Jupyter Debug Adapter。</p>
<h2>在 VSCode 中注册 Debug Adapter Protocol</h2>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240624142142.png" alt="(https://code.visualstudio.com/api/extension-guides/debugger-extension)"></p>
<p>从 VSCode 的相关介绍中我们可以看到，VSCode 的 Debug Adapter 是一个独立的进程，它负责处理 IDE 和调试器之间的通信。而调试功能正是通过 Debug Adapter Protocol（DAP）来实现的，它是一个标准的调试协议，用于在 IDE 和调试器之间进行通信。</p>
<p>而为了给 VSCode 挂载自定义的调试器，我们可以通过 <code>registerDebugAdapterDescriptorFactory</code> 这个 API 来注册我们的 Debug Adapter。由于 Jupyter 是基于 Python 语言的，因此这里的 debugType 选择 python。</p>
<p>之后我们就启动 debugpy 后在 vscode 中设置好 <code>launch.json</code> 入口，调试普通 python 代码了。</p>
<blockquote>
<p>如果你想了解更多关于 Debug Adapter 的内容，可以参考 <a href="https://code.visualstudio.com/api/extension-guides/debugger-extension" target="_blank" rel="noopener noreferrer">VSCode 官方文档</a>。</p>
</blockquote>
<p>在 DAP 中，要实现一套完成的 debugger 流程，要求我们需要实现一些基本的功能，如：</p>
<ol>
<li><code>initialize</code>：初始化调试器。</li>
<li><code>setBreakpoints</code>：设置断点。</li>
<li><code>variables</code>/<code>stackTrace</code>/<code>threads</code>：获取相关变量、调用栈等信息。</li>
<li><code>stepInto</code>/<code>stepOut</code>/<code>stepOver</code>：单步调试。</li>
<li><code>break statement</code>：中断调试。</li>
</ol>
<p>接下来我们就以 Jupyter 为例，看看如果要实现其他语言的 debug 接入，应该做哪些工作。</p>
<h2>实现 Jupyter Debug Protocol</h2>
<p>通过翻阅 <a href="https://jupyter-client.readthedocs.io/en/latest/messaging.html#debug-request" target="_blank" rel="noopener noreferrer">Jupyter 文档</a>，我们可以知道，若要实现调试功能，其连接的 kernel 里必须要支持 Jupyter Debug Protocol，这也是我们主要需要实现的地方。</p>
<p>我们可以通过以下的流程图来了解 debug 从发起到结束的全过程：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240625145827.png" alt="20240625145827"></p>
<ol>
<li>
<p><code>Initialize</code> 阶段。IDE 会向 kernel 发送 <code>initialize_request</code>，这个 request 将会帮我们创建一个新的 channel 用来交换调试信息。</p>
</li>
<li>
<p><code>Attach</code> 阶段。该请求将会帮我们将建立好的 debug adaptor channel 与当前的 IDE 进行绑定，将在这里负责 debug 交互的全过程。</p>
</li>
<li>
<p><code>Configuring breakpoints and exception behavior</code> 阶段。这一部分是将 IDE 中设置的断点等相关信息传递给 kernel，以便 kernel 能够在适当的时候中断。</p>
<p>其中，setBreakpoints 等将会传递设置断点的行/函数/异常处理等信息，dumpCell 是将单元格内的内容或状态信息传递给 kernel。</p>
<p>值得注意的是，这里所有的请求 msg_type 将以 <code>debug_event</code> 或者 <code>status</code> 发出而不再是 <code>request</code>。</p>
<p>随着 configureationDone 的出现，标志着客户端配置过程的结束。</p>
</li>
<li>
<p><code>Execute request</code> 阶段。这一步与正常的代码执行完全一致，发出代码执行请求，最终收获到执行结果。</p>
<p>但此时，如果我们设置了 breakpoint，该过程将在执行到断点处时被一个内容为 <code>stopped</code> 的 <code>debug_event</code> 给暂时 block。</p>
</li>
<li>
<p><code>Pausing and extract context</code> 阶段。</p>
<p>当 kernel 收到 <code>stopped</code> 的<code>debug_event</code> 后，将会暂停当前的执行，此时会发送一系列<code>channel type</code> 为 <code>control</code> 的 <code>command</code>，将当前的各种相关 context 传递给 IDE。</p>
<p>其中 <code>variables</code> 是获取当前 code 中的变量信息，包括其名称类型等。<code>stackTrace</code> 帮助 IDE 获取当前的调用栈信息。<code>scopes</code> 则是获取函数或变量的作用域信息。<code>threads</code> 则是获取当前处理 debug 功能所处的线程信息。</p>
</li>
<li>
<p><code>Dispose</code> 阶段。当所有断点都被跳过后，之前的 <code>execute_request</code> 将被执行完成返回 <code>execute_reply</code>。至此 debug 流程结束。此时我们需要让 IDE 发送 <code>disconnect request</code> 来关闭当前的 debug adaptor channel。如果我们想正确执行完整的 debug 生命周期。无论是否异常结束，都需要执行 <code>disconnect request</code>。</p>
</li>
</ol>
<p>了解了 Jupyter Debug Protocol 的全流程后，我们就可以开始着手为 VSCode 的交互实现做准备了。</p>
<h2>利用 Jupyterlab 库为沟通 kernel 提供 API 支持</h2>
<p>上面我们简要介绍了一下 Jupyter 调试过程的原理，而事实上我们并不需要完全从零开始实现 Jupyter Debug Protocol，因为开源社区里已经有了很多现成的库可以帮助我们实现这一功能。</p>
<p>Jupyterlab 是一个为 Jupyter 打造的第一方开发环境工具库，它提供了丰富的 API 支持，可以帮助我们更方便地与 kernel 进行交互。</p>
<p>在 Jupyterlab 中，我们可以通过 <code>jupyterlab/debugger</code> 这个插件来实现对 Jupyter Debug Protocol 的支持。它提供了一套完整的调试功能，包括设置断点、单步调试、查看变量等。</p>
<p>因此，我们真正需要实现的触发事件与交互逻辑也就变得更为清晰了。只需要处理好 debugging 的这几个实现即可：</p>
<ol>
<li>debugging 的开始与终止事件</li>
<li>断点的设置与清除</li>
<li>代码执行</li>
<li>变量、调用栈等的查看</li>
<li>单步调试（包括<code>stepInto</code>/<code>stepOut</code>/<code>stepOver</code>）</li>
</ol>
<p>因此，我们可以得出基于 jupyterlab 的调试器实现的基本流程：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240625161141.png" alt="20240625161141"></p>
<h2>实现 Debugging Manager 完成对调试器的管理</h2>
<p>到了最终代码实现的阶段了。我们需要实现一个 Debugging Manager，用于通过<code>registerDebugAdapterDescriptorFactory</code> 注册给 VSCode，管理调试器的启动、停止、断点设置等操作。</p>
<p>具体的工程实现方案可以有很多，具体就不展开了，这里只 po 一下 <a href="https://github.com/microsoft/vscode-jupyter" target="_blank" rel="noopener noreferrer">vscode-jupyter</a> 的实现方案：</p>
<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20240625160558.png" alt="20240625160558"></p>
<p>vscode-jupyter 通过额外增加了 <code>KernelDebugAdapter</code> 类实现了 <code>debug_event</code> 消息的收发，通过 <code>DebugCellController</code> 类来管理单元格的 debug 执行信息，实现了不同消息走不同 Controller 的分离。</p>
<h2>总结</h2>
<p>通过本文的介绍，我们可以了解 VSCode 的 Debug Adapter 的实现原理，并以 Jupyter 为例，成功在 VSCode 中实现 Jupyter Debug Adapter，并实现完全的调试能力。</p>
<p>得益于 VSCode 灵活的调试注入能力，我们可以方便地为更多的语言，甚至是一些自定义框架实现调试能力，这可能可以为更多的小众语言或框架的开发者带来工作效率上的帮助。</p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2024-06-25T17:10:22.000Z</published>
  </entry>
  <entry>
    <title type="text">使用依赖注入框架管理多实例服务（以 InversifyJS 为例）</title>
    <id>https://blog.realduang.com/blogs/vscode-for-web/multi-instance-service-management-in-di-framework.html</id>
    <link href="https://blog.realduang.com/blogs/vscode-for-web/multi-instance-service-management-in-di-framework.html"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在大型项目的管理中，控制反转的思想是非常重要的。它可以帮助我们解耦代码，提高代码的可维护性。同时避免了不必要的重复实例化，降低内存泄漏的可能性。</p>
<p>而在 JS/TS 技术栈中，我们通常会使用依赖注入框架来帮助我们管理服务。这其中最佳的选择当然是 Angular 这种大而全的大型工程开发框架。而对于使用了其他 UI 框架的项目来说，我们同样可以额外引入一个轻量化的依赖注入框架。而 InversifyJS 就是其中的佼佼者。我们可以通过使用它，来见微知著地了解依赖注入的原理与设计哲学。</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在大型项目的管理中，控制反转的思想是非常重要的。它可以帮助我们解耦代码，提高代码的可维护性。同时避免了不必要的重复实例化，降低内存泄漏的可能性。</p>
<p>而在 JS/TS 技术栈中，我们通常会使用依赖注入框架来帮助我们管理服务。这其中最佳的选择当然是 Angular 这种大而全的大型工程开发框架。而对于使用了其他 UI 框架的项目来说，我们同样可以额外引入一个轻量化的依赖注入框架。而 InversifyJS 就是其中的佼佼者。我们可以通过使用它，来见微知著地了解依赖注入的原理与设计哲学。</p>
</div><p>但最近在使用 Inversify 进行项目重构时，遇到了一个问题：众所周知依赖注入框架天生适合管理单例服务。它的设计哲学是 <code>Everything as Service</code>。但是在某些场景下，单例模式并不能解决一切问题，我们同样需要进行多实例的管理。那么我们该如何解决这个问题呢？</p>
<p>这并不是 Inversify 框架的问题，而其实是一个依赖注入框架下常见的设计疑惑，但是网上对此的解析资料却很少。</p>
<p>我看了很多使用了 InversifyJS 的项目，他们对此的方式就是直接在需要处实例化，不将其注册到容器中。这实际上是没有真正理解到依赖注入框架的内核。这样做的好处是简单，但是有很多弊端。由于我们无法在容器中统一管理这些实例，那么这些服务的生命周期将不受控制，在 dispose 时无法在容器中统一销毁这些实例。与不引入依赖注入框架一样，这样同样会带来内存泄漏的可能性。</p>
<p>那么该如何正确地处理这种情况呢？</p>
<h2>构造器注入</h2>
<p>一个最简便的改造方式是，我们将类的构造函数绑定到容器中。需要的时候从容器中获取类的构造器，再进行实例化。这样我们就可以在容器中统一管理这些实例了。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 将 InstanceClass 的构造函数绑定到容器中</span>
container
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">bind</span><span class="token generic class-name"><span class="token operator">&lt;</span>interfaces<span class="token punctuation">.</span>Newable<span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Newable&lt;InstanceClass&gt;"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toConstructor</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>InstanceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 获取构造器</span>
<span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token string">"Newable&lt;InstanceClass&gt;"</span><span class="token punctuation">)</span> InstanceClass<span class="token operator">:</span> Newable<span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InstanceClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InstanceClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实例会跟随类的生命周期而存在，且该类能纳入容器中进行管理。但是这样做，实际上仍然无法在容器中统一管理这些实例的生命周期。如果我们需要在 dispose 时销毁这些实例，那么我们需要在类中手动实现 dispose 方法，并在 dispose 时手动销毁这些实例。</p>
<p>这样改造的好处是简单，但是很多时候并不是一个最优解，因为我们希望该实例本身能在注入框架的管理下，避免我们去手动的控制与销毁。</p>
<h2>工厂注入</h2>
<p>依赖注入框架天生不太好管理多实例的服务，但是如果利用工厂模式的设计思想，将这些服务的实例化过程封装到工厂中，而这样的工厂类一定是单例的。那么我们就可以通过管理工厂类来管理这些多实例服务的生命周期了。</p>
<p>在需要多实例服务实例化时，我们不直接 import 类进行实例化，而是通过 import 工厂类来获取实例。这样我们就可以在工厂中控制多实例服务的生命周期了。</p>
<p>在 InversifyJS 中，提供了工厂注入的方法：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 设置工厂函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> context<span class="token punctuation">.</span>container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Instance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 工厂创建器，这里设置高阶函数的目的是将 context 传递给工厂函数，方便获取容器</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactoryCreator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>context<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> instanceFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 绑定工厂</span>
container
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">bind</span><span class="token generic class-name"><span class="token operator">&lt;</span>interfaces<span class="token punctuation">.</span>Factory<span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Factory&lt;InstanceClass&gt;"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toFactory</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>instanceFactoryCreator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 获取构造器</span>
<span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token string">"Factory&lt;InstanceClass&gt;"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token function-variable function">instanceFactory</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> InstanceClass<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">instanceFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">instanceFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的实现非常优雅，也是 Inversify 推荐的多实例管理方式。</p>
<p>当然，你也可以通过高阶函数的方式，生成不同的的工厂函数，以实现不同的实例化逻辑。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 设置工厂函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">"Instance"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> context<span class="token punctuation">.</span>container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Instance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> context<span class="token punctuation">.</span>container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>DefaultClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 工厂创建器，这里设置高阶函数的目的是将 context 传递给工厂函数，方便获取容器</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactoryCreator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>context<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> instanceFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 绑定工厂</span>
container
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">bind</span><span class="token generic class-name"><span class="token operator">&lt;</span>interfaces<span class="token punctuation">.</span>Factory<span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Factory&lt;InstanceClass&gt;"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toFactory</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>instanceFactoryCreator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在大多数情况下，它就是最标准的依赖注入框架下多实例管理方式了，也推荐能使用此方式的类尽量如此改造。</p>
<h2>带参数实例化的工厂注入</h2>
<p>现在重点来了，依赖注入框架完美解决了在类实例化时需要传入的依赖实例，避免了我们需要在类的构造函数中获取或新建依赖实例。那么，对于那些依赖于传入外部上下文变量的类，我们该如何处理呢？</p>
<p>这是我们将已有的项目重构的过程中，经常会遇到的一种情况，这些类的构造函数执行过程依赖于外部上下文变量。</p>
<p>InversifyJS 的工厂注入在这中情形下的推荐实现方式比较奇怪，是在获取实例后为实例进行属性注入。我大致转写一下主要实现：</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 设置工厂函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span>payload<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> context<span class="token punctuation">.</span>container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Instance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span>payload <span class="token operator">=</span> payload<span class="token punctuation">;</span>
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 工厂创建器，这里设置高阶函数的目的是将 context 传递给工厂函数，方便获取容器</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactoryCreator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>context<span class="token operator">:</span> interfaces<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> instanceFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 绑定工厂</span>
container
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">bind</span><span class="token generic class-name"><span class="token operator">&lt;</span>interfaces<span class="token punctuation">.</span>Factory<span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Factory&lt;InstanceClass&gt;"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toFactory</span><span class="token generic class-name"><span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>instanceFactoryCreator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在实例化后的运行时改变实例的属性，从而使实例中对属性的依赖得以满足。但这样的实现方式，会使得我们原有类的实现方式发生改变，也会改变类中属性的访问方式，例如原来时 readonly 或是 private 的属性，我们都无法在运行时对其进行赋值。</p>
<p>当这个类继承于外部需要传入参数的类，或者是需要在首次实例化时根据传入的变量依赖执行部分操作时，这种实例化的方式是行不通的。</p>
<p>那么如果我们的改造类具有以上特性，在不改变原有实现方式的情况下，应当如何做呢？</p>
<p>我们可以注意到，通过构造器注入的方式并不会将实例化时的行为交给容器，因此我们可以在这里进行手动的实例化并传入参数。那这样的实例化方式同样可以与工厂模式相结合，实现带参数实例化的工厂注入。</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// 设置工厂函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">instanceFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span>payload<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> InstanceClass <span class="token operator">=</span> context<span class="token punctuation">.</span>container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>Newable<span class="token operator">&lt;</span>InstanceClass<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span>
    <span class="token string">"Newable&lt;InstanceClass&gt;"</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InstanceClass</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，这里的 <code>new InstanceClass</code> 并不是引用原有类，而是引用了类的构造函数，而构造函数处于框架的管辖下，因此某种程度上该实例也是由框架进行了实例化得来的。因此，原有类甚至都不需要通过 <code>@injectable</code> 标注与注册。只需注册其构造器即可。</p>
<p>但始终，对于带参数实例化的工厂注入，它的实现方式并不优雅，也不符合依赖注入的思想。因此，本质上来说，类似于<code>类继承</code>的方式并不是一个好的<code>code smell</code>，我们推荐使用<code>对象组合</code>来代替<code>类继承</code>，从而规避掉需要在构造函数中为 super() 传入变量的尴尬局面。</p>
<h2>结语</h2>
<p>以上就是我在使用依赖注入框架重构项目时，对于多实例服务管理的一些思考与实践。它成功地帮我完成了整个项目的重构，也让我对于依赖注入框架有了更深的理解。</p>
<p>但于此同时，我也在实践中发现了许多依赖注入框架的局限性。但这并不说明依赖注入框架不够完善，而是说明了依赖注入作为一种设计模式与思想，它有其匹配的设计哲学。例如在上述的例子中，真正按照框架的最佳实践来说，我们应当只为服务注入行为抽象，而不是某些具体的变量数据，这对代码可测性来说非常重要。</p>
<p>因此，我更推荐在使用依赖注入框架前，先学习依赖注入的设计思想，再去使用框架。而不是尝试魔改某个依赖注入框架来迎合固有的编码风格。这不一定对设计与性能有正向的收益。</p>
]]></content>
    <category term="VSCode For Web 深入浅出"/>
    <published>2023-06-27T15:05:11.000Z</published>
  </entry>
  <entry>
    <title type="text">关于我</title>
    <id>https://blog.realduang.com/docs/about/</id>
    <link href="https://blog.realduang.com/docs/about/"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>你好我是 <code>Duang</code>，一名涉猎广泛的 Web 工程师。</p>
<p>毕业于 中南大学 计算机专业。</p>
<p>现就职于微软 <code>C + AI</code> 团队，主研 <code>VS Code for Web</code> 在大数据使用场景下的落地。</p>
<p>前腾讯 <code>Alloy Team</code> 前端工程师，负责腾讯文档的基建及开发工作，对大前端基建、云原生自动化管理有一定的研究。</p>
<p>微信号：<code>realDuang</code></p>
</blockquote>
<p>嘻嘻，欢迎找我做朋友呀！</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>你好我是 <code>Duang</code>，一名涉猎广泛的 Web 工程师。</p>
<p>毕业于 中南大学 计算机专业。</p>
<p>现就职于微软 <code>C + AI</code> 团队，主研 <code>VS Code for Web</code> 在大数据使用场景下的落地。</p>
<p>前腾讯 <code>Alloy Team</code> 前端工程师，负责腾讯文档的基建及开发工作，对大前端基建、云原生自动化管理有一定的研究。</p>
<p>微信号：<code>realDuang</code></p>
</blockquote>
<p>嘻嘻，欢迎找我做朋友呀！</p>
]]></content>
    <published>2023-05-18T16:44:20.000Z</published>
  </entry>
  <entry>
    <title type="text">留言板</title>
    <id>https://blog.realduang.com/docs/message-board/</id>
    <link href="https://blog.realduang.com/docs/message-board/"/>
    <updated>2024-12-02T12:16:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">INFO</p><p>这里是一个好看的留言板，欢迎大家在此留下任何问题或者建议！一起进步！</p>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">INFO</p><p>这里是一个好看的留言板，欢迎大家在此留下任何问题或者建议！一起进步！</p>
</div>]]></content>
    <published>2022-05-21T17:23:22.000Z</published>
  </entry>
</feed>