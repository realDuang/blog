import{_ as t,r as e,o as p,c as o,a as n,d as s,e as c,b as i}from"./app-BU-w-E0g.js";const l={},u=i(`<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>在阅读 VSCode 代码的过程中，我们会发现每一个模块中都有大量装饰器的使用，用来装饰模块以及其中依赖的模块变量。这样做的目的是什么呢？在这一篇中我们来详细分析一下。</p></div><h2 id="依赖注入介绍" tabindex="-1"><a class="header-anchor" href="#依赖注入介绍"><span>依赖注入介绍</span></a></h2><p>如果有这样一个模块 A，它的实现依赖另一个模块 B 的能力，那么应该如何设计呢？很简单，我们可以在 A 模块的构造函数中实例化模块 B，这样就可以在模块 A 内部使用模块 B 的能力了。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样做有两个问题，一是模块 A 的实例化过程中，需要手动实例化模块 B，而且如果模块 B 的依赖关系发生变化，那么也需要修改模块 A 的构造函数，导致代码耦合。</p><p>二是在复杂项目中，我们在实例化模块 A 时，难以判断模块 B 是否被其他模块依赖而已经实例化过了，从而可能将模块 B 多次实例化。若模块 B 较重或者需要为单例设计，这将带来性能问题。</p><p>因此，更好的方式是，将所有模块的实例化交给外层框架，由框架统一管理模块的实例化过程，这样就可以解决上述两个问题。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种将依赖对象通过外部注入，避免在模块内部实例化依赖的方式，称为依赖注入 (Dependencies Inject, 简称 DI)。这在软件工程中是一种常见的设计模式，我们在 Java 的 Spring，JS 的 Angular，Node 的 NestJS 等框架中都可以看到这种设计模式的应用。</p><p>当然，在实际应用中，由于模块众多，依赖复杂，我们很难像上面的例子一样，规划出来每个模块的实例化时机，从而编写模块实例化顺序。并且，许多模块可能并不需要第一时间被创建，需要<strong>按需实例化</strong>，因此，粗暴的统一实例化是不可取的。</p><p>因此我们需要一个统一的框架来分析并管理所有模块的实例化过程，这就是依赖注入框架的作用。</p><p>借助于 TypeScript 的装饰器能力，VSCode 实现了一个极为轻量化的依赖注入框架。我们可以先来简单实现一下，解开这个巧妙设计的神秘面纱。</p><h2 id="最简依赖注入框架设计" tabindex="-1"><a class="header-anchor" href="#最简依赖注入框架设计"><span>最简依赖注入框架设计</span></a></h2><p>实现一个依赖注入框架只需要两步，一个是将模块声明并注册到框架中进行管理，另一个是在模块构造函数中，声明所需要依赖的模块有哪些。</p><p>我们先来看模块的注册过程，这需要 TypeScript 的类装饰器能力。我们在注入时，只需要判断模块是否已经注册，如果没有注册，将模块的 id(这里简化为模块 Class 名称)与类型传入即可完成单个模块的注册。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>Target<span class="token operator">:</span> Class<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collection<span class="token punctuation">.</span>providers<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>Target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      collection<span class="token punctuation">.</span>providers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Target<span class="token punctuation">.</span>name<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后我们再来看看模块是如何声明依赖的，这需要 TypeScript 的属性装饰器能力。我们在注入时，先判断依赖的模块是否已经被实例化，如果没有，则将依赖模块进行实例化，并存入框架中管理。最终返回已经被实例化完成的模块实例。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Inject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> Property<span class="token punctuation">,</span> propertyKey<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> instance <span class="token operator">=</span> collection<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> DependencyProvider<span class="token operator">:</span> Class <span class="token operator">=</span> collection<span class="token punctuation">.</span>providers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
      collection<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DependencyProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    target<span class="token punctuation">[</span>propertyKey<span class="token punctuation">]</span> <span class="token operator">=</span> collection<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后只需要保证框架本身在项目运行前完成实例化即可。(在例子中表示为 injector)</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ServiceCollection</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> providers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> dependencies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> collection<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，一个最简化的依赖注入框架就完成了。由于保存了模块的类型与实例，它实现了模块的按需实例化，无需在项目启动时就初始化所有模块。</p><p>我们可以尝试调用它，以上面举出的例子为例：</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token decorator"><span class="token at operator">@</span><span class="token function">inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无需知晓模块 A，B 的实例化时机，直接初始化任何一个模块，框架会自动帮你找到并实例化好所有依赖的模块。</p><h2 id="vscode-的依赖收集实现" tabindex="-1"><a class="header-anchor" href="#vscode-的依赖收集实现"><span>VSCode 的依赖收集实现</span></a></h2><p>上面介绍了一个依赖注入框架的最简实现。但当我们真正阅读 VSCode 的源码时，我们发现 VSCode 中的依赖注入框架貌似并不是这样消费的。</p><p>例如在下面这段鉴权服务中，我们发现该类并没有<code>@injectable()</code>作为类的依赖收集，并且依赖服务也直接用其类名作为修饰器，而不是<code>@inject()</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// src\\vs\\workbench\\services\\authentication\\browser\\authenticationService.ts</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthenticationService</span> <span class="token keyword">extends</span> <span class="token class-name">Disposable</span> <span class="token keyword">implements</span> <span class="token class-name">IAuthenticationService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IActivityService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> activityService<span class="token operator">:</span> IActivityService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IExtensionService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> extensionService<span class="token operator">:</span> IExtensionService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IStorageService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> storageService<span class="token operator">:</span> IStorageService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IRemoteAgentService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> remoteAgentService<span class="token operator">:</span> IRemoteAgentService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IDialogService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> dialogService<span class="token operator">:</span> IDialogService<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IQuickInputService</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> quickInputService<span class="token operator">:</span> IQuickInputService
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实这里的修饰符并不是真正指向类名，而是一个同名的资源描述符 id(VSCode 中称之为 <code>ServiceIdentifier</code>)，通常使用字符串或 Symbol 标识。</p><p>通过 <code>ServiceIdentifier</code> 作为 id，而不是简单粗暴地通过类名称作为 id 注册 Service，有利于处理项目中一个 interface 可能存在多态实现，需要同时多个同名类实例的问题。</p><p>此外，在构造 <code>ServiceIdentifier</code> 时，我们便可以将该类声明注入框架，而无需<code>@injectable()</code>显示调用了。</p><p>那么，这样一个 <code>ServiceIdentifier</code> 该如何构造呢？</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// src\\vs\\platform\\instantiation\\common\\instantiation.ts</span>
<span class="token comment">/**
 * The *only* valid way to create a {{ServiceIdentifier}}.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">createDecorator</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>serviceId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ServiceIdentifier<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>_util<span class="token punctuation">.</span>serviceIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> _util<span class="token punctuation">.</span>serviceIds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;@IServiceName-decorator can only be used to decorate a parameter&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">storeServiceDependency</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> target<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  id<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> serviceId<span class="token punctuation">;</span>

  _util<span class="token punctuation">.</span>serviceIds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 被 ServiceIdentifier 装饰的类在运行时，将收集该类的依赖，注入到框架中。</span>
<span class="token keyword">function</span> <span class="token function">storeServiceDependency</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> target<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_TARGET</span><span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_DEPENDENCIES</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> index <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_DEPENDENCIES</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> index <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_util<span class="token punctuation">.</span><span class="token constant">DI_TARGET</span><span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们仅需通过<code>createDecorator</code>方法为类创建一个唯一的<code>ServiceIdentifier</code>，并将其作为修饰符即可。</p><p>以上面的 AuthenticationService 为例，若所依赖的 ActivityService 需要变更多态实现，仅需修改 <code>ServiceIdentifier</code> 修饰符确定实现方式即可，无需更改业务的调用代码。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> IActivityServicePlanA <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createDecorator</span><span class="token generic class-name"><span class="token operator">&lt;</span>IActivityService<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;IActivityServicePlanA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IActivityServicePlanB <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createDecorator</span><span class="token generic class-name"><span class="token operator">&lt;</span>IActivityService<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;IActivityServicePlanB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IActivityService</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthenticationService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">IActivityServicePlanA</span></span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> activityService<span class="token operator">:</span> IActivityService<span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="循环依赖问题" tabindex="-1"><a class="header-anchor" href="#循环依赖问题"><span>循环依赖问题</span></a></h2><p>模块之间的依赖关系是有可能存在循环依赖的，比如 A 依赖 B，B 依赖 A。这种情况下进行两个模块的实例化会造成死循环，因此我们需要在框架中加入循环依赖检测机制来进行规避。</p><p>本质上，一个健康的模块依赖关系就是一个有向无环图(DAG)，我们之前介绍过有向无环图在 excel 表格函数中的应用，放在依赖注入框架的设计中也同样适用。</p><p>我们可以通过深度优先搜索(DFS)来检测模块之间的依赖关系，如果发现存在循环依赖，则抛出异常。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// src/vs/platform/instantiation/common/instantiationService.ts</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> roots <span class="token operator">=</span> graph<span class="token punctuation">.</span><span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// if there is no more roots but still</span>
  <span class="token comment">// nodes in the graph we have a cycle</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>roots<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">throwCycleError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> root <span class="token keyword">of</span> roots<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// create instance and overwrite the service collections</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createInstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">.</span>desc<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_services<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">.</span>id<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该方法通过获取图节点的出度，将该类的全部依赖提取出来作为roots，然后逐个实例化，并从途中剥离该依赖节点。由于依赖树的构建是逐层依赖的，因此按顺序实例化即可。当发现该类的所有依赖都被实例化后，图中仍存在节点，则认为存在循环依赖，抛出异常。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本篇文章简要介绍并实现了一个依赖注入框架，并解析了VSCode在实际问题上做出的一些改进。</p><p>实际上 VSCode 的依赖注入能力还有很多细节需要处理。例如异步实例化能力支持，通过封装 Deferred 类取得Promise执行状态，等等，在此就不一一展开了。感兴趣的同学可以参考 VSCode 源码：<a href="src/vs/platform/instantiation/common/instantiationService.ts">src/vs/platform/instantiation/common/instantiationService.ts</a>，做更进一步的学习。</p><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录"><span>附录</span></a></h2>`,46),r={href:"https://github.com/realDuang/dependencies-injector-demo",target:"_blank",rel:"noopener noreferrer"};function k(d,v){const a=e("ExternalLinkIcon");return p(),o("div",null,[u,n("p",null,[s("最简 DI 框架完整 demo："),n("a",r,[s("https://github.com/realDuang/dependencies-injector-demo"),c(a)])])])}const b=t(l,[["render",k],["__file","3.dependency-injection-design.html.vue"]]),y=JSON.parse('{"path":"/blogs/vscode-for-web/3.dependency-injection-design.html","title":"VS Code For Web 深入浅出 -- 依赖注入设计","lang":"en-US","frontmatter":{"title":"VS Code For Web 深入浅出 -- 依赖注入设计","date":"2022-11-15T12:23:56.000Z","categories":["VSCode For Web 深入浅出"],"tags":["VS Code","VS Code For Web"]},"headers":[{"level":2,"title":"依赖注入介绍","slug":"依赖注入介绍","link":"#依赖注入介绍","children":[]},{"level":2,"title":"最简依赖注入框架设计","slug":"最简依赖注入框架设计","link":"#最简依赖注入框架设计","children":[]},{"level":2,"title":"VSCode 的依赖收集实现","slug":"vscode-的依赖收集实现","link":"#vscode-的依赖收集实现","children":[]},{"level":2,"title":"循环依赖问题","slug":"循环依赖问题","link":"#循环依赖问题","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"附录","slug":"附录","link":"#附录","children":[]}],"git":{"createdTime":1727256384000,"updatedTime":1727256384000,"contributors":[{"name":"Duang Cheng","email":"longcheng@microsoft.com","commits":1}]},"filePathRelative":"blogs/vscode-for-web/3.dependency-injection-design.md"}');export{b as comp,y as data};
