import{_ as t,r as p,o as r,c,a as n,d as e,e as o,b as a}from"./app-D7BFNZkS.js";const d={},l=a('<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>最近我在浏览 VSCode for web 的 repo，在最近更新的一些 commit 中发现了一个新的 VSCode 插件特性支持，名为 <code>webOpener</code>，它的作用是什么呢？又是如何影响插件加载的呢？在这一篇中我们结合 VSCode For Web 的插件加载机制来详细分析一下。</p></div><h2 id="vscode-for-web-的插件加载机制" tabindex="-1"><a class="header-anchor" href="#vscode-for-web-的插件加载机制"><span>VSCode for web 的插件加载机制</span></a></h2><p>我们知道，由于 VSCode for web 运行在浏览器上，因此，它的插件加载机制与 VSCode for desktop 有所不同。</p><p>在 VSCode for desktop 中，插件是以 vsix 包的形式存在的，因此，VSCode for desktop 可以直接通过 vsix 包的形式加载插件。而在 VSCode for web 中，由于浏览器的安全机制，不能直接加载 vsix 包。</p><p>因此，VSCode for web 采用了一种特殊的插件加载机制。发布 VSCode for web 插件时，发布系统会直接将项目编译，并发布到 CDN 节点上。当用户加载插件时，通过向该目标 url 发送请求，拉取远端(也可以是本地)的 <code>extension.js</code> 文件。并利用 web worker 加载机制，为每个插件分配独立线程加载与执行。</p><p>在生产环境中，对每个进入 VSCode 插件商店的插件，VSCode for web 会将支持 web 环境的插件的 <code>package.json</code> 与 <code>extension.js</code> 等文件打包成一个 zip 包，然后根据 publisher 分配合适的二级域名，通过 CDN 分发。</p><p>以我在使用的<code>One Dark Pro</code>主题为例：</p><p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230508145433.png" alt="20230508145433"></p><p>而在调试模式中，我们可以通过 <code>Install extension from location...</code>命令，指定编译后插件的 url，从而加载插件。</p><p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230508143115.png" alt="20230508143115"></p>',10),i={href:"https://localhost:5000",target:"_blank",rel:"noopener noreferrer"},u=n("code",null,"package.json",-1),b=n("code",null,"extension.js",-1),h=a(`<p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20230508144906.png" alt="20230508144906"></p><p>通过这样的方式，VSCode for web 在每次页面打开后，完成了对用户自定义的插件管理与加载。并由于<code>web worker</code>的特性，每个插件的执行环境都是独立且相互隔离的。</p><h2 id="通过特殊-url-路由的方式的插件加载机制" tabindex="-1"><a class="header-anchor" href="#通过特殊-url-路由的方式的插件加载机制"><span>通过特殊 url 路由的方式的插件加载机制</span></a></h2><p>VSCode for web 最突出的特点是它是运行在浏览器上的，因此，我们可以利用 url，来实现一些奇妙的新特性。例如，通过特殊的 url 路由，免安装地加载插件。</p><p>目前，vscode.dev 可以使用这样的方式加载插件：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>https://vscode.dev/+publisher.name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如，在浏览器中输入 <code>https://vscode.dev/+ms-vscode.onedrive-browser</code> 将加载 OneDrive 浏览器扩展。</p><p>当然，我们也可以使用同样的方式加载本地编译的插件。由于 vscode.dev 强制要求 <code>secure context</code> ，因此，我们需要在本地启动一个 <code>https</code> 的服务器，并对 url 进行 base64 编码，才能正常访问。</p>`,8),m=n("code",null,"https://vscode.dev/+aHR0cHM6Ly9sb2NhbGhvc3Q6MzAwMA==",-1),v={href:"https://localhost:3000",target:"_blank",rel:"noopener noreferrer"},k=a(`<h2 id="webopener-特性介绍" tabindex="-1"><a class="header-anchor" href="#webopener-特性介绍"><span>webOpener 特性介绍</span></a></h2><p>有开发过 VSCode for desktop 的插件的同学应该知道，vscode 插件的所有能力都是在 <code>package.json</code> 中声明的，这也是为什么 VSCode 除了需要加载入口的 <code>extension.js</code> 外，还一定要加载插件的 <code>package.json</code> 的原因。</p><p>在插件 <code>package.json</code> 的 <code>contributes</code> 字段中，我们可以声明插件的各种能力，例如，命令、菜单、快捷键、主题、语言、调试器等等。</p><p>对于 vscode for web 版本的插件来说，我们还可以声明 <code>webOpener</code> 能力，其所有属性都是可选的。声明如下：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;onedrive-browser&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;contributes&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;webOpener&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;scheme&quot;</span><span class="token operator">:</span> <span class="token string">&quot;onedrive&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;import&quot;</span><span class="token operator">:</span> <span class="token string">&quot;webOpener.js&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;runCommands&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token property">&quot;command&quot;</span><span class="token operator">:</span> <span class="token string">&quot;hello-world&quot;</span><span class="token punctuation">,</span> <span class="token property">&quot;args&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;$url&quot;</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    ...
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="webopener-scheme" tabindex="-1"><a class="header-anchor" href="#webopener-scheme"><span>webOpener.scheme</span></a></h3><p>默认情况下，<code>vscode.dev/+publisher.name</code> 路由将直接打开默认的 VSCode 示例工作区。但是，如果提供了 scheme path，则 VSCode 将根据路由参数打开一个以该协议打开 url 中后续 path 指向的文件夹，格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 当 scheme 设置为 onedrive</span>
https://vscode.dev/+publisher.name/remoteAuthority/path/segments/<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，当插件 webOpener 的 scheme 设置为 onedrive 时，访问 <code>https://vscode.dev/+ms-vscode.onedrive-browser/myPersonalDrive/cool/folder</code> ，此时访问 url 将重定向为 <code>onedrive:///myPersonalDrive/cool/folder</code>。</p><p>若此协议不在 VSCode 的内置协议中，我们可以在插件中通过 <code>vscode.workspace.registerFileSystemProvider</code> 这个 API 注册自定义的 FileSystemProvider，从而实现对自定义协议的 FileSystem 支持。</p><p>本质上，它打开的方式与 VSCode for web 的 <code>vscode.open</code> 命令也是一致的。</p><h3 id="webopener-runcommands" tabindex="-1"><a class="header-anchor" href="#webopener-runcommands"><span>webOpener.runCommands</span></a></h3><p>当 VSCode 的主 workbench 加载完毕后，会触发 <code>webOpener</code> 的 <code>onDidCreateWorkbench</code> 的钩子，并执行此处声明的命令集。</p><p>这将传入一个命令数组，例如：<code>[{ &quot;command&quot;: &quot;test-extension.hello-world&quot;, &quot;args&quot;: [&quot;$url&quot;] }]</code>，此时将可以执行自定义插件 <code>test-extension</code> 的相关命令。</p><p>其中，<code>$url</code> 指代当前页面 url。如果插件的初始化依赖来自 url 的 query/path 等等信息，这将很有用。</p><h3 id="webopener-import" tabindex="-1"><a class="header-anchor" href="#webopener-import"><span>webOpener.import</span></a></h3><p>这里定义了 webOpener 加载的入口点。它是一个相对于插件 package.json 的 ES Module 路径，例如：<code>webOpener.js</code>。</p><p>它与 <code>extension.js</code> 一样，默认导出一个 <code>doRoute</code> 函数，该函数将获取 route 与 workbench 等信息(workbench 这个实例中提供了当前 vscode for web 的命令、日志、环境、window、workspace 等多种能力支持)。由于 <code>webOpener.js</code> 运行在主线程中，因此它能做到的事情要比处于 web worker 下的 vscode for web 插件更多。</p><p>举一个例子，这是一个简单的 webOpener 贡献 onedrive-browser：</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">doRoute</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// If we&#39;re not already opening a OneDrive, show the picker immediately</span>
  <span class="token comment">// when the user hits \`vscode.dev/+ms-vscode.onedrive-browser\`.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>route<span class="token punctuation">.</span>workspace<span class="token punctuation">.</span>folderUri<span class="token operator">?.</span>scheme <span class="token operator">!==</span> <span class="token string">&#39;onedrive&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    route<span class="token punctuation">.</span>onDidCreateWorkbench<span class="token punctuation">.</span>runCommands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      command<span class="token operator">:</span> <span class="token string">&#39;onedrive-browser.openOneDrive&#39;</span><span class="token punctuation">,</span>
      args<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它将在 workbench 加载完毕后，判断当前的 workspace 是否为 onedrive，如果不是，则执行 <code>onedrive-browser.openOneDrive</code> 命令，从而打开 onedrive 文件夹。</p><h2 id="webopener-与插件的通信机制" tabindex="-1"><a class="header-anchor" href="#webopener-与插件的通信机制"><span>webOpener 与插件的通信机制</span></a></h2><p>在了解了 webOpener 的基本特性之后，我们来看看该如何利用这些特性，与我们的 web 插件进行通信，从而扩展插件能力。</p><p>我们可以看出，由于 webOpener 加载在主线程，且 doRoute 方法的执行时机在主线程 workbench 加载完毕之后，在请求远端插件并执行之前。因此，我们可以有两种方式来传递信息，与处于 web worker 下，与宿主隔离的插件进行通信。</p><p>第一种即为在 runCommands 中介绍的，通过执行 command 并传递 url 的方式传递初始化信息。该方式也是 webOpener 与插件通信的常用方式之一，用于为初始化插件时提供部分依赖参数。</p><p>第二种则是通过 doRoute 方法，捕获此时的请求信息，并根据请求信息的不同对插件能力进行不同的变更，但本质上还是通过 command 的方式给插件发送 args 来实现的。</p><p>我在当前最新版本的 vscode-dev 代码库中(1.79.0)，并未发现直接通过 webOpener 暴露类似 postMessage 的与插件通信的方法，因此到目前为止，我们只能通过给插件的 command 方式触发 trigger 与传入参数这一种方式来实现与插件的通信。这导致了在 web 下插件的能力其实相当受限。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本篇文章解析了在 VSCode for web 中的插件加载机制，以及如何通过 webOpener 特性来扩展插件的能力。</p><p>我们可以看出，在现阶段的 VSCode for web 中，插件的加载机制也仅仅只是做到了可用状态。由于 web worker 天然的与主线程隔离的特性，desktop 的很多好用的功能性插件(即除了 theme/key-binding 这种不需要执行逻辑的插件之外)在 web 端的支持还是会遇到很多问题，并不能无缝迁移。这点也是我在尝试开发 VSCode for web 插件时最大的痛点。</p><p>不过，随着 VSCode for web 项目仍在进行高频的开发与完善，希望未来的 VSCode for web 能在插件开发与使用上尽可能对齐甚至兼容 desktop 的体验。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2>`,32),w={href:"https://github.com/microsoft/vscode-dev",target:"_blank",rel:"noopener noreferrer"},g={href:"https://code.visualstudio.com/docs/editor/vscode-web",target:"_blank",rel:"noopener noreferrer"};function f(C,S){const s=p("ExternalLinkIcon");return r(),c("div",null,[l,n("p",null,[e("我们使用本地服务器，指定一个已编译好的 VSCode web extension，并填入本地服务器地址 ("),n("a",i,[e("https://localhost:5000"),o(s)]),e(")，并刷新页面，那么从 Chrome 的 Network 中可以看到 VSCode 向目标位置请求了"),u,e(" 与 "),b,e("，并看到插件已经被成功加载了。")]),h,n("p",null,[e("访问"),m,e('即可。(后面那一段为"'),n("a",v,[e("https://localhost:3000"),o(s)]),e('") 的 base64 编码)')]),k,n("ul",null,[n("li",null,[n("a",w,[e("VSCode dev Repository"),o(s)]),e(" (目前是私有仓库，需要向 Microsoft 申请权限，未来功能完善后或将开放)")]),n("li",null,[n("a",g,[e("VSCode for the Web Introduction"),o(s)])])])])}const V=t(d,[["render",f],["__file","4.extension-loading-mechanism.html.vue"]]),_=JSON.parse('{"path":"/blogs/vscode-for-web/4.extension-loading-mechanism.html","title":"VSCode For Web 深入浅出 -- 插件加载机制","lang":"en-US","frontmatter":{"title":"VSCode For Web 深入浅出 -- 插件加载机制","date":"2023-05-08T18:54:33.000Z","categories":["VSCode For Web 深入浅出"],"tags":["VS Code","VS Code For Web"]},"headers":[{"level":2,"title":"VSCode for web 的插件加载机制","slug":"vscode-for-web-的插件加载机制","link":"#vscode-for-web-的插件加载机制","children":[]},{"level":2,"title":"通过特殊 url 路由的方式的插件加载机制","slug":"通过特殊-url-路由的方式的插件加载机制","link":"#通过特殊-url-路由的方式的插件加载机制","children":[]},{"level":2,"title":"webOpener 特性介绍","slug":"webopener-特性介绍","link":"#webopener-特性介绍","children":[{"level":3,"title":"webOpener.scheme","slug":"webopener-scheme","link":"#webopener-scheme","children":[]},{"level":3,"title":"webOpener.runCommands","slug":"webopener-runcommands","link":"#webopener-runcommands","children":[]},{"level":3,"title":"webOpener.import","slug":"webopener-import","link":"#webopener-import","children":[]}]},{"level":2,"title":"webOpener 与插件的通信机制","slug":"webopener-与插件的通信机制","link":"#webopener-与插件的通信机制","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1716368266000,"updatedTime":1716368266000,"contributors":[{"name":"Duang Cheng","email":"longcheng@microsoft.com","commits":1}]},"filePathRelative":"blogs/vscode-for-web/4.extension-loading-mechanism.md"}');export{V as comp,_ as data};
