import{_ as n,o as s,c as a,b as t}from"./app-BgGkuvCY.js";const e={},p=t(`<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>了解设计模式是学习一切软件架构设计的基础，大到一个项目的整体框架设计，小到一个功能函数的优化，都有着重要意义。《代码大全》中将设计模式共分为了 23 类，分别为：</p><ol><li>创建型模式(5 种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式(7 种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式(11 种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ol><p>接下来我将针对其中常用的几种设计模式进行解读与实现，供大家参考。</p></div><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>上一篇中我们提到了装饰器模式，这也是一种非常实用的设计模式，主要的特点是非侵入式，能让组件功能能被更好的解耦和复用，解决了不同组件之间共享某些相同功能的难题。有时候我们并不关心函数的内部实现，仅仅想做功能增强，装饰器模式就能给我们带来良好的可读性的同时，减少我们修改需求的成本。</p><p>在 js 中，我们可以构造一个装饰器函数，接收任何一个组件函数，返回一个增强功能的新组件，原组件其他功能不受影响，并且当该增强功能不再使用时，只需要在调用处去除包裹的装饰器函数即可，这样可插拔式的功能体验可使得代码变得简单而优雅。</p><h2 id="修饰函数的装饰器实现" tabindex="-1"><a class="header-anchor" href="#修饰函数的装饰器实现"><span>修饰函数的装饰器实现</span></a></h2><p>正是因为装饰器模式带来的种种好处，在 es7 标准中已经正式引入了装饰器特性，标志符为 <code>@</code>。我们可以设定如下情况：设计一个通用型的日志补丁，能够输出组件中某些方法的调用日志的功能，我们可以这样写：</p><blockquote><p>以下代码请务必在支持 es7 的环境下运行，如何使用请自行查阅 babel 相关文档</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  @decorateLog
  <span class="token function">addNum</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">decorateLog</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.arguments：</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> descriptor<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> comp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> comp<span class="token punctuation">.</span><span class="token function">addNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">answer is:</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// addNum.arguments：[1, 2] answer is: 3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不难看出，装饰器函数接收三个参数：被修饰对象，被修饰对象名，以及该对象属性描述符(参考<code>Object.defineProperty</code>中的<code>descriptor</code>属性)，返回新的被修饰对象属性描述符。</p><h2 id="修饰类的装饰器实现" tabindex="-1"><a class="header-anchor" href="#修饰类的装饰器实现"><span>修饰类的装饰器实现</span></a></h2><p>装饰器不仅能被用于修饰类属性，甚至能够直接修饰类本身，增强类功能。这个特性也十分实用。本质上，装饰器的行为就是一个高阶函数，其作用全等于以下用法：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">decorator</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Component <span class="token operator">=</span> <span class="token function">decorator</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span> <span class="token operator">||</span> Component<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之前在写 redux 相关的文章时也顺口提到过，connect 这个高阶组件也能够用装饰器模式来实现，使得导出类变得更美观且易读。</p><p>这是不使用装饰器的 connect 组件写法，高阶函数显得冗长不易读，export 导出物不够明显与直观。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用装饰器后，写法变成了这样</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>@<span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们也参照上述写法，来实现自己的类装饰器。假设这样一种情况，我们需要对每一个类组件增添一个获取作者名的通用方法，那我们可以这样来做：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>@decorateAuthor
<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他属性</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">decorateAuthor</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getAuthor</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&#39;synccheng&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> comp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comp<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的一点的是，在 js 中，装饰器只能用于类和类中的方法，不能用于函数。这是因为，装饰器函数是在编译时执行，而不是在运行时执行。因此，若之间在普通函数中使用会存在函数提升的问题，即先定义函数名称，并不赋值，在被修饰函数声明时只能取到 undefined 的装饰器值，导致调用结果与预期不符。</p><p>总而言之，在适当的时机使用装饰器模式能帮我们得到一份优雅、易读、可插拔式的代码体验，使用装饰器模式，不需要深入理解原有的代码逻辑就能直接开发新特性，在对老代码进行功能增强的时候，有着事半功倍的效果。</p>`,21),o=[p];function c(l,i){return s(),a("div",null,o)}const r=n(e,[["render",c],["__file","2019-09-23.html.vue"]]),d=JSON.parse('{"path":"/blogs/architecture/2019-09-23.html","title":"设计模式的 js 实现 (2)--装饰器模式","lang":"en-US","frontmatter":{"title":"设计模式的 js 实现 (2)--装饰器模式","date":"2019-09-23T11:07:08.000Z","categories":["架构设计"],"tags":["JavaScript","设计模式"]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"修饰函数的装饰器实现","slug":"修饰函数的装饰器实现","link":"#修饰函数的装饰器实现","children":[]},{"level":2,"title":"修饰类的装饰器实现","slug":"修饰类的装饰器实现","link":"#修饰类的装饰器实现","children":[]}],"git":{"createdTime":1716360538000,"updatedTime":1716360538000,"contributors":[{"name":"Duang Cheng","email":"longcheng@microsoft.com","commits":1}]},"filePathRelative":"blogs/architecture/2019-09-23.md"}');export{r as comp,d as data};
