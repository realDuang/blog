import{_ as o,r as l,o as c,c as i,a as e,d as a,e as s,b as p}from"./app-B9TWmIeZ.js";const t={},d=p(`<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p><code>DevOps</code>一词源于<code>Development</code> 和 <code>Operations</code> 的组合，即将软件交付过程中开发与测试运维的环节通过工具链打通，并通过自动化的测试与监控，减少团队的时间损耗，更加高效稳定地交付制品。</p><p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续集成阶段</code> 需要提供的能力，将对工作流的设计及流水线的优化思路做一个简要讲解。</p></div><p>随着项目规模越来越大，功能特性与维护人员越来越多，特性交付频率与软件质量之间的矛盾日渐尖锐，如何平衡两者成为了目前团队亟需关注的一个重点，于是，落地一个完善的<code>DevOps</code>工具链便被提上日程。</p><p>我们认为，从代码集成、功能测试，到部署发布、基础设施架构管理，每一个环节都应该有全面且完善的自动化监控手段，并尽量避免人工介入。只有这样，软件才能同时兼顾质量与效率，在提高发布频率的情况下保证可靠性。这是每一个成功的大型项目最终一定要实现的目标。</p><p>本篇文章将着重探讨 <code>DevOps</code> 在 <code>持续集成阶段</code> 需要提供的能力，将对工作流的设计及流水线的优化思路做一个简要讲解。</p><h2 id="当我们在谈论-ci-时-我们在谈论什么" tabindex="-1"><a class="header-anchor" href="#当我们在谈论-ci-时-我们在谈论什么"><span>当我们在谈论 CI 时，我们在谈论什么</span></a></h2><p>CI(Continuous Integration)，即持续集成，指频繁地(一天多次)将代码集成到主干的行为。</p><p>注意，这里既包含持续将代码集成到主干的含义，也包含持续将源码生成可供实际使用的制品的过程。因此，我们需要通过 CI，自动化地保证代码的质量，并对其构建产物转换生成可用制品供下一阶段调用。</p><p>因此，在 CI 阶段，我们至少有如下阶段需要实现：</p><ol><li>静态代码检查</li></ol><p>这其中包括，ESLINT/TSLINT 静态语法检查，验证 git commit message 是否符合规范，提交文件是否有对应 owner 可以 review 等等。这些静态检查不需要编译过程，直接扫描源代码就可以完成。</p><ol start="2"><li>单元测试/集成测试/E2E 测试</li></ol><p>自动化测试这一环节是保障制品质量的关键。测试用例的覆盖率及用例质量直接决定了构建产物的质量，因此，全面且完善的测试用例也是实现持续交付的必备要素。</p><ol start="3"><li>编译并整理产物</li></ol><p>在中小型项目中，这一步通常会被直接省略，直接将构建产物交由部署环节实现。但对于大型项目来说，多次频繁的提交构建会产生数量庞大的构建产物，需要得到妥善的管理。产物到制品的建立我们接下来会有详细讲解。</p><h2 id="利于集成的工作流设计" tabindex="-1"><a class="header-anchor" href="#利于集成的工作流设计"><span>利于集成的工作流设计</span></a></h2><p>在正式接入 CI 前，我们需要规划好一种新的工作流，以适应项目切换为高频集成后可能带来的问题与难点。这里涉及到的改造层面非常多，除了敦促开发人员习惯的转变以及进行新流程的培训外，我们主要关心的是源码仓库的更新触发持续集成步骤的方式。</p><h3 id="流水线的组织形式" tabindex="-1"><a class="header-anchor" href="#流水线的组织形式"><span>流水线的组织形式</span></a></h3><p>我们需要一个合适的组织形式来管理一条 CI 流水线该在什么阶段执行什么任务。</p><p>市面上有非常多的 CI 工具可以进行选择，仔细观察就会发现，无论是 Drone 这样的新兴轻量的工具，亦或是老牌的 Jenkins 等，都原生或通过插件方式支持了这样一个特性：<code>Configuration as Code</code>，即使用配置文件管理流水线。</p><p>这样做的好处是相当大的。首先，它不再需要一个 web 页面专门用于流水线管理，这对于平台方来说无疑减少了维护成本。其次对于使用方来说，将流水线配置集成在源码仓库中，享受与源码同步升级的方式，使得 CI 流程也能使用 git 的版本管理进行规范与审计溯源。</p><p>确立了流水线的组织形式后，我们还需要考虑版本的发布模式以及源码仓库的分支策略，这直接决定了我们该以什么样的方式规划流水线进行代码集成。</p><h3 id="版本发布模式的取舍" tabindex="-1"><a class="header-anchor" href="#版本发布模式的取舍"><span>版本发布模式的取舍</span></a></h3><p>在《持续交付 2.0》一书中提到，版本发布模式有三要素：<code>交付时间、特性数量以及交付质量</code>。</p><p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210525201849.png" alt="20210525201849"></p><p>这三者是相互制衡的。在开发人力与资源相对固定的情况下，我们只能对其中的两个要素进行保证。</p><p>传统的项目制发布模式是牺牲了交付时间，等待所有特性全部开发完成并经历完整人工测试后才发布一次新版本。但这样会使得交付周期变长，并且由于特性数量较多，在开发过程中的不可控风险变高，可能会导致版本无法按时交付。不符合一个成熟的大型项目对于持续交付的要求。</p><p>对于持续集成的思想来说，当我们的集成频率足够高，自动化测试足够成熟且稳定时，完全可以不用一股脑的将特性全堆在一次发布中。每开发完成一个特性就自动进行测试，完成后合入等待发布。接下来只需要在特定的时间周期节点自动将已经稳定的等待中的特性发布出去即可。这对于发布频率越来越高，发布周期越来越短的现代大型项目中无疑是一个最优解。</p><h3 id="分支策略" tabindex="-1"><a class="header-anchor" href="#分支策略"><span>分支策略</span></a></h3><p>与大部分团队一样，我们原有的开发模式也是<code>分支开发，主干发布</code>的思想，分支策略采用业界最成熟也是最完善的<code>Git-Flow</code>模式。</p><p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20210601150436.png" alt="gitflow"></p><p>可以看出，该模式在特性开发，bug 修复，版本发布，甚至是 hotfix 方面都已经考虑到位了，是一个能应用在生产环境中的工作流。但整体的结构也因此变得极为复杂，不便管理。例如进行一次 hotfix 的操作流程是：从最新发布前使用的主干分支拉出 hotfix 分支，修复后合入到 develop 分支中，等待下一次版本发布时拉出到 release 分支中，发布完成后才能合回主干。</p><p>此外，对于<code>Git-Flow</code>的每一个特性分支来说，并没有一个严格的合入时间，因此对于较大需求来说可能合入时间间隔会很长，这样在合入主干时可能会有大量的冲突需要解决，导致项目工期无端延长。对此，做大型改造与重构的同学应该深有体会。</p><p>针对这一点，我们决定大胆采用<code>主干开发，主干发布</code>的分支策略。</p><p>我们要求，开发团队的成员尽量每天都将自己分支的代码提交到主干。在到达发布条件时，从主干直接拉出发布分支用于发布。若发现缺陷，直接在主干上修复，并根据需要 <code>cherry pick</code> 到对应版本的发布分支。</p><p><img src="https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/主干开发.png" alt="主干开发"></p><p>这样一来，对于开发人员来说需要关注的分支就只有主干和自己 working 的分支两条，只需要 push 与 merge 两条 git 命令就能完成所有分支操作。同时，由于合入频率的提高，平均每人需要解决的冲突量大大减少，这无疑解决了很多开发人员的痛点。</p><p>需要说明的是，分支策略与版本发布模式没有银弹。我们采用的策略可能并不适合所有团队的项目。提高合入频率尽快能让产品快速迭代，但无疑会让新开发的特性很难得到充分的手工测试及验证。</p><p>为了解决这一矛盾点，这背后需要有强大的基础设施及长期的习惯培养做支持。这里将难点分为如下几个类型，大家可以针对这些难点做一些考量，来确定是否有必要采用主干开发的方式。</p><ol><li>完善且快速的自动化测试。只有在单元测试、集成测试、E2E 测试覆盖率极高，且通过变异测试得出的测试用例质量较高的情况下，才能对项目质量有一个整体的保证。但这需要团队内所有开发人员习惯 TDD(测试驱动开发)的开发方式，这是一个相当漫长的工程文化培养过程。</li><li>Owner 责任制的 Code Review 机制。让开发人员具有 Owner 意识，对自己负责的模块进行逐行审查，可以在代码修改时规避许多设计架构上的破坏性修改与坑点。本质上难点其实还是开发人员的习惯培养。</li><li>大量的基础设施投入。高频的自动化测试其实是一个相当消耗资源的操作，尤其是 E2E 测试，每一个测试用例都需要启动一个无头浏览器来支撑。另外，为了提升测试的效率，需要多核的机器来并行执行。这里的每一项都是较大的资源投入。</li><li>快速稳定的回滚能力和精准的线上及灰度监控等等。只有在高度自动化的全链路监控下，才能保证该机制下发布的新版本能够稳定运行。这里的建设我会在之后的文章里详细介绍。</li></ol><h2 id="大型项目中产物-制品的建立" tabindex="-1"><a class="header-anchor" href="#大型项目中产物-制品的建立"><span>大型项目中产物-&gt;制品的建立</span></a></h2><p>对于大多数项目来说，在代码编译完成生成产物后，部署项目的方式就是登录发布服务器，将每一次生成的产物粘贴进发布服务器中。生成的静态文件由于 hash 不同可以同时存放，html 采用直接覆盖的方式进行更新。</p><p>直接使用复制粘贴的方式来操作文件的更新与覆盖，这样既不方便对更新历史的审计与追溯，同时这样的更改也很难保证正确性。</p><p>除此之外，当我们需要回滚版本时，由于服务器上并没有存放历史版本的 html，因此回滚的方式其实是重新编译打包生成历史版本的产物进行覆盖。这样的回滚速度显然不是令人满意的。</p><p>一个解决方法是，不要对文件进行任何的覆盖更新，所有的产物都应该被上传持久化存储。我们可以在请求上游增设一个流量分发服务，来判断每一条请求应该返回哪一个版本的 html 文件。</p><p>对于大型项目来说，返回的 html 文件也不一定不是一成不变的。它可能会被注入渠道、用户自定义等标识，以及 SSR 所需要的首屏数据，从而改变其代码形式。因此，我们认为 html 文件的制品提供方应该是一个单独的动态服务，通过一些逻辑完成对模板 html 的替换并最终输出。</p><p>总结一下，在每次编译完成后，产物将会进行如下的整理以生成最终的前端制品：</p><ol><li>针对静态文件，如 CSS、JS 等资源将会发布到云对象存储中，并以此为源站同步给 CDN 做访问速度优化。</li><li>针对 HTML 制品，需要一个直出服务做支撑，并打包成 docker 镜像，与后端的微服务镜像同等级别，供上游的流量分发服务(网关)根据用户请求选择调起哪些服务负载进行消费。</li></ol><h2 id="速度即效率-流水线优化思路" tabindex="-1"><a class="header-anchor" href="#速度即效率-流水线优化思路"><span>速度即效率，流水线优化思路</span></a></h2><p>对于一个好的工具来说，内部设计可以很复杂，但对于使用者来说必须足够简单且好用。</p><p>在主干开发这样高频的持续集成下，集成速度即效率，流水线的执行时间毫无疑问是开发人员最关心的，也是流水线是否好用的决定性指标。我们可以从几个方面着手，提高流水线执行效率，减少开发人员的等待时间。</p><h3 id="流水线任务编排" tabindex="-1"><a class="header-anchor" href="#流水线任务编排"><span>流水线任务编排</span></a></h3><p>对流水线各个阶段需要执行的任务我们需要遵循一定的编排原则：<code>无前置的任务优先</code>，<code>执行时间短的任务优先</code>，<code>无关联的任务并行</code>。</p><p>根据这一原则，我们可以通过分析流水线中执行的各个任务，对每一个任务做一次最短路径依赖分析，最终得出该任务的最早执行时机。</p><h3 id="巧用-docker-cache" tabindex="-1"><a class="header-anchor" href="#巧用-docker-cache"><span>巧用 Docker Cache</span></a></h3><p>Docker提供了这样一个特性：在Docker镜像的构建过程中，Dockerfile的每一条可执行语句都会构建出一个新的镜像层，并缓存起来。在第二次构建时，Docker会以镜像层为单位逐条检查自身的缓存，若命中相同镜像层，则直接复用该条缓存，使得多次重复构建的时间大大缩短。</p><p>我们可以利用Docker的这一特性，在流水线中减少通常会重复执行的步骤，从而提高CI的执行效率。</p><p>例如前端项目中通常最耗时的依赖安装<code>npm install</code>，变更依赖项对于高频集成来说其实是一个较小概率的事件，因此我们可以在第一次构建时，将<code>node_modules</code>这个文件夹打包成为镜像供下次编译时调用。Dockerfile示例编写如下：</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> node:12 <span class="token keyword">AS</span> dependencies</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /ci</span>

<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>

<span class="token instruction"><span class="token keyword">ENV</span> NODE_PATH=/ci/node_modules</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们给流水线增加一条检查缓存命中的策略：在下次编译之前，先查找是否有该镜像缓存存在。并且，为了保证本次构建的依赖没有更新，我们还必须比对本次构建与镜像缓存中的<code>package-lock.json</code>文件的md5码是否一致。若不一致，则重新安装依赖并打包新镜像进行缓存。若比对结果一致，则从该镜像中直接取到<code>node_modules</code>文件夹，从而省去大量依赖安装的时间。</p><p>流水线拉取镜像文件夹的方法示例如下，其中 <code>--from</code> 后跟的是之前缓存构建镜像的别名：</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">dependencies</span></span> node_modules/ .</span>
<span class="token comment"># 其他步骤执行</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同理，我们也可以将这一特性扩展到CI过程中所有更新频率不高，生成时间较长的任务中。例如Linux中环境依赖的安装、单元测试每条用例运行前的缓存、甚至是静态文件数量极多的文件夹的复制等等，都能利用Docker cache的特性达到几乎跳过步骤，减少集成时间的效果。由于原理大致相同，在此就不赘述了。</p><h3 id="分级构建" tabindex="-1"><a class="header-anchor" href="#分级构建"><span>分级构建</span></a></h3><p>众所周知，流水线的执行时间一定会随着任务数量的增多而变慢。大型项目中，随着各项指标计算的接入，各项测试用例的数量逐渐增多，运行时间迟早会达到我们难以忍受的地步。</p><p>但是，测试用例的数量一定程度上决定着我们项目的质量，质量检查决不能少。那么有没有一种方法既可以让项目质量得到持续保障的同时，减少开发者等待集成的时间呢？答案就是分级构建。</p><p>所谓分级构建，就是将CI流水线拆分为主构建和次级构建两类，其中主构建需要在每次提交代码时都要执行，并且若检查不通过无法进行下一步操作。而次级构建不会阻塞工作流，通过旁路的方式在代码合入后继续执行。但是，一旦次级构建验证失败，流水线将会立即发出通知告警，并阻塞其他所有代码的合入，直到该问题被修复为止。</p><p>对于某任务是否应放入次级构建过程，有如下几点原则：</p><ol><li>次级构建将包含执行时间长(如超过15分钟)、耗费资源多的任务，如自动化测试中的E2E测试。</li><li>次级构建应当包含用例优先级低或者出错可能性低的任务，尽量不要包含重要链路。如果自动化测试中的一些测试用例经过实践发现失败次数较高，应当考虑增加相关功能单元测试，并移入主构建过程。</li><li>若次级构建仍然过长，可以考虑用合适的方法分割测试用例，并行测试。</li></ol><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>工欲善其事，必先利其器。腾讯文档项目高频稳定发布的背后，必定需要拥有强大基础设施的支持。</p><p>本篇文章仅主要介绍了持续集成阶段对项目进行的改造，持续部署、持续运营等阶段的具体改造思路将在笔者接下来的文章中详细说明。也欢迎大家多多探讨，对其中需要改进或有误的部分提出建议与斧正。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2>`,72),r=e("li",null,"《持续交付 2.0》—— 乔梁 著",-1),h={href:"https://www.redhat.com/zh/topics/devops/what-is-ci-cd",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.36kr.com/p/1218375440667012",target:"_blank",rel:"noopener noreferrer"};function u(m,v){const n=l("ExternalLinkIcon");return c(),i("div",null,[d,e("ol",null,[r,e("li",null,[e("a",h,[a("https://www.redhat.com/zh/topics/devops/what-is-ci-cd"),s(n)])]),e("li",null,[e("a",k,[a("https://www.36kr.com/p/1218375440667012"),s(n)])])])])}const w=o(t,[["render",u],["__file","2021-05-11.html.vue"]]),f=JSON.parse('{"path":"/blogs/frontend-tech-institute/2021-05-11.html","title":"大型前端项目 DevOps 沉思录 -- CI 篇","lang":"en-US","frontmatter":{"title":"大型前端项目 DevOps 沉思录 -- CI 篇","date":"2021-05-11T20:37:21.000Z","categories":["前端技术研究院"],"tags":["云原生","CI/CD","DevOps"]},"headers":[{"level":2,"title":"当我们在谈论 CI 时，我们在谈论什么","slug":"当我们在谈论-ci-时-我们在谈论什么","link":"#当我们在谈论-ci-时-我们在谈论什么","children":[]},{"level":2,"title":"利于集成的工作流设计","slug":"利于集成的工作流设计","link":"#利于集成的工作流设计","children":[{"level":3,"title":"流水线的组织形式","slug":"流水线的组织形式","link":"#流水线的组织形式","children":[]},{"level":3,"title":"版本发布模式的取舍","slug":"版本发布模式的取舍","link":"#版本发布模式的取舍","children":[]},{"level":3,"title":"分支策略","slug":"分支策略","link":"#分支策略","children":[]}]},{"level":2,"title":"大型项目中产物->制品的建立","slug":"大型项目中产物-制品的建立","link":"#大型项目中产物-制品的建立","children":[]},{"level":2,"title":"速度即效率，流水线优化思路","slug":"速度即效率-流水线优化思路","link":"#速度即效率-流水线优化思路","children":[{"level":3,"title":"流水线任务编排","slug":"流水线任务编排","link":"#流水线任务编排","children":[]},{"level":3,"title":"巧用 Docker Cache","slug":"巧用-docker-cache","link":"#巧用-docker-cache","children":[]},{"level":3,"title":"分级构建","slug":"分级构建","link":"#分级构建","children":[]}]},{"level":2,"title":"结语","slug":"结语","link":"#结语","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1733141773000,"updatedTime":1733141773000,"contributors":[{"name":"Duang Cheng","email":"longcheng@microsoft.com","commits":1}]},"filePathRelative":"blogs/frontend-tech-institute/2021-05-11.md"}');export{w as comp,f as data};
