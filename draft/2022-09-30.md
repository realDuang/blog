---
title: VSCode Server -- 下一代 Serverless 的 Web IDE 服务
date: 2022-09-30 14:41:00
tags:
---

## 背景

众所周知，VSCode 是一个非常优秀的 IDE，它的设计架构已经成为了近些年各家竞相模仿追逐的对象。但是它的体积非常大，而且需要安装在本地，无法直接安装在云端环境中，这就导致了它的使用场景非常有限。

2019 年，微软在 PyCon 2019 大会上发布了 VSCode Remote 插件，支持了远程开发，这个插件的出现，使得 VSCode 成为了一款真正的跨平台 IDE，不再局限于本地开发，可以通过 SSH 连接到远程服务器，然后在远程服务器上开发。

2020 年，Github Codespaces 又将 Web IDE 的进展向前迈进了一步，它允许用户使用云上托管的服务托管来进行开发，而不需要自己搭建服务器，实现了一个全托管的远程开发解决方案。

而现在，微软发布了 private preview 版本的 VS Code Server。这是一个`可私有化的`，可以在`远程`开发机器上运行的独立服务端，它允许用户直接通过 URL，在浏览器中安全地链接到远程开发机，且同时支持了 HTTP 与 Web Socket 协议。在此过程中不需要进行任何前期的 SSH 或 HTTPS 设置。

注：本文基于 VSCode v1.71 版本。

## VSCode Server 架构

注意，在了解 VSCode Server 的架构之前，我们最好对 VSCode 的组织架构有一定的了解。（详细内容可自行参考 [VSCode 的官方文档](https://github.com/microsoft/vscode/wiki/Source-Code-Organization)。）

从设计上说，VSCode 是一个多进程架构的应用程序，它主要由客户端与服务端 2 个应用程序组成：

1. Web Workbench，即 VSCode 的客户端，此处处理如何与后端建联，解析资源，以及如何渲染编辑区的内容等。
2. 远端服务器，为编辑器提供 webview，terminal，file system，debugger 等服务。

![vscode code artifact](https://github.com/microsoft/vscode/wiki/images/organization/layers2.png)

上图展示的是 VSCode 编辑区及 workbench 的架构，右侧的 code 即为本地客户端启动的入口，server 文件夹则是我们要介绍的重点部分：远程服务端程序的 [entrypoint](https://github.com/microsoft/vscode/tree/main/src/vs/server)。

VSCode Server 与客户端运行的 VSCode 的架构职责区分如下图所示：

![20221009135447](https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009135447.png)

我们可以注意到，VS Code Server 除了负责启动服务的 Running App 进程外，还需要处理如 terminal、debugger、file system、search 等等进程。这些进程都是 VS Code Server 的子进程，它们的生命周期都是由 VS Code Server 管理的。

## Remote File System 实现

Remote File System 负责处理文件系统的读写操作，同时还需要处理文件系统的变化事件，以便于客户端能够实时更新文件系统的变化。

这一部分是 VSCode Server 的核心中最容易实现的部分。它本质上就是使依赖现代浏览器的 [File_System_Access_API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API) 来实现的（强制在 HTTPS 下使用）。

```ts
async function getTheFile() {
  // open file picker
  [fileHandle] = await window.showOpenFilePicker(pickerOpts);

  // get file contents
  const fileData = await fileHandle.getFile();
}
```

具体的代码声明位置见 [FileSystemProvider](https://github.com/microsoft/vscode/blob/dc8bd9cd7e5231745549ac6218266c63271f48cd/src/vs/vscode.d.ts#L7038)。

这里使用 `vscode-vfs` 这个库来实现虚拟文件系统。这是一个 URI 方案，它注册了 `File System Provider`，并且该文件系统上的资源将由使用该模式的 URI 表示（例如`vscode-vfs://vscode/package.json`）。

因此，直接打开远程存储库也得以实现，例如 `Github Codespaces` 的打开就是这样实现的。

使用 `vscode-vfs://github/microsoft/vscode`， 通过访问 `https://github.com/microsoft/vscode`，就能够在不进行 `git clone`的情况下，直接打开项目文件夹了。

实例化后，全局都可以通过传入 `RuntimeEnvironment`，通过 `runtime.fs` 来访问与调用。

```ts
async stat(uri: string): Promise<FileStat> {
    if (fileFs && uri.startsWith('file:')) {
        return fileFs.stat(uri);
    }
    const res = await connection.sendRequest(FsStatRequest.type, uri.toString());
    return res;
}

readDirectory(uri: string): Promise<[string, FileType][]> {
    if (fileFs && uri.startsWith('file:')) {
        return fileFs.readDirectory(uri);
    }
    return connection.sendRequest(FsReadDirRequest.type, uri.toString());
}
```

当然，对于不支持这套 API 的浏览器来说，打开时会检测接口，弹出警告。

![20221009144016](https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009144016.png)

至于解决方式，之前说过，VSCode 的 server 端是同构的，server 自然也能提供本地文件系统支持，仍可以通过浏览器的上传 API 来实现。

## Remote Terminal Process 实现

![20221009181331](https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009181331.png)

## Remote Extension Processes 的实现

### 存储位置

VSCode Server 会将通过 `code-server --install-extension <extension id>` 命令安装的 extensions 存储在 `$XDG_DATA_HOME/code-server/extensions` 下。

用户配置信息存储在本地的`~/.vscode` 下，使用官方的 [Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync) 插件重用配置。

### 插件复用

VSCode 将插件分为了 `UI Extension` 与 `Workspace Extension` 两种，通过 `extensionKind` 字段进行指定。

如果不涉及到 Node.js 调用的简单插件，（例如 Themes、key-binding 等），则可以定义为 `UI Extension`，直接在 client 中运行，直接复用。

这也是为什么 vscode.dev 中，所有的主题、包括例如 TS、Python、Markdown、HTML 等语言的文件补全、语法高亮、括号着色都是可以正常使用的原因。因为在架构上，这些能力都是由 client 端的内置插件提供的，通过 [VSCode API](https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations) 进行调用。

但如果功能涉及到系统级调用，则需要被定义为`Workspace Extension`，它可以完全访问源码、文件系统、以及大部分 `OS API`。需要在插件入口中增加可用的 Node.js entrypoint 相关能力，并自行做好兼容。

## 进程通信与调用方式

### 进程间通信方式

客户端主进程与渲染进程之间则主要通过 `IPC` 进行通信，而客户端与服务器之间则主要通过 `Web Socket` 协议的 `RPC` 调用进行通信。

关于 `IPC` 通信部分，我们去年有进行过源码分析，感兴趣的也可以去看看外网脱敏版本：[VSCode 源码解读--IPC通信机制](https://zhuanlan.zhihu.com/p/195472626)，但这里我们主要介绍前后端间通信的 `RPC` 部分。

目前，VSCode 调用支持两种 `RPC` 通信方式：

1. 直接通过服务端 RPC 通道进行通信，例如 `File System` 与 `Terminal` 的通信都是基于此种模式。
2. 根据不同的浏览器窗口，创建新的远程扩展进程来进行通信，例如插件部分的通信就是基于此种模式。

![rpc](https://img-blog.csdn.net/20150108170924203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

VSCode 的 RPC 通信本质上其实还是 Event Emitter 的那一套事件监听机制来实现的。其客户端调用方式如下所示：

```ts
import * as cp from 'child_process';
import * as rpc from 'vscode-jsonrpc/node';

let childProcess = cp.spawn(...);

// Use stdin and stdout for communication:
let connection = rpc.createMessageConnection(
    new rpc.StreamMessageReader(childProcess.stdout),
    new rpc.StreamMessageWriter(childProcess.stdin));

let notification = new rpc.NotificationType<string, void>('testNotification');

connection.listen();

connection.sendNotification(notification, 'Hello World');
```

服务端调用也采用类似的包装：

```ts
import * as rpc from 'vscode-jsonrpc/node';

let connection = rpc.createMessageConnection(
    new rpc.StreamMessageReader(process.stdin),
    new rpc.StreamMessageWriter(process.stdout));

let notification = new rpc.NotificationType<string, void>('testNotification');
connection.onNotification(notification, (param: string) => {
    console.log(param); // This prints Hello World
});

connection.listen();
```

## FAQ

### 多租户能力支持

![20221009140654](https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20221009140654.png)

这块官方的意思是不想支持了（笑，但我感觉从设计架构上来说并没有什么冲突。

不过需要用到 k8s 管理 server 多实例的话，有些地方我估计可能会成为坑点。VSCode Server 中调用了大量 systemd 之类的系统级调用，需要给每个租户开辟单独的 namespace 做好隔离，普通的 container 可能并不支持，需要有 runtime 能力支持的 container 才行，开源的比如 [sysbox](https://github.com/nestybox/sysbox) 这一类的。需要的话可以进一步调研。

### VSCode Server Feedback

Brigit Murtaugh, VS Code Program Manager @BrigitMurtaugh

Eric Amodio, VS Code Principal Software Engineer @eamodio
