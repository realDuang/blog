---
title: VSCode Server -- 下一代 Serverless 的 Web IDE 服务
date: 2022-09-30 14:41:00
tags:
---

## 背景

众所周知，VSCode 是一个非常优秀的 IDE，它的设计架构已经成为了近些年各家竞相模仿追逐的对象。但是它的体积非常大，而且需要安装在本地，无法直接安装在云端环境中，这就导致了它的使用场景非常有限。

2019 年，微软在 PyCon 2019 大会上发布了 VSCode Remote 插件，支持了远程开发，这个插件的出现，使得 VSCode 成为了一款真正的跨平台 IDE，不再局限于本地开发，可以通过 SSH 连接到远程服务器，然后在远程服务器上开发。

2020 年，Github Codespaces 又将 Web IDE 的进展向前迈进了一步，它允许用户使用云上托管的服务托管来进行开发，而不需要自己搭建服务器，实现了一个全托管的远程开发解决方案。

而现在，微软发布了 private preview 版本的 VS Code Server。这是一个`可私有化的`，可以在`远程`开发机器上运行的独立服务端，它允许用户直接通过 URL，在浏览器中安全地链接到远程开发机，且同时支持了 HTTP 与 Web Socket 协议。在此过程中不需要进行任何前期的 SSH 或 HTTPS 设置。

注：本文基于 VSCode v1.71 版本。

## VSCode Server 架构

注意，在了解 VSCode Server 的架构之前，我们最好对 VSCode 的组织架构有一定的了解。（详细内容可自行参考 [VSCode 的官方文档](https://github.com/microsoft/vscode/wiki/Source-Code-Organization)。）

从设计上说，VSCode 是一个多进程架构的应用程序，它主要由客户端与服务端 2 个应用程序组成：

1. Web Workbench，即 VSCode 的客户端，此处处理如何与后端建联，解析资源，以及如何渲染编辑区的内容等。
2. 远端服务器，为编辑器提供 webview，terminal，file system，debugger 等服务。

[vscode code artifact](https://github.com/microsoft/vscode/wiki/images/organization/layers2.png)

左侧部分展示的是 VSCode 编辑区及 workbench 的架构，右侧的 code 即为客户端启动的入口点，server 文件夹则是我们要介绍的重点部分：远程服务端程序的 [入口点](https://github.com/microsoft/vscode/tree/main/src/vs/server)。

VSCode Server 的架构如下图所示：

![20220930162957](https://zakum-1252497671.cos.ap-guangzhou.myqcloud.com/20220930162957.png)

我们可以注意到，VS Code Server 除了负责启动服务的 Running App 进程外，还需要处理如 terminal、debugger、file system、search 等等进程。这些进程都是 VS Code Server 的子进程，它们的生命周期都是由 VS Code Server 管理的。

## 进程通信与调用方式

## 进程间通信方式

客户端与服务器之间通过 `Web Socket` 协议的 `RPC` 调用进行通信，而客户端主进程与渲染进程之间则主要通过 `IPC` 进行通信。这里我们主要介绍前后端通信的 `RPC` 部分。

目前，VSCode Server 调用支持两种 `RPC` 通信方式：

1. 直接通过服务端 RPC 通道进行通信，例如 `file system` 与 `terminal` 的通信都是基于此种模式。
2. 根据不同的浏览器窗口，创建新的远程扩展进程来进行通信，例如插件部分的通信就是基于此种模式。

![rpc](https://img-blog.csdn.net/20150108170924203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

VSCode 的 RPC 通信本质上其实还是 Event Emitter 的那一套事件监听机制来实现的。其客户端调用方式如下所示：

```ts
import * as cp from 'child_process';
import * as rpc from 'vscode-jsonrpc/node';

let childProcess = cp.spawn(...);

// Use stdin and stdout for communication:
let connection = rpc.createMessageConnection(
    new rpc.StreamMessageReader(childProcess.stdout),
    new rpc.StreamMessageWriter(childProcess.stdin));

let notification = new rpc.NotificationType<string, void>('testNotification');

connection.listen();

connection.sendNotification(notification, 'Hello World');
```

服务端调用也采用类似的包装：

```ts
import * as rpc from 'vscode-jsonrpc/node';

let connection = rpc.createMessageConnection(
    new rpc.StreamMessageReader(process.stdin),
    new rpc.StreamMessageWriter(process.stdout));

let notification = new rpc.NotificationType<string, void>('testNotification');
connection.onNotification(notification, (param: string) => {
    console.log(param); // This prints Hello World
});

connection.listen();
```
