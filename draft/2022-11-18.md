---
title: VSCode For Web 深入浅出 -- 依赖注入设计
date: 2022-11-18 12:23:56
tags:
---

在阅读 VSCode 代码的过程中，我们会发现每一个模块中都有大量装饰器的使用，用来装饰模块以及其中依赖的模块变量。这样做的目的是什么呢？在这一篇中我们来详细分析一下。

## 依赖注入介绍

如果有这样一个模块 A，它的实现依赖另一个模块 B 的能力，那么应该如何设计呢？很简单，我们可以在 A 模块的构造函数中实例化模块 B，这样就可以在模块 A 内部使用模块 B 的能力了。

```ts
class A {
  constructor() {
    this.b = new B();
  }
}

class B {}

const a = new A();
```

但是这样做有两个问题，一是模块 A 的实例化过程中，需要手动实例化模块 B，而且如果模块 B 的依赖关系发生变化，那么也需要修改模块 A 的构造函数，导致代码耦合。

二是在复杂项目中，我们在实例化模块 A 时，难以判断模块 B 是否被其他模块依赖而已经实例化过了，从而可能将模块 B 多次实例化。若模块 B 较重或者需要为单例设计，这将带来性能问题。

因此，更好的方式是，将所有模块的实例化交给外层框架，由框架统一管理模块的实例化过程，这样就可以解决上述两个问题。

```ts
class A {
  constructor(private b: B) {
    this.b = b;
  }
}

class B {}

class C {
  constructor(private a: A, private b: B) {
    this.b = b;
  }
}

const b = new B();
const a = new A(b);
const c = new C(a, b);
```

这种将依赖对象通过外部注入，避免在模块内部实例化依赖的方式，称为依赖注入 (Dependencies Inject, 简称 DI)。这在软件工程中是一种常见的设计模式，我们在 Java 的 Spring，JS 的 Angular，Node 的 NestJS 等框架中都可以看到这种设计模式的应用。

当然，在实际应用中，由于模块众多，依赖复杂，我们很难像上面的例子一样，规划出来每个模块的实例化时机，从而编写模块实例化顺序。并且，许多模块可能并不需要第一时间被创建，需要**按需实例化**，因此，粗暴的统一实例化是不可取的。

因此我们需要一个统一的框架来分析并管理所有模块的实例化过程，这就是依赖注入框架的作用。

借助于 TypeScript 的装饰器能力，VSCode 实现了一个极为轻量化的依赖注入框架。我们可以简单的仿照实现一下基础功能。

## 最简依赖注入框架设计

实现一个依赖注入框架只需要两步，一个是将模块声明并注册到框架中进行管理，另一个是在模块构造函数中，声明所需要依赖的模块有哪些。

我们先来看模块的注册过程，这需要TypeScript的类装饰器能力。我们在注入时，只需要判断模块是否已经注册，如果没有注册，将模块的id（这里简化为模块Class名称）与类型传入即可完成单个模块的注册。

```ts
export function Injectable(): ClassDecorator {
  return (Target: Class): any => {
    if (!injector.providers.has(Target.name)) {
      injector.providers.set(Target.name, new Target());
    }
    return Target;
  };
}
```

```ts
export function Injectable(): ClassDecorator {
  return (target: Class): any => {
    if (!injector.providers.has(name)) {
      injector.providers.set(name, target);
    }
    return target;
  };
}
```

之后我们再来看看模块是如何声明依赖的，这需要TypeScript的属性装饰器能力。我们在注入时，先判断依赖的模块是否已经被实例化，如果没有，则将依赖模块进行实例化，并存入框架中管理。最终返回已经被实例化完成的模块实例。

```ts
export function Inject(): PropertyDecorator {
  return (target: Property, propertyKey: string) => {

    const instance = injector.dependencies.get(propertyKey);
    if (!instance) {
      const Dependency: Class = injector.get(propertyKey);
      injector.dependencies.set(propertyKey, new Dependency());
    }

    target[propertyKey] = injector.dependencies.get(propertyKey);
  };
}
```

最后只需要保证框架本身在项目运行前完成实例化即可。（在例子中表示为 injector）

```ts
export class Injector {
  readonly providers = new Map<string, any>();
  readonly dependencies = new Map<string, any>();
}

const injector = new Injector();
export default injector;
```

这样，一个最简化的依赖注入框架就完成了。由于保存了模块的类型与实例，它实现了模块的按需实例化，无需在项目启动时就初始化所有模块。

我们可以尝试调用它，以上面举出的例子为例：

```ts
@injectable()
class A {
  constructor(@inject() private b: B) {
    this.b = b;
  }
}

@injectable()
class B {}

class C {
  constructor(@inject() private a: A, @inject() private b: B) {
    this.b = b;
  }
}

const c = new C();
```

无需知晓模块A，B的实例化时机，直接初始化任何一个模块，框架会自动帮你找到并实例化好所有依赖的模块。

## 循环依赖问题

模块之间的依赖关系是有可能存在循环依赖的，比如A依赖B，B依赖A。这种情况下进行两个模块的实例化会造成死循环，因此我们需要在框架中加入循环依赖检测机制来进行规避。

本质上，一个健康的模块依赖就是一个有向无环图（DAG），我们之前介绍过有向无环图在excel表格函数中的应用，在依赖注入框架中也同样适用。

我们可以通过深度优先搜索（DFS）来检测模块之间的依赖关系，如果发现存在循环依赖，则抛出异常。

```ts
// 源码位置：src/vs/platform/instantiation/common/instantiationService.ts
while (true) {
  let roots = graph.roots();

  // if there is no more roots but still
  // nodes in the graph we have a cycle
  if (roots.length === 0) {
    if (graph.length !== 0) {
      throwCycleError();
    }
    break;
  }

  for (let root of roots) {
    // create instance and overwrite the service collections
    const instance = this._createInstance(root.data.desc, []);
    this._services.set(root.data.id, instance);
    graph.removeNode(root.data);
  }
}
```

## 总结

完整 demo可见：[https://github.com/realDuang/dependencies-injector-demo](https://github.com/realDuang/dependencies-injector-demo)

当然此处的代码只做演示，实际上VSCode 的依赖注入能力还有很多细节需要处理。例如同模块多实例管理，区分`register`与`registerSingleton`,这需要通过资源描述符创立`Symbol`替换简单粗暴地通过类名注册实例；异步实例化能力，加入Deferred 延迟初始化机制，等等。

这些需要更多的篇幅去介绍，这里就不再展开了。感兴趣的同学可以参考VSCode源码：[src/vs/platform/instantiation/common/instantiationService.ts](src/vs/platform/instantiation/common/instantiationService.ts)
