<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有向无环图的数据模型设计与应用]]></title>
    <url>%2Fposts%2Fadeb%2F</url>
    <content type="text"><![CDATA[从 TodoList 说起对于我们前端开发来说，想要学习一个框架，从开发一个 TodoList 项目做起，这就像学习语言先学会写 Hello world 一样基础。但其实，简单的 TodoList 里面，同样可以蕴含一些复杂的结构。 设想一下，今天需要完成若干个任务，需要规划一下工作流，可以通过 TodoList 记录下来。但与普通的线性工作不同的是，每条工作任务可能会有若干个前置工作，那么现在我们该如何分配工作顺序呢？ 其实这样的事情在我们自己平时的工作中经常遇到，而我们通常的做法是：优先找出不需要做前置工作的任务，将其完成。再寻找剩下的工作任务中，是否有已经将所有前置工作做完的任务，在接下来完成。如此往复，直到所有工作都已经被完成。 事实上，不知不觉中，我们已经悄然构建了一个有向无环图，并对其进行好了拓扑排序，按照拓扑序列的结果执行任务了。 有向无环图与拓扑排序啥啥啥？我怎么不知道？ 你看，每一个任务与它的前置任务之间都存在着一个父子关系。由于每个任务的前置可以有多个，因此使用有向图而不是有向树来表示更为合适。而已经做过的工作不会在被重复做一遍，因此工作流中不可能形成环路，从第一个工作开始，至最后一个工作结束，对于每个任务的执行必定是有且只有一遍的。而这，也就是有向无环图（Directed Acyclic Graph，下称 DAG 图）的定义了： 如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图。 而拓扑序列，实际上指的是一个 DAG 图的所有顶点的线性序列，即将一个二维图展平成一维链的一种表示形式。 并非所有有向图都能生成拓扑序列，我们必须确保该图是不存在环的。 而检查有向图是否存在环的方法，我们可以跟无向图一样，以深度优先遍历的方式查找图，并在遍历时对节点染色，以方便判断该节点是否已被访问过。而其实，我们可以直接使用拓扑排序算法来更直观的进行判断。 拓扑排序的具体方法如下：先统计所有节点的入度，找到一个入度为 0 的节点作为序列的第一个节点，将该点从图中删去，同时删去以该节点为弧尾的所有有向边，并将有向边指向的顶点入度减一，得到一个新图，之后重复以上操作。 举个例子，假设有这样一个 DAG 图，其拓扑排序的算法演示如下： 这样最终得到的拓扑序列为： A -&gt; D -&gt; E -&gt; B -&gt; C 操作结束时，若未删去所有的节点，即出现找不到入度为 0 的节点，则说明剩余的节点形成了一个环路，即该图有环，此时该函数就抛出错误，存在循环引用，终止计算。 DAG 图数据模型设计在了解了 DAG 图的工作原理之后，接下来我们就可以撸起袖子开干了。 为了生成一个稳定的 DAG 图，首先我们需要一个严谨的数据模型作为工程的支撑。我们可以将项目的实现分为控制器与构成单元两个部分： 控制器部分负责 DAG 类整体的信息读取与写入，如查看布局信息，节点生成的拓扑序列，以及具体节点的增删改查等方法并在操作之后维持图的正确性，等等。 构成单元部分则相对简单，负责存放图中的自定义的顶点 node 以及关联关系 edge 的相关信息。 通过对这两部分的数据模型设计，即可描述一个完整的 DAG 图的状态扭转关系以及查改任意一处的数据或关联关系了。于是我们可以设计出一套基础且通用的数据模型，如下图所示： 图结构变化后依赖关系的修复在上节数据模型中提到的 高级 API 对 DAG 图的操作中，都提到了一个子图的修复或重建行为，这也恰恰是这个算法中的难点，值得单独抽出来简要说一说。 当我们增加一个节点时，在设置好所有的邻边关系后，还需要对整图进行一次拓扑排序以排除存在环的可能。当存在环时，增加节点时添加的那条边可能会被弃用，以永远维持依赖图有向无环的稳定性。 当我们删除一个节点时，会使得其该节点所关联的所有入度与出度失效，因此处理这种情况时，应该先去除该节点所有的入度，取消掉对这些节点的监听，并沿着出度染色所有依赖该节点的继任节点，之后更新邻接表。 由于前置节点删除导致这些染色节点无法完成原本的计算，因此也需要将这些染色节点进行清除处理（当然，染色节点是可以根据具体产品策略来判断是否需要保留的，如保留节点但存储的数据结果返回错误）。 觉得比较难以理解的话，我们可以在下节的例子中实践一下。 在 Excel 中依赖图的应用在 Excel 的设计中，函数功能是一个非常重要且难点极多的部分。设计函数功能，其中的难点在于：如何以代价最小的方式获取到该 Excel 函数所有依赖的数据，并能建立起对这些依赖数据的监听机制，在依赖数据更改时触发重算。 而对于这样复杂且频繁的数据变更，显然使用普通处理事件的方式：订阅者模式是不适用的，我们很难及时地进行事件的挂载与清理。 我们知道，在 Excel 表格中，一个单元格，既可以依赖多个单元格的数据，该单元格的运算结果也可以被多个单元格所依赖。并且当单元格之间形成了相互依赖时会报出循环引用 &quot;#REF!&quot; 错误。 经过了之前的介绍，我们很容易想到，函数的依赖关系恰好是符合 DAG 图的特性的，因此我们采用该数据结构来存储表格内所有函数之间的依赖关系，称为表格的依赖图。 依赖图中拥有多个单元格中存储的数据作为图顶点，（当然，在 Excel 中作为顶点的可以是任何依赖图中其它顶点的自定义数据，以下统一称之为数据节点），这些顶点之间存在的依赖关系作为图的边。 当依赖图建立完成以后，我们就能够处理任意一处的数据变更导致所有依赖节点的数据重算了。从变更的节点开始进行拓扑排序，依照生成的拓扑序列依次重算所有继任节点，直到所有相关节点数据都被更新完成。 我们来举一个例子，模拟一下计算机是怎样处理表格的依赖关系的。 假如有如下的一个 Excel 表格： A B 1 1 =A1*A2 2 =A1+1 =SUM(A1, A2)+B1 首先我们来设计一下数据模型，在这个 他的依赖关系是什么样的呢，我们可以很清晰地梳理出来。 再检查一下环，很好，符合DAG图的定义，可以开始计算了。 先进行一次整表的拓扑排序，得到如下结果： A1 -&gt; A2 -&gt; B1 -&gt; SUM函数 -&gt; B2 接下来就可以依次对每个节点进行计算了。由于每个节点计算所需的参数都已经在前置处理中计算完成，因此每一个单元格的结果都是确定的。最终该Excel展现出来的结果如下，这样就帮助Excel完成了一次依赖图建造与首次计算。 A B 1 1 2 2 2 5 我们也可以来试试用户操作对依赖图的影响。我们可以看看把表格的A2单元格删除会发生什么。 按照之前所介绍的，当节点删除时同时也要删去其入度，变成下图这样： 接下来沿着出度对所有继任节点染色，B1单元格、SUM函数进入计算队列。 接下来遍历染色节点，由于这些节点处于依赖条件不满足，无法计算的状态，根据Excel产品的策略，他们返回计算错误结果 #VALUE!。 （如果你在Excel中尝试了这个数据却发现没有出现错误结果，是因为Excel对空值做了默认处理，在数字计算时转化成了0。） 之后更新他们的继任节点，根据拓扑排序结果，B2单元格进入计算队列。由于#VALUE!的结果无法正常参与计算，因此B2单元格也返回#VALUE!。最终Excel展示结果如下： A B 1 1 #VALUE! 2 #VALUE! 至此，Excel的依赖图结构以及数据就完成了一次更新。 写在结尾当然，在 Excel 中真实的依赖图架构的数据模型要比上节所介绍的复杂得多。从节点的种类上，我们可能需要区分单元格节点、范围节点、位置节点、函数节点、甚至各种各样的自定义节点，他们在接收图的变化时都有着不同的行为。在对图的操作上，也会多出来许多情况需要考虑，如行列变更、复制粘贴、数据格式继承等等可能导致依赖图需要重算甚至重构的情况。 这里又可以细讲出很多篇文章，在此就不过多展开了，感兴趣的话可以在上节中基础的数据模型上自行扩展。 在复杂的工程项目架构中，往往存在着大量精妙的算法设计。有向无环图的思路在 Excel 的设计中也只是其中一隅，下次我会介绍更多 Excel 中涉及到的算法思路，帮助大家认识合适的算法思想对复杂问题的解决有多大的帮助。]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个版本自动控制的 IndexedDB]]></title>
    <url>%2Fposts%2F3d6%2F</url>
    <content type="text"><![CDATA[随着现代大型项目复杂度的提升，渲染一个 WEB 页面需要的数据越来越多，在多次打开并渲染的过程中，有许多数据都是重复并且不常更新的，因此这部分的数据需要通过浏览器缓存来缓解网络压力，同时提升页面打开速度。 IndexedDB 的存储方案比较在 IndexedDB 推出以前，浏览器数据的存储方案就已经有了一些实现，例如 cookie，localStorage 等等。 cookie 不用多说，每次都需要随着请求全部带给服务端，并且大小只有可怜的 4KB。cookie 用来做存储数据缓存必然会给网络请求带来更大的压力，因此在该种情况下不是一个合适的载体。 localStorage 作为一个 HTML5 标准，很适合用来做存储数据的本地缓存，并且它能够在不同的标签页之间共享数据，一些网站利用这个特点能够实现一些神奇的操作。它的存储限制比 cookie 要大，根据浏览器的实现不同，大部分浏览器至少支持 5MB - 50MB 的存储。但是，由于 localStorage 的实现与 cookie 类似，存储格式只能为 key-value, 并且 value 只能为 string 类型。因此需要存储复杂类型时，还必须得进行一次 JSON 的序列化转换。于此同时，localStorage 的读写是同步的，会阻塞主线程的执行，因此在存取复杂类型或大数据量的缓存数据时，localStorage 并不是一个很合适的选择。 为了解决 localStorage 存在的上述问题，W3C 提出了浏览器数据库 —— IndexedDB 标准。一个无大小限制的（一般只取决于硬盘容量）、异步的、支持存储任意类型数据的浏览器存储方案。 IndexedDB 的基本概念要学习 IndexedDB 的使用，首先得了解它的一些核心概念。 数据库版本和所有数据库一样，IndexedDB 也有 Database 的概念。每个同源策略下，都可以有多个数据库。 由于 IndexedDB 存在于客户端，数据存储在浏览器中。因此开发人员不能直接访问它。因此 IndexedDB 有一个独特的 scheme 版本控制机制，引申出来数据库版本的概念。同一时间统一数据库只保留唯一且最新的版本，低于此版本的标签页会触发 upgradeneeded 事件升级版本库。修改数据库结构的操作（如增删表、索引等），只能通过升级数据库版本完成。 ObjectStoreIndexedDB 用来存储数据集的单位是 ObjectStore，相当于关系型数据库的表，或是非关系型数据库的集合。 事务事务相当于是一个原子操作，在一个事务中若出现报错，整个事务之中执行的所有功能都不会生效。从而使得数据库能够保证数据一致性，提升业务可靠性。 IndexedDB 的一大特点就是事务化，所有的数据操作都必须被包裹在事务之内执行。IndexedDB 的层级关系为：请求 -&gt; 事务 -&gt; 数据库，我们也可以通过这个关系链来进行错误处理的事件委托，从而集中错误捕获逻辑处理。 IndexedDB API 的原生使用IndexedDB 的 API 较为繁杂，由于并不是本文要讲的重点，在此不展开，对原生 API 感兴趣的可以参考一下 MDN 的文档：https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API。 由于原生 API 的异步过程采用的是监听回调机制，在现代项目中使用起来不是很方便，一般来说推荐使用 Promise 的方式在外部封装一层，更能够贴合现代项目的使用场景。 建立版本自动控制的 IndexedDB解决思路从使用文档中可以知道，IDBFactory.open 方法用于打开一个数据库连接，它通过传入数据库名称以及版本号 version 两个参数，执行以下步骤，并在相应的时期触发指定回调的钩子。 指定数据库已经存在时，等待 versionchange 操作完成。如果数据库已计划删除，那等着删除完成。 如果已有数据库版本高于给定的 version，中止操作并返回 Error。 如果已有数据库版本，且版本低于给定的 version，触发一个 versionchange 操作。 如果数据库不存在，创建指定名称的数据库，将版本号设置为给定版本，如果没有给定版本号，则设置为 1。 创建数据库连接。 从这里可以看出，这个方法兼具了创建数据库与建立数据库连接两个功能，这里与我们常用数据库的操作不太一致，因此使用起来会有些奇怪。 事实上，IndexedDB 的设计初衷及推荐用法是让我们在代码中硬编码 version 这个版本号，从而在触发的 versionchange 事件中根据版本号不同给出确定的响应。 123456789101112const openRequest: IDBOpenDBRequest = this.dbFactory.open(this.dbName, version);openRequest.onupgradeneeded = (e) =&gt; &#123; versionChangeCb(e); if (e.oldVersion &lt; 1) &#123; const objectStore = db.createObjectStore('test_objectStore'); &#125; else if(e.oldVersion === 1) &#123; ... &#125; else &#123; ... &#125;&#125;; 这与我们对熟悉的数据库认知是不一致的。有的时候，我们希望 IndexedDB 只像一个建立在浏览器本地的普通的数据库一样在项目执行时进行任意的增删表操作，并不想关心当前最新的版本号是多少，希望能自动控制版本。 而现有的IndexedDB能力对于这样的使用场景来说就变得非常艰难。因为在不知道当前最新版本号的情况下根本没法打开最新版本的数据库，并且，在不打开数据库得到数据库实例之前也没法获取当前数据库的最新版本！这就形成了一个死结，我们必须在某个本地位置记录下当前数据库的最新版本，以便下次打开表时能够直接读取到。 理清了处理思路，接下来就是具体的实现环节。 本地存取某个数据库的最新版本首先我们需要解决的就是在本地存储版本号的问题。 本地存取的方式有很多，在之前也简单介绍过各种本地存储的解决方案。在这里，考虑到最大的兼容性，使用的是多使用一个版本固定不变的IndexedDB数据库。(这里使用 localStorage 等存储方案也同样合适) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private getDBLatestVersion(dbName: string): Promise&lt;number&gt; &#123; return new Promise(async (resolve, reject) =&gt; &#123; const openRequest: IDBOpenDBRequest = this.dbFactory.open('DBVersion', 1); openRequest.onerror = () =&gt; &#123; reject(INDEXEDDB_ERROR.OPEN_FAILED); &#125;; openRequest.onsuccess = () =&gt; &#123; const db = openRequest.result; const objectStore = db.transaction(['version'], 'readonly').objectStore('version'); const request = objectStore.get(dbName); // 找不到说明应该是新建的数据库 request.onerror = function () &#123; resolve(0); &#125;; request.onsuccess = function () &#123; if (request.result?.version) &#123; resolve(request.result.version); &#125; else &#123; resolve(0); &#125; &#125;; &#125;; openRequest.onupgradeneeded = () =&gt; &#123; const db = openRequest.result; const objectStore = db.createObjectStore('version', &#123; keyPath: 'dbName', &#125;); objectStore.createIndex('dbName', 'dbName', &#123; unique: true &#125;); objectStore.createIndex('version', 'version', &#123; unique: false &#125;); &#125;; &#125;);&#125;private updateDBLatestVersion(dbName: string, newVersion: number) &#123; return new Promise(async (resolve, reject) =&gt; &#123; const openRequest: IDBOpenDBRequest = this.dbFactory.open('DBVersion', 1); openRequest.onerror = () =&gt; &#123; reject(INDEXEDDB_ERROR.OPEN_FAILED); &#125;; openRequest.onsuccess = () =&gt; &#123; const db = openRequest.result; const objectStore = db.transaction(['version'], 'readwrite').objectStore('version'); // 更新数据库版本字段 const updateRequest = objectStore.put(&#123; dbName, version: newVersion &#125;); updateRequest.onerror = reject; updateRequest.onsuccess = resolve; &#125;; openRequest.onupgradeneeded = () =&gt; &#123; const db = openRequest.result; const objectStore = db.createObjectStore('version', &#123; keyPath: 'dbName', &#125;); objectStore.createIndex('dbName', 'dbName', &#123; unique: true &#125;); objectStore.createIndex('version', 'version', &#123; unique: false &#125;); &#125;; &#125;);&#125; 这里使用dbName与version两个字段来对每一个数据库以及其最新版本进行存储映射。这里需要注意的是，若是无法在这里找到该数据库名称，说明应该是数据库在新建过程中，也是正常情况，根据建表方法所需，返回0。 建立数据库连接为了像普通数据库一样操作，首先我们需要拆分IndexedDB.open这个API的建立连接和新增表这两个功能，先来看建连部分。 123456789101112131415161718192021222324252627282930313233343536373839private getDBConnection(version?: number): Promise&lt;IDBDatabase&gt; &#123; if (this.hasDBOpened &amp;&amp; this.db) &#123; return Promise.resolve(this.db); &#125; const openRequest: IDBOpenDBRequest = this.dbFactory.open(this.dbName, version || this.dbVersion); return new Promise((resolve, reject) =&gt; &#123; openRequest.onerror = () =&gt; &#123; this.close(); reject(INDEXEDDB_ERROR.CONNECTION_FAILED); &#125;; openRequest.onblocked = () =&gt; &#123; this.close(); reject(INDEXEDDB_ERROR.CONNECTION_FAILED); &#125;; openRequest.onsuccess = () =&gt; &#123; this.db = openRequest.result; this.hasDBOpened = true; resolve(openRequest.result); &#125;; // 此时会新建一个数据库，不正确的调用 openRequest.onupgradeneeded = () =&gt; &#123; this.close(); reject(INDEXEDDB_ERROR.CONNECTION_FAILED); &#125;; &#125;);&#125;public close() &#123; if (this.db) &#123; this.db.close(); &#125; this.db = null; this.hasDBOpened = false;&#125; 这块逻辑挺好理解，在取得最新版本号后打开数据库，并对高于或低于当前版本的输入均抛出报错。目的是为了确保该方法仅执行打开连接的操作。 断开连接即使用 IDBDatabase.close 方法，并重置标记位即可。 增删表操作新建表的逻辑为，再打开数据库前，先获取到当前数据库的最新版本，并在该基础上+1，这是为了确保触发onupgradeneeded事件，从而在这里进行更新数据库版本与创建新表的操作。 由于版本号是一个 unsigned long long 类型，因此不要使用浮点数来记录它的版本，否则会被强行取整。 1234567891011121314151617181920212223242526272829303132333435public createTable(options: &#123; tableName: string; objectStoreOptions&#125;): Promise&lt;IDBDatabase&gt; &#123; if (this.hasDBOpened) this.close(); const &#123; tableName, createIndexParamsArr, primaryKey &#125; = options; return new Promise(async (resolve, reject) =&gt; &#123; const version = await this.getDBLatestVersion(this.dbName); const newVersion = version + 1; const openRequest: IDBOpenDBRequest = this.dbFactory.open(this.dbName, newVersion); openRequest.onupgradeneeded = () =&gt; &#123; // 版本更新 this.dbVersion = newVersion; this.updateDBLatestVersion(this.dbName, newVersion); db.createObjectStore(tableName, objectStoreOptions); &#125;; openRequest.onsuccess = () =&gt; &#123; this.db = openRequest.result; this.hasDBOpened = true; resolve(openRequest.result); &#125;; openRequest.onerror = () =&gt; &#123; this.close(); reject(INDEXEDDB_ERROR.OPEN_FAILED); &#125;; openRequest.onblocked = () =&gt; &#123; this.close(); &#125;; &#125;);&#125; 删表也是同理 123456789101112131415161718192021222324252627282930public deleteTable(tableName: string): Promise&lt;IDBDatabase&gt; &#123; if (this.hasDBOpened) this.close(); return new Promise(async (resolve, reject) =&gt; &#123; const version = await this.getDBLatestVersion(this.dbName); const newVersion = version + 1; const openRequest: IDBOpenDBRequest = this.dbFactory.open(this.dbName, newVersion); openRequest.onupgradeneeded = () =&gt; &#123; // 版本更新 this.dbVersion = newVersion; this.updateDBLatestVersion(this.dbName, newVersion); const db = openRequest.result; if (db.objectStoreNames.contains(tableName)) &#123; db.deleteObjectStore(tableName); resolve(db); &#125; else &#123; reject(INDEXEDDB_ERROR.CAN_NOT_FIND_TABLE); &#125; &#125;; openRequest.onsuccess = () =&gt; &#123; this.db = openRequest.result; resolve(openRequest.result); &#125;; openRequest.onerror = () =&gt; &#123; this.close(); reject(INDEXEDDB_ERROR.OPEN_FAILED); &#125;; &#125;);&#125; 至此，就能实现一个能够进行自动版本控制的 IndexedDB promise 封装了。 当然，接下来还需要对表的增删改查进行promise化处理，并支持批量增删、索引与主键查询、多条件查询等等，就能封装成一个完整可用的库了。由于跟本次主题无关，就不将代码贴上来了，感兴趣的可以自己实现一下。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>IndexedDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给 JavaScript 插上多线程的翅膀 —— Web Worker 的 Promise 化实践]]></title>
    <url>%2Fposts%2F8625%2F</url>
    <content type="text"><![CDATA[Web Worker 介绍众所周知，JavaScript 这门语言的一大特点就是单线程，即同一时间只能同步处理一件事情，这也是这门语言衍生出的 nodeJS 被后端开发诟病的的一点。 然而，JavaScript 在设计之初，其实是故意被设计成单线程语言的，这是由于它当时的主要用途的决定的。 JavaScript 最初的设计初衷是完成页面与用户的交互，操作 DOM 或者 BOM 元素，此时如果一味地追求效率使用多线程的话，会带来资源抢占，数据同步等等问题，因此必须规定，同一时间只有一个线程能直接操作页面元素，以保证系统的稳定性以及安全性。 尽管如此，但是 JavaScript 并不是只能线性处理任务。JS 拥有消息队列和事件循环机制，通过异步处理消息的能力来实现并发。在高 I/O 型并发事务处理的过程中，由于不需要手动生成与销毁线程以及占用额外管理线程的空间，性能表现及为优异。因此，nodeJS 作为 JavaScript 在服务端的探索者，在处理高并发网络请求的优势极为明显。 尽管 JavaScript 通过异步机制完美解决了高 I/O 性能的问题，但 JavaScript 单线程执行的本质还是没有变的。因此缺点就显而易见了，那就是处理 CPU 密集型的事务时没有办法充分调动现代多核心多线程机器的运算资源。 在现代大型前端项目中，随着代码的复杂程度越来越高，本地的计算型事务也在变得繁重，而运行在单线程下 JavaScript 项目必定会忙于处理计算而无暇顾及用户接下来的频繁操作，造成卡顿等不太好的用户体验，更严重的情况是，当计算型事务过多时还有可能因为资源被占满带来网页无响应的卡死现象。因此，Web 项目的本地多线程运算能力势在必行，由此，Web Worker 应运而生了。 Web Worker 是 HTML5 中推出的标准，官方是这样定义它的： Web Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. 它允许 JavaScript 脚本创建多个线程，从而充分利用 CPU 的多核计算能力，不会阻塞主线程（一般指 UI 渲染线程）的运行。 Web Worker 虽然是 HTML5 标准，但其实早在 2009 年 W3C 就已经提出了草案，因此它的兼容性良好，基本覆盖了所有主流浏览器。 Web Worker 的局限需要注意的是，Web Worker 本质上并没有突破 JavaScript 的单线程的性质。 事实上，Web Worker 脚本中的代码并不能直接操作 DOM 节点，并且不能使用绝大多数 BOM API。它的全局环境是 DedicatedWorkerGlobalScope 而并不是 Window。运行 Worker 的实际上是一个沙箱，跑的是与主线程完全独立 JavaScript 文件。 Worker 做的这些限制，实际上也是为了避免文章开头说过的抢占问题。它更多的使用场景是作为主线程的附属，完成高 CPU 计算型的数据处理，再通过线程间通信将执行结果传回给主线程。在整个过程中，主线程仍然能正常地相应用户操作，从而很好地避免页面的卡顿现象。 Web Worker 的使用新建目前 Web Worker 的浏览器支持已经较为完善，基本上直接传入 Worker 脚本的 URI 并实例化即可使用。 123/* main.js */const worker = new Worker("./worker.js") 通信Worker 与主线程之间的通信只需要各有两个 API：onmessage/addEventListener 与 postMessage 即可完成收发消息的交互。 123456789101112/* main.js */const worker = new Worker("./worker.js");// 主线程发送消息worker.postMessage(&#123; data: 'mainthread send data' &#125;);// 主线程接收消息worker.onmessage = (e) =&gt; &#123; const &#123; data &#125; = e; if (!data) return; console.log(data);&#125; 12345678/* worker.js */// worker 线程接收消息self.addEventListener('message', (e) =&gt; &#123; const &#123; data &#125; = e; if (!data) return; // worker 线程发送消息 self.postMessage(&#123;data: 'worker received data'&#125;)&#125;); 注：Worker 中，this.xxx，self.xxx 与直接使用 xxx，其作用域都指向 worker 的全局变量 DedicatedWorkerGlobalScope，可以互换。 销毁Worker 的销毁方式有两种，既能在内部主动销毁，也能够被主线程通知销毁。 12/* main.js */worker.terminate(); 12/* worker.js */self.close(); 进阶：让通信方式 Promise 化根据上一节，我们已经能够简单地使用 Worker 的 API 来获取浏览器多线程计算的能力，但是它离工程化的应用还缺少了一些易用性，比如我们多数时候需要使用到的异步相应。接下来我们就来做这件事情。 首先我们需要一个异步回调集合 actionHandlerMap，用于存放等待 Worker 响应的 Promise resolve 方法，其 key 值可以用通信中的某一 id 指定（保证其唯一性即可）。接着我们需要封装一下原生的 postMessage 与 onmessage 方法。 我们在原生的 postMessage 发送的信息中加入 id，并将当前的 Promise 的 resolve 方法放入 actionHandlerMap，等待 Worker 返回结果后触发。 对于 onmessage 的监听，在接收到 Worker 发送过来的响应之后，匹配响应的 Promise 并执行 .then() 方法，完成后删除集合中的 Promise resolve 函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* main.js */let fakeId = 0;class MainThreadController &#123; constructor(options) &#123; this.worker = new Worker(options.workerUrl, &#123; name: options.workerName &#125;); // 等待异步回调集合 this.actionHandlerMap = &#123;&#125;; this.worker.onmessage = this.onmessage.bind(this); &#125; onmessage(e) &#123; const &#123; id, response &#125; = e.data; if(!this.actionHandlerMap[id]) return; // 执行相应的 Promise resolve this.actionHandlerMap[id].call(this, response); delete this.actionHandlerMap[id]; &#125; postMessage(action) &#123; // 实际使用中，可以指定或生成一个业务 id 作为 key 值 const id = fakeId++; return new Promise((resolve, reject) =&gt; &#123; const message = &#123; id, ...action, &#125;; this.worker.postMessage(message); this.actionHandlerMap[id] = (response) =&gt; &#123; resolve(response); &#125;; &#125;); &#125;&#125;const mainThreadController = new MainThreadController(&#123; workerUrl: './worker.js', workerName: 'test-worker' &#125;);mainThreadController .postMessage(&#123; actionType: 'asyncCalc', payload: &#123; msg: 'send messages to worker', params: 1 &#125;, &#125;) .then((response) =&gt; console.log('message received from worker: ', response.msg)); 对于 worker 部分的处理就简单得多，计算处理完毕后，在响应回复中带上请求的 id 即可。 1234567891011121314151617181920212223242526272829303132/* worker.js */class WorkerThreadController &#123; constructor() &#123; this.worker = self; // 等待异步回调集合 this.actionHandlerMap = &#123;&#125;; this.worker.onmessage = this.onmessage.bind(this); &#125; async onmessage(e) &#123; const &#123; id, actionType, payload &#125; = e.data; switch (actionType) &#123; case 'print': console.log(payload.msg); self.postMessage(&#123; id, response: &#123; msg: 'msg has been print.' &#125; &#125;); break; case 'asyncCalc': // 构造一个异步处理情形 const result = await new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(payload.params * 2), 1000)); self.postMessage(&#123; id, response: &#123; msg: `the caculated answer is $&#123;result&#125;.` &#125; &#125;); break; default: break; &#125; &#125;&#125;const workerThreadController = new WorkerThreadController(); 当然，worker 这边的改造还能够更进一步。我们发现，当 Worker 需要接收的计算种类增多，使用 switch 方式包裹的 onmessage 函数就会变得冗长，使用字符串判断也不够可靠，我们可以用策略模式简单地封装一下 Worker 中的逻辑。 12345678910111213141516171819202122232425262728293031/* worker.js */// 可以单独抽成一个文件，然后 import 进来const api = &#123; print(payload) &#123; console.log(payload.msg); return &#123; msg: 'msg has been print.' &#125;; &#125;, async asyncCalc(payload) &#123; const result = await new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(payload.params * 2), 1000)); return &#123; msg: `the caculated answer is $&#123;result&#125;.` &#125;; &#125;,&#125;;class WorkerThreadController &#123; constructor() &#123; this.worker = self; // 等待异步回调集合 this.actionHandlerMap = &#123;&#125;; this.worker.onmessage = this.onmessage.bind(this); &#125; async onmessage(e) &#123; const &#123; id, actionType, payload &#125; = e.data; const result = await api[actionType].call(this, payload); self.postMessage(&#123; id, payload: result &#125;); &#125;&#125;const workerThreadController = new WorkerThreadController(); 至此，一个简单好用的 Promise Worker 就建立完成了。 当然，为了增加框架的鲁棒性，我们还应该加入类似于错误处理，报错及监控数据上报等等能力。由于不属于本文探讨的范围，这里就先按住不表，有兴趣的读者可以参看 AlloyTeam 最新开源的 alloy-worker 项目，其中对上述存在的问题进行了全面的补足，是一个较为完善的高可用的 Worker 通信框架。 总结本文对 Web Worker 进行了简要的介绍，包括其能力以及局限性，让读者对 Worker 的使用场景有一个全面的了解。提出了一种封装 Worker 原生 API 使之能被 Promise 化调用的解决方案，并在最后推荐了团队内正在使用的功能完善的成熟解决方案，希望能帮助到近期有兴趣进行 Worker 改造的前端开发者们。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React16.8 useHook 特性]]></title>
    <url>%2Fposts%2F6b60%2F</url>
    <content type="text"><![CDATA[React16.8 迎来了大众期盼已久的函数式编程利器：useHook特性。它能大大增强函数式组件的能力，使得立即执行的、没有生命周期与 state 等等类组件特性的函数式组件拥有相同的能力。 useHook的原理实际上是利用了 JavaScript 的闭包机制，因此在多次执行函数的同时记住一些状态。 useHook拥有多种函数，我们也可以自定义自己的 hook。在这里主要来说说其中最常用的几种，简述他们的大致原理，以及使用时的注意事项。 useStateuseState就是为了给纯函数组件加入 class 组件中的 state 能力。它返回一个有两个元素的数组，第一个元素是需要设置的 state 变量，第二个是改变这个变量的 setter 函数。useState的入参决定了返回变量的初始值。 1const [flag, setFlag] = useState(false) 在每一次执行 setter 之后，使用了useState的整个函数组件都会被重新执行一次。但是此时useState函数本身并不会被再次执行。这是因为实际上，useState利用了闭包的特性，在闭包内设置了一个私有变量。事实上 setter 改变的值是这个私有变量，我们能取出的变量是这个私有变量的 getter 返回值。 注意，只能在函数的最外层调用 Hook，不能在循环、条件判断或子函数中使用。 这是因为，为了支持在同一个函数组件中使用多次useState，在闭包中，被useState的赋值的私有变量本质上是一个数组类型，通过函数首次被调用的useState的顺序来决定被赋值变量的索引位置，最后 getter 通过索引顺序找到希望取得的变量值。若在循环、条件判断或子函数中使用，则有可能造成函数组件重新执行时顺序与首次执行不一致，这将导致useState的取值混乱。 useEffectuseEffect 为纯函数组件提供了 class 组件中的componentDidMount、componentDidUpdate、componentWillUnMount、shouldComponentUpdate这些生命周期能力。 useEffect 接收两个参数，第一个参数是一个函数，在函数中执行的动作相当于在类组件中生命周期中的所需要进行的工作。该函数的返回值也是一个函数，若不为空的话它执行的时机等同于componentWillUnMount。 第二个参数是一个数组，传入的是需要监听变量列表，若填写该值，只有当监听范围内的变量更新时，才执行第一个参数函数中的动作。起到了类似shouldComponentUpdate的作用。当传入空数组时相当于不监听任何变量，只在组件生成时执行一遍，等同于componentDidMount。当传入为空值时相当于监听所有变量，等同于componentDidUpdate。 1234567891011function fetchSth() &#123; /* 执行异步操作 */&#125;function destroySth() &#123; /* 执行 unmount 操作 */&#125;useEffect(() =&gt; &#123; fetchSth() return detroySth()&#125;,[]) useReduceruseReducer事实上与 redux 概念中的reducer十分类似，如果使用过 redux 应该对reducer的概念和定义不会陌生。 它与useState作用场景相似，也能赋予函数组件设定和处理 state 的能力。通常情况下，它们是可以互换的。 但是，对于在组件中存在着多个 state 的定义，或者是操作逻辑复杂需要同时更改多个 state，又或者定义的 state 是一个复杂类型，如数组、对象或存在嵌套，使用useReducer会使得 state 声明更加集中，同时操作逻辑更为清晰，代码也能有更好的可读性。 123456789101112131415161718192021// 第一个参数：应用的初始化const initialState = &#123;count: 0, isDone: false&#125;;// 第二个参数：state 的 reducer 处理函数function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;...initialState, count: state.count + 1, isDone: true&#125;; case 'decrement': return &#123;...initialState, count: state.count - 1, isDone: true&#125;; default: return initialState &#125;&#125;const [state, dispatch] = useReducer(reducer, initialState);// 用法function onIncrementClick() &#123; dispatch(&#123;type: 'increment'&#125;)&#125; useMemo 和 useCallback这两个 API 我拿在一起来说，原因很简单，他们的目标都是一致的，都是缓存结果，只不过useCallback是缓存函数本身，useMemo是缓存函数返回的结果。从这里也可以看出，实际上，useCallback是可以被useMemo通过多包裹一层函数实现的。 这两个 API 的函数签名与 useEffect 基本一致，因此调用方法区别不大。在用法功能上，他们之间区别最大的一点是，useEffect 是处理副作用的，是在 render 函数执行完后执行的，相当于 class 组件的didMount/didUpdate。而这两个 API 不能处理副作用，必须同步调用，即在哪里调用就在哪里立即执行函数内容，在下一行就能直接使用返回的结果。 那么，这两个 API 的使用情景是什么呢？答案是性能优化。我们先来看看需要使用useMemo的情况： 1234567function keywordChangeCompute(keyword) &#123; /* 执行一些非常消耗资源的同步操作 */&#125;const [keyword, setKeyword] = useState('')useMemo(() =&gt; &#123; keywordChangeCompute(keyword)&#125;,[keyword]) 若不使用useMemo而直接将函数调用写在 render 中的话，当外部组件或者该组件的其他 state 进行频繁的更新时，该组件会不断地多次触发keywordChangeCompute函数，造成不必要的性能损失。而对于使用了useMemo来说，只在keyword变化的时候才会触发一次函数调用，这与useEffect的触发机制是一致的。 对于useCallback的使用，有一种情况是非常实用的，即该方法会被传给子组件的情况： 12345678910const [status, setStatus] = useState(false)const onChange = (value) =&gt; &#123; fetch(`/api/get/$&#123;value&#125;/$&#123;status&#125;`)&#125;return ( &lt;&gt; &lt;ChildComponent onChange=&#123;useCallback(onChange，[status])&#125;&gt; &lt;/&gt;) 因为父组件在每一次更新的时候都会生成一个全新的onChange函数，而由于status状态不变，新的onChange函数并没有改变，这样会导致子组件进行一次没必要的更新，造成性能损失。而使用了useCallback后，只会在status状态更新时生成新的函数传给子组件，从而减少子组件渲染次数。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React15 与 React16 生命周期区别与使用方式]]></title>
    <url>%2Fposts%2F1cec%2F</url>
    <content type="text"><![CDATA[为什么要变更生命周期因为 React16 框架使用了全新的Fiber架构，这其中有一个特性叫做async rendering，render 过程可中断，因此，render 函数之前的所有生命周期函数都有可能被多次执行，如果在这些函数中存在异步请求的话将会造成许多无用的请求被调用。 涉及到的生命周期函数一共有 4 个： componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 很多开发者在componentWillMount或是componentWillUpdate里调用请求的原因是期望请求回更新的状态能在 render 之前刷新，但这样是不可能的，无论请求相应速度多快，异步操作的返回逻辑执行都会被安排在下一次 tick 之后，页面还是会被 render 两次。 而在componentWillReceiveProps写同步逻辑也会存在一些问题，如当父组件传入的 props 变更非常频繁的时候，componentWillReceiveProps的调用次数是非常多的，但若是将这些逻辑放入 render 及以后的周期函数中则并不会这样，这是因为 react 进行 setState 的时候是会通过transaction进行合并的，实际 render 的执行次数并不会增多。 因此，从合理性上来说，推荐将异步请求放在componentDidMount里，同步处理逻辑写在 render 中或使用shouldComponentUpdate优化直接省去 render 步骤。为了强制开发者彻底摈弃这样的使用习惯，官方在 React16 中干脆去掉了除了shouldComponentUpdate以外的其他声明周期。 但仍然有开发者需要在 render 之前获取到 props 的更新，因此官方增加了新的生命周期函数getDrivedStateFromProps。它的作用其实与componentWillReceiveProps差不多，但优势在于在多次变更 props 操作的过程中，它与 render 一样，只更新一次。 我画了一张图来清晰地展示 React 新旧生命周期过程的对比： componentWillXX 生命周期函数的替代者首先来看看这个新增引入的生命周期函数： 1static getDrivedStateFromProps(nextProps, prevState): newState || null 在组件创建和更新时都会调用，它能获取到更新的 props 与当前的 state，返回更新后的 state，若不需要进行更新则返回 null。 我们需要注意的是，这个函数一定需要写成 static 的静态函数，这样做的目的是不让开发者在这个函数中拿到 this，因此无法进行setState操作，使之变成一个纯函数。以这样的方式规范了 react 在 render 函数执行之前不做任何更新状态的异步请求。 如何在页面更新后立即获取到更新后的 DOM 信息这就要提到 React16 的另一个生命周期函数： 1getSnapshotBeforeUpdate(prevProps, prevState): any 这个函数的作用时机是 render 函数之后，实际组件更新之前，这个时候组件无法进行更改但可以读取 DOM 中的信息，我们可以在这个阶段获取到如 ref 之类的真实 DOM 数据，并将结果传递给 componentDidUpdate(prevProps, prevState, snapshot) 中的第三个参数，从而在更新后可以根据当前 DOM 的数据进行状态的相应调整。 React16 如何进行错误捕获与处理因为 React 是基于 javascript 的框架，因此组件内部若存在 js 异常，将会阻断一些状态的更新，导致应用崩溃。而一般认为，在 UI 部分发生的异常不应该让整个应用 crash，为此在 React16.0 中，引入了一个新的异常处理捕获的生命周期函数componentDidCatch。 1componentDidCatch(error, info) 它引入了一个新概念：error boundary，错误边界。它是一个内部包含componentDidCatch函数的 React 类组件，它用以捕获在整个子组件树的构造函数以及生命周期函数中的 JS 异常，从而渲染不同的子页面。 注意，由于它本质上还是利用了 React 类的生命周期，因此只能对类组件的错误捕获有效，并且只能对错误边界包裹的子组件（不包括自身）有效。 若没有在错误边界中被 catch 的 JS 错误将导致整个 React 组件被卸载。 与 try/catch 不同的是，错误边界保留了 React 声明式的特性，而前者适用于命令式的代码。并且错误边界能捕获组件树内部底层逻辑导致的错误，如在componentDidUpdate中的setState。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式的 js 实现 (4)--代理模式]]></title>
    <url>%2Fposts%2F34cc%2F</url>
    <content type="text"><![CDATA[介绍代理模式在注重交互体验的前端应用环境中是一个十分重要的思想，有些时候，当调用方不适合直接访问一个对象的时候，代理模式可以提供出来一个替身对象来控制对这个对象的访问，当替身对象对请求做出一些处理后，再转交给目标对象。 根据上述定义，我们可以将代理模式分解为三种类型：虚拟代理、保护代理以及缓存代理。其中缓存代理能够为计算开销大的一些运算函数提供一层缓存，避免重复计算，多用于一些算法优化的实现，本文暂且不论，重点介绍其他两种代理模式在前端项目中的应用。 虚拟代理虚拟代理的应用范围非常广泛，它常用于对创建或使用时开支较大的目标对象进行代理，以达到推迟与减少资源消耗的目的。例如异步请求常用的函数节流、函数防抖、以及懒加载都可以使用此种思想。 我们以实现某图片懒加载来举例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; height: 2000px; &#125; #others &#123; width: 100%; height: 1000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="others"&gt;&lt;/div&gt; &lt;img id="img" /&gt; &lt;script&gt; function lazyloadImage(node, src) &#123; const intersectionObserver = new IntersectionObserver(function(entries) &#123; if (entries[0].isIntersecting) &#123; // 进入 viewport 后加载图片，并解除监听，防止离开 viewport 后再次触发 node.src = src; intersectionObserver.unobserve(node); &#125; &#125;); // 开始监听 intersectionObserver.observe(node); &#125; const imgNode = document.querySelector("#img"); lazyloadImage(imgNode, "https://github.com/realDuang/blog-storage/blob/master/avatar.jpg?raw=true"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 又或者通过代理模式实现函数的防抖： 1234567891011121314151617181920212223242526272829303132333435363738// leading 为是否在进入时立即执行一次const debounce = ( fn, time = 17, options = &#123; leading: true, context: null &#125;) =&gt; &#123; let timer; const _debounce = function(...args) &#123; timer &amp;&amp; clearTimeout(timer); if (options.leading &amp;&amp; !timer) &#123; // 立即执行一次 fn.apply(options.context, args); timer = setTimeout(null, time); &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(options.context, args); timer = null; &#125;, time); &#125; &#125;; return _debounce;&#125;;// 目标对象const scrollFunc = () =&gt; &#123; let scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log("滚动条位置：" + scrollTop); &#125;// 代理对象const proxyScrollFunc = debounce( scrollFunc, 200, &#123; leading: false &#125;);window.onscroll = proxyScrollFunc 保护代理保护代理适用于目标对象安全要求较高，需要鉴权功能时，将所有请求汇聚到代理对象中统一进行授权与控制，再将符合要求的请求转发给目标对象。这种代理解耦了复杂鉴权控制与实际业务处理之间的联系，并且负责鉴权控制的代理模块能做到可复用，从而进一步优化代码架构。 能使用保护代理的情况也有很多，这里以最常见的登录验证为例。（为了更明显体现代理模式的存在，使用了 es6 规范下的 Proxy 对象特性） 1234567891011121314151617181920212223242526272829303132333435function getValidatorProxy(target) &#123; return new Proxy(target, &#123; validator: &#123; account: value =&gt; &#123; const re = /^\d+$/; return &#123; isValid: re.test(value), error: "账号组成必须全为数字", &#125;; &#125;, password: value =&gt; (&#123; isValid: value.length &gt;= 6, error: "密码长度不能小于 6", &#125;), &#125;, set(target, prop, value) &#123; const checkVar = this.validator[prop](value); if (checkVar.isValid) &#123; console.log(`$&#123;prop&#125;参数校验通过`); return Reflect.set(target, prop, value); &#125; console.log(`$&#123;prop&#125;参数校验不通过，错误原因：$&#123;checkVar.error&#125;`); return Reflect.set(target, prop, ""); &#125;, &#125;);&#125;const loginProxy = getValidatorProxy(&#123; account: "", password: "",&#125;);loginProxy.account = "123"; // account 参数校验通过loginProxy.password = "123"; // password 参数校验不通过，错误原因：密码长度不能小于 6console.log(loginProxy); // &#123; account: '123', password: '' &#125;]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式的 js 实现 (3)--观察者模式]]></title>
    <url>%2Fposts%2F8dda%2F</url>
    <content type="text"><![CDATA[介绍在行为型模式中，最值得我们前端学习的设计模式就是观察者模式了，也就是我们熟悉的发布-订阅模式。因为前端与用户侧强交互的需要，我们会对用户操作实现非常多的联动依赖，当页面中某个对象状态改变后，所有依赖其状态的组件都能收到通知，并相应地改变自己的状态。而这也衍生出来一种编程思想–事件驱动编程。 在前端中，这种思想运用的非常广泛。例如 DOM 事件监听，路由变化更新，vue 的事件机制甚至是其双向绑定原理–defineProperty 等等都是基于观察者模式实现的。 基础实现我们可以尝试实现一个观察者模式模型。这个对象至少应该包括：一个记录所有被监听事件的映射对象 subscribersMap（其中每个属性的 value 值都应为一个订阅该事件的所有函数组成的数组 subscriber)、将订阅者添加进相应事件的 subscriber 中的订阅函数、删除某个事件中订阅者的退订函数、发布者发布时广播给所有订阅者的发布函数、以及一个获取某个事件所有订阅者的查询函数组成。简单实现如下： 12345678910111213141516171819202122232425262728293031323334353637const event = &#123; subscribersMap: &#123;&#125;, subscribe: function(eventKey, func) &#123; if (!this.subscribersMap[eventKey]) &#123; this.subscribersMap[eventKey] = []; &#125; this.subscribersMap[eventKey].push(func); &#125;, unSubscribe: function(eventKey, func) &#123; const funcList = this.subscribersMap[eventKey]; if (!funcList) &#123; return false; &#125; if (!func) &#123; delete this.subscribersMap[eventKey]; &#125; else &#123; this.subscribersMap[eventKey] = funcList.filter( subscribeFunc =&gt; subscribeFunc !== func ); &#125; &#125;, publish: function(eventKey, ...args) &#123; const funcList = this.subscribersMap[eventKey]; if (!funcList) &#123; return false; &#125; funcList.forEach(func =&gt; &#123; func.apply(this, args); &#125;); &#125;, getSubscribeFunc: function(eventKey) &#123; return this.subscribersMap[eventKey]; &#125;,&#125;; 12345678910111213const subscribeFunc = answer =&gt; console.log("subscription update:", answer);event.subscribe("addNum", subscribeFunc);console.log(event.getSubscribeFunc("addNum")); // [ [Function: subscribeFunc] ]// 在不相关的组件内function publishFunc(a, b) &#123; const answer = a + b; event.publish("addNum", answer);&#125;publishFunc(1, 2); // subscription update: 3event.unSubscribe("addNum", subscribeFunc);console.log(event.getSubscribeFunc("addNum")); // [] 总结使用观察者模式能够使得两个毫不相关的组件能够产生联动，免去了逐级传递状态信息的麻烦，并且在一对多的联动表现中优势突出。但观察者模式也有其局限性： 由于其影响对象之间的关系过于松散，过度使用观察者模式将导致功能的维护以及调用栈追踪变得困难。 订阅者一旦使用生成订阅后，该函数就会常驻内存运行，在生命周期中并没有销毁操作，过度使用将对系统造成负荷。 由此可以看出，设计模式没有银弹，我们应该正确认识到每一种设计模式带给我们的益处以及它可能为我们的项目带来的风险，在合适的地方使用合适的设计模式来解决问题。]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式的 js 实现 (2)--装饰器模式]]></title>
    <url>%2Fposts%2F948d%2F</url>
    <content type="text"><![CDATA[介绍上一篇中我们提到了装饰器模式，这也是一种非常实用的设计模式，主要的特点是非侵入式，能让组件功能能被更好的解耦和复用，解决了不同组件之间共享某些相同功能的难题。有时候我们并不关心函数的内部实现，仅仅想做功能增强，装饰器模式就能给我们带来良好的可读性的同时，减少我们修改需求的成本。 在 js 中，我们可以构造一个装饰器函数，接收任何一个组件函数，返回一个增强功能的新组件，原组件其他功能不受影响，并且当该增强功能不再使用时，只需要在调用处去除包裹的装饰器函数即可，这样可插拔式的功能体验可使得代码变得简单而优雅。 修饰函数的装饰器实现正是因为装饰器模式带来的种种好处，在 es7 标准中已经正式引入了装饰器特性，标志符为 @。我们可以设定如下情况：设计一个通用型的日志补丁，能够输出组件中某些方法的调用日志的功能，我们可以这样写： 以下代码请务必在支持 es7 的环境下运行，如何使用请自行查阅 babel 相关文档 12345678910111213141516171819class Component &#123; @decorateLog addNum(num1, num2) &#123; return num1 + num2; &#125;&#125;function decorateLog(target, name, descriptor) &#123; return &#123; value: function(...args) &#123; console.log(`$&#123;name&#125;.arguments：`, args); return descriptor.value.apply(this, args); &#125; &#125;;&#125;const comp = new Component();const res = comp.addNum(1, 2);console.log(`answer is:`, res); // addNum.arguments：[1, 2] answer is: 3 不难看出，装饰器函数接收三个参数：被修饰对象，被修饰对象名，以及该对象属性描述符（参考Object.defineProperty中的descriptor属性），返回新的被修饰对象属性描述符。 修饰类的装饰器实现装饰器不仅能被用于修饰类属性，甚至能够直接修饰类本身，增强类功能。这个特性也十分实用。本质上，装饰器的行为就是一个高阶函数，其作用全等于以下用法： 123456function decorator(target) &#123; // ...&#125;class Component &#123;&#125;Component = decorator(Component) || Component; 之前在写 redux 相关的文章时也顺口提到过，connect 这个高阶组件也能够用装饰器模式来实现，使得导出类变得更美观且易读。 这是不使用装饰器的 connect 组件写法，高阶函数显得冗长不易读，export 导出物不够明显与直观。 12class Component extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(Component); 使用装饰器后，写法变成了这样 12@connect(mapStateToProps, mapDispatchToProps)export default class Component extends React.Component &#123;&#125; 我们也参照上述写法，来实现自己的类装饰器。假设这样一种情况，我们需要对每一个类组件增添一个获取作者名的通用方法，那我们可以这样来做： 12345678910111213@decorateAuthorclass Component &#123; // ... 其他属性&#125;function decorateAuthor(target) &#123; target.prototype.getAuthor = () =&gt; &#123; return 'synccheng'; &#125;&#125;const comp = new Component();console.log(comp.getAuthor()) 需要注意的一点的是，在 js 中，装饰器只能用于类和类中的方法，不能用于函数。这是因为，装饰器函数是在编译时执行，而不是在运行时执行。因此，若之间在普通函数中使用会存在函数提升的问题，即先定义函数名称，并不赋值，在被修饰函数声明时只能取到 undefined 的装饰器值，导致调用结果与预期不符。 总而言之，在适当的时机使用装饰器模式能帮我们得到一份优雅、易读、可插拔式的代码体验，使用装饰器模式，不需要深入理解原有的代码逻辑就能直接开发新特性，在对老代码进行功能增强的时候，有着事半功倍的效果。]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式的 js 实现 (1)--单例模式]]></title>
    <url>%2Fposts%2F68b8%2F</url>
    <content type="text"><![CDATA[介绍在所有设计模式中，最基础同时也非常实用的一类就是单例模式了。单例模式，顾名思义，指的是在此种设计模式下，整个系统将只会构建一次实例，接下来每一次的新的生成都视为对第一次生成实例的引用。 其实，单例模式在我们的项目中运用的十分广泛，例如浏览器的全局变量 window 就是一个例子，所有声明的全局变量都要挂靠在 window 下，并且 window 变量只生成一次，全局都能够调用。再比如一些一些需要保持唯一性的组件，例如顶部提示框、对话框、抽屉组件等等，也都可以用单例模式来解决。 基础实现接下来我们尝试着来实现一下单例模式的构造函数。假设我们现在想实现一个单例的顶部提示框组件，简单展示如下： 123456789class Notification &#123; constructor(message = "") &#123; this.message = message; &#125; getMessage() &#123; return this.message; &#125;&#125; 为了实现所需的目标，我们需要为该类增添一个获取单例实例的函数 getInstance。先定义一个标志位记录生成的实例，每次调用时检查，若未实例化则生成一个实例，否则返回之前生成实例的引用。 123456789101112Notification.getInstance = function(...args) &#123; // 若未生成过实例，则实例化该方法，并将实例引用赋值给一个属性，之后返回该属性 if (!Notification.instance) &#123; Notification.instance = new Notification(...args); &#125; return Notification.instance;&#125;;const a = Notification.getInstance();const b = Notification.getInstance();console.log(a === b); // true 这样就实现了这个组件的单例化。 能不能更通用上面这个例子能够实现所需要的目标，但是代码过于耦合，且不方便复用。我们可以考虑使用更通用的方法来实现这一目标。比如我们可以将单例逻辑抽离出来，在原组件外层包裹一个用于生成单例的函数，返回一个功能相同，但拥有单例功能的新组件。 1234567891011121314151617const Singleton = function(Class) &#123; let instance = null; return function(...args) &#123; if (!instance) instance = new Class(...args); return instance; &#125;;&#125;;const SingleNotification = new Singleton(Notification);const a = new SingleNotification("info");const b = new SingleNotification("warning");console.log(b.message); // "info"b.message = "warning";console.log(a.message); // "warning" 这样就实现了单例逻辑与实际功能组件的解耦。这里实际上用到了装饰器模式的一些思想，关于装饰器模式我们留到下一节说。]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 React 高阶组件实现一个面包屑导航]]></title>
    <url>%2Fposts%2F57%2F</url>
    <content type="text"><![CDATA[什么是 React 高阶组件React 高阶组件就是以高阶函数的方式包裹需要修饰的 React 组件，并返回处理完成后的 React 组件。React 高阶组件在 React 生态中使用的非常频繁，比如react-router 中的 withRouter 以及 react-redux 中 connect 等许多 API 都是以这样的方式来实现的。 使用 React 高阶组件的好处在工作中，我们经常会有很多功能相似，组件代码重复的页面需求，通常我们可以通过完全复制一遍代码的方式实现功能，但是这样页面的维护可维护性就会变得极差，需要对每一个页面里的相同组件去做更改。因此，我们可以将其中共同的部分，比如接受相同的查询操作结果、组件外同一的标签包裹等抽离出来，做一个单独的函数，并传入不同的业务组件作为子组件参数，而这个函数不会修改子组件，只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数，从而我们能够在不改变这些组件逻辑的情况下将这部分代码解耦，提升代码可维护性。 自己动手实现一个高阶组件前端项目里，带链接指向的面包屑导航十分常用，但由于面包屑导航需要手动维护一个所有目录路径与目录名映射的数组，而这里所有的数据我们都能从 react-router 的路由表中取得，因此我们可以从这里入手，实现一个面包屑导航的高阶组件。 首先我们看看我们的路由表提供的数据以及目标面包屑组件所需要的数据： 1234567891011121314151617181920212223242526272829303132333435363738394041// 这里展示的是 react-router4 的route示例let routes = [ &#123; breadcrumb: '一级目录', path: '/a', component: require('../a/index.js').default, items: [ &#123; breadcrumb: '二级目录', path: '/a/b', component: require('../a/b/index.js').default, items: [ &#123; breadcrumb: '三级目录1', path: '/a/b/c1', component: require('../a/b/c1/index.js').default, exact: true, &#125;, &#123; breadcrumb: '三级目录2', path: '/a/b/c2', component: require('../a/b/c2/index.js').default, exact: true, &#125;, &#125; ] &#125;]// 理想中的面包屑组件// 展示格式为 a / b / c1 并都附上链接const BreadcrumbsComponent = (&#123; breadcrumbs &#125;) =&gt; ( &lt;div&gt; &#123;breadcrumbs.map((breadcrumb, index) =&gt; ( &lt;span key=&#123;breadcrumb.props.path&#125;&gt; &lt;link to=&#123;breadcrumb.props.path&#125;&gt;&#123;breadcrumb&#125;&lt;/link&gt; &#123;index &lt; breadcrumbs.length - 1 &amp;&amp; &lt;i&gt; / &lt;/i&gt;&#125; &lt;/span&gt; ))&#125; &lt;/div&gt;); 这里我们可以看到，面包屑组件需要提供的数据一共有三种，一种是当前页面的路径，一种是面包屑所带的文字，一种是该面包屑的导航链接指向。 其中第一种我们可以通过 react-router 提供的 withRouter 高阶组件包裹，可使子组件获取到当前页面的 location 属性，从而获取页面路径。 后两种需要我们对 routes 进行操作，首先将 routes 提供的数据扁平化成面包屑导航需要的格式，我们可以使用一个函数来实现它。 12345678910/** * 以递归的方式展平react router数组 */const flattenRoutes = arr =&gt; arr.reduce(function(prev, item) &#123; prev.push(item); return prev.concat( Array.isArray(item.items) ? flattenRoutes(item.items) : item ); &#125;, []); 之后将展平的目录路径映射与当前页面路径一同放入处理函数，生成面包屑导航结构。 1234567891011121314151617181920212223242526export const getBreadcrumbs = (&#123; flattenRoutes, location &#125;) =&gt; &#123; // 初始化匹配数组match let matches = []; location.pathname // 取得路径名，然后将路径分割成每一路由部分. .split('?')[0] .split('/') // 对每一部分执行一次调用`getBreadcrumb()`的reduce. .reduce((prev, curSection) =&gt; &#123; // 将最后一个路由部分与当前部分合并，比如当路径为 `/x/xx/xxx` 时，pathSection分别检查 `/x` `/x/xx` `/x/xx/xxx` 的匹配，并分别生成面包屑 const pathSection = `$&#123;prev&#125;/$&#123;curSection&#125;`; const breadcrumb = getBreadcrumb(&#123; flattenRoutes, curSection, pathSection, &#125;); // 将面包屑导入到matches数组中 matches.push(breadcrumb); // 传递给下一次reduce的路径部分 return pathSection; &#125;); return matches;&#125;; 然后对于每一个面包屑路径部分，生成目录名称并附上指向对应路由位置的链接属性。 12345678910111213141516171819202122232425262728const getBreadcrumb = (&#123; flattenRoutes, curSection, pathSection &#125;) =&gt; &#123; const matchRoute = flattenRoutes.find(ele =&gt; &#123; const &#123; breadcrumb, path &#125; = ele; if (!breadcrumb || !path) &#123; throw new Error( 'Router中的每一个route必须包含 `path` 以及 `breadcrumb` 属性' ); &#125; // 查找是否有匹配 // exact 为 react router4 的属性，用于精确匹配路由 return matchPath(pathSection, &#123; path, exact: true &#125;); &#125;); // 返回breadcrumb的值，没有就返回原匹配子路径名 if (matchRoute) &#123; return render(&#123; content: matchRoute.breadcrumb || curSection, path: matchRoute.path, &#125;); &#125; // 对于routes表中不存在的路径 // 根目录默认名称为首页. return render(&#123; content: pathSection === '/' ? '首页' : curSection, path: pathSection, &#125;);&#125;; 之后由 render 函数生成最后的单个面包屑导航样式。单个面包屑组件需要为 render 函数提供该面包屑指向的路径 path, 以及该面包屑内容映射content 这两个 props。 12345678910/** * */const render = (&#123; content, path &#125;) =&gt; &#123; const componentProps = &#123; path &#125;; if (typeof content === 'function') &#123; return &lt;content &#123;...componentProps&#125; /&gt;; &#125; return &lt;span &#123;...componentProps&#125;&gt;&#123;content&#125;&lt;/span&gt;;&#125;; 有了这些功能函数，我们就能实现一个能为包裹组件传入当前所在路径以及路由属性的 React 高阶组件了。传入一个组件，返回一个新的相同的组件结构，这样便不会对组件外的任何功能与操作造成破坏。 123456789101112131415const BreadcrumbsHoc = ( location = window.location, routes = []) =&gt; Component =&gt; &#123; const BreadComponent = ( &lt;Component breadcrumbs=&#123;getBreadcrumbs(&#123; flattenRoutes: flattenRoutes(routes), location, &#125;)&#125; /&gt; ); return BreadComponent;&#125;;export default BreadcrumbsHoc; 调用这个高阶组件的方法也非常简单，只需要传入当前所在路径以及整个 react router 生成的 routes 属性即可。至于如何取得当前所在路径，我们可以利用 react router 提供的 withRouter 函数，如何使用请自行查阅相关文档。值得一提的是，withRouter 本身就是一个高阶组件，能为包裹组件提供包括 location 属性在内的若干路由属性。所以这个 API 也能作为学习高阶组件一个很好的参考。 123withRouter((&#123; location &#125;) =&gt; BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)); Q&amp;A如果react router 生成的 routes 不是由自己手动维护的，甚至都没有存在本地，而是通过请求拉取到的，存储在 redux 里，通过 react-redux 提供的 connect 高阶函数包裹时，路由发生变化时并不会导致该面包屑组件更新。使用方法如下： 1234567891011function mapStateToProps(state) &#123; return &#123; routes: state.routes, &#125;;&#125;connect(mapStateToProps)( withRouter((&#123; location &#125;) =&gt; BreadcrumbsHoc(location, routes)(BreadcrumbsComponent) )); 这其实是 connect 函数的一个bug。因为 react-redux 的 connect 高阶组件会为传入的参数组件实现 shouldComponentUpdate 这个钩子函数，导致只有 prop 发生变化时才触发更新相关的生命周期函数(含 render)，而很显然，我们的 location 对象并没有作为 prop 传入该参数组件。 官方推荐的做法是使用 withRouter 来包裹 connect 的 return value，即 12345withRouter( connect(mapStateToProps)((&#123; location, routes &#125;) =&gt; BreadcrumbsHoc(location, routes)(BreadcrumbsComponent) )); 其实我们从这里也可以看出，高阶组件同高阶函数一样，不会对组件的类型造成任何更改，因此高阶组件就如同链式调用一样，可以任意多层包裹来给组件传入不同的属性，在正常情况下也可以随意调换位置，在使用上非常的灵活。这种可插拔特性使得高阶组件非常受 React 生态的青睐，很多开源库里都能看到这种特性的影子，有空也可以都拿出来分析一下。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 的垂直居中方法]]></title>
    <url>%2Fposts%2Fb04a%2F</url>
    <content type="text"><![CDATA[CSS 是每一个前端工程师都绕不过去的坎，熟练运用 CSS 后，实现同样一种效果我们可以有很多种写法，但由于兼容问题，通常简洁的写法并不能实现全平台统一效果，复杂的写法对性能又不太友好，导致我们在编写 CSS 过程中有很多需要注意的点，要踩很多的坑，因此用一个笔记来集中记录一下方法。 （为方便表达代码，在此定义 html 结构为： 123&lt;div class="parent"&gt; &lt;div class="target"&gt;&lt;/div&gt;&lt;/div&gt; 默认的 css 样式为： 12345678910.parent &#123; background-color: #ccc; width: 100%; height: 400px;&#125;.target &#123; background-color: #333; width: 25%; height: 100px;&#125; 行内元素 html 结构改为： 123&lt;div class="parent"&gt; &lt;label class="target"&gt;Duang&lt;/label&gt;&lt;/div&gt; css 样式改为： 1234.target &#123; background-color: #eee; font-size: 25px;&#125; 以下无特殊说明的话结构都使用这个。 水平居中1. 行内元素只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加 text-align:center 即可： 123.parent &#123; text-align: center;&#125; 2. 块状元素对于块状元素来说，我们需要将它的左右外边距（即，margin-left，margin-right）设置为 auto，即可实现块状元素的居中，如下： 123.target &#123; margin: 0 auto;&#125; 垂直居中1. 行内元素单行居中对于单行行内元素来说，垂直居中就是设定父元素行高等于其块状元素高度。 123456.parent &#123; line-height: 400px;&#125;.target &#123; display: inline-block;&#125; 2. 行内元素多行居中这个使用的手段是比较复杂的，我这里组合使用 display:table-cell 和 vertical-align:middle 属性来定义需要居中的元素的父容器元素，但是缺点有很多，比如这里因为格式变成了 table 类型，宽高必须设置成定值才行，希望有大佬提出更好的解决方法。 12345.parent &#123; display: table-cell; width: 400px; vertical-align:middle;&#125; 水平垂直居中这里的方法同样适用于仅水平或者仅垂直居中。取与之相关的居中代码即可。 1. 最通用且实用的首选方法在不知道自己高度和父容器高度的情况下，给父元素设置相对定位，子元素绝对定位，然后按照向右向下偏移的办法移到中心位置即可。 这里绝对定位的好处是无论父元素的实际高度以及子元素的个数，都能够完成覆盖型的居中显示。 代码示例如下： 123456789.parent &#123; position: relative;&#125;.target &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; （注：其实这里可以不用知道父子元素高度，为了方便显示才使用） 2. 已知父元素的高度，并且子元素有且只有一个如果已知父元素的高度，并且子元素有且只有一个的话，完全可以只对子元素使用相对定位完成同样的效果： 123456.target &#123; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 3. 多个子元素自适应的同时水平垂直居中如果想实现多个子元素自适应的同时水平垂直居中，同时浏览器兼容性也支持的不错的话，推荐使用简单方便的 flex 布局。仅仅只设定父元素 display 属性为 flex 即可。 12345.parent &#123; display: flex; align-items: center; justify-content: center;&#125; 4. table-cell 方式附加一个兼容性更好但是不太推荐的方法，就是由刚才多行行内元素垂直居中衍生出来的，再加一行行内水平居中的代码就能解决了。 123456.parent &#123; display: table-cell; width: 400px; vertical-align:middle; text-align: center;&#125; 不太推荐的原因同垂直居中时说的。 而且想实现这个效果还不如直接用一个块状元素包裹这些行内元素，然后再用块状元素的水平垂直居中即可，当然显示方式可能会有少许的不同，自己斟酌使用吧~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用命令笔记]]></title>
    <url>%2Fposts%2Fb608%2F</url>
    <content type="text"><![CDATA[git 是现如今最火的版本控制工具，尽管已经使用了 GitHub 数年的时间了，但一直没有对 git 命令以及作用进行深入的分析和学习，对 git 的使用还仅停留在 add、commit、push、clone 上，这根本算不得掌握 git。因此，这次一得出空来就开始从头恶补 git 知识了，分享出来与大家一同学习进步。 文件指针 git log 可以查看历次提交信息，其中就有每一次提交的 hash 值，这对每一次提交都是唯一的文件指针。hash 可以用短 hash 值表示，只需要在 git log 后加上–abbrev-commit 参数即可。 HEAD 是一个特殊的文件指针，它指向当前工作区版本的位置。 ^和~的意思都是指向该版本的父提交，如 HEAD^与 HEAD~其实是等价的，但是~2 与^^等价，与^2 不等价，^2 指的是该版本的第二个父提交版本（因为在 merge 过后一个文件版本会有多个父版本）。 文件版本控制操作 git add &lt; file &gt; // 将文件的修改从工作区添加至暂存区 (staged) git rm &lt; file &gt; // 将删除文件这样一个修改操作提交到暂存区 git commit // 将暂存区的所有修改提交入库 -m 参数 填写提交内容的说明。 –amend 表示回退最近一次 commit 重新编写内容说明。 -a 相当于自动做了一次git add .操作。 git checkout – &lt; file &gt; checkout 命令有两种作用，后面加上 – （注意两边都有空格，是一个独立参数）后的意思是，将文件同步成版本库中最新的状态。相当于取消当前工作区的所有更改。但是这个操作不会影响暂存区 (staged) 中的内容。 这对本地已经删除但还没有 git rm 的文件同样适用，能够恢复本地工作区的文件。需要注意的是，此操作不可逆，工作区的修改中的文件内容将无法恢复。 但如果要修改的文件已经在暂存区的话，无论是 git add 还是 git rm，就只能通过 git reset 恢复了，接下来介绍。 git checkout 的另外一种意思在下面介绍。 更新：git2.23 新增语法糖git restore命令，更语义化的本地修改撤销操作。 git restore &lt; file &gt; 作用效果与git checkout -- &lt; file &gt;相同，都是表示将工作区的修改全部取消。 而若加入–staged 参数，则是表示将缓存区的文件撤销回工作区的意思，等价于git reset HEAD。 git reset &lt; hash &gt; 这是个功能及其强大也及其复杂的命令。它表示在本地库回滚状态。 它主要有三种参数，分别代表三种不同效果的回滚。 –hard，是 git 中少有的几个会丢失信息的操作，它代表将该版本库中的内容强制覆盖本地文件，使得暂存区和工作区的状态强制与该版本同步。该操作不可逆，会使得你正在工作区和暂存区的文件修改完全丢失。不仅如此，被你回退之前的版本将会剔除出提交树中，不会显示在版本控制信息里，版本将无法回溯。因此慎用！非要使用的话最好先 git stash 缓存一下。 还有一种用法，如果我们希望彻底丢掉本地修改但是又希望保留当前 branch 所指向的版本的话，直接 git reset –hard HEAD 即可。 （当然，非要找回还是有办法的，使用 git reflog 查找那个版本的 hash 再 git reset 回来即可） –soft，它使得文件的状态与 HEAD 指针都回退到指定版本的位置，并且同时，当前处于工作区和暂存区的文件都不会做任何更改。所有的在 HEAD 节点和你重置到的那个版本之间的所有变更集都放在暂存区中。 –mixed，为 git reset 的默认参数，混合了–hard 与–soft 的特点，它也将文件的状态与 HEAD 指针都回退到指定版本的位置，但只将暂存区与该版本强制同步，工作区的内容不会被更改。并且它也不会剔除 git stash // 修改代码的临时存储 对于还没有 commit 但是被 git 跟踪到了的代码，如果需要临时存储一下可以使用git stash命令，会建立一个栈来存储当前的修改代码。 需要恢复时，可以使用git stash pop恢复最后一次临时存储的代码。若想恢复其他时间存储过的代码，使用git stash list查看所有被临时存储了的代码，然后找到某一次存储的 stash id，然后使用git stash drop stash@&lt; id &gt;来进行恢复。 加入–include-untracked 参数可以存储未被加入 git 跟踪的代码。 使用git stash clear删除所有被临时存储的 stash 记录。 git merge &lt; branch &gt; // 将该分支合并进当前分支 这里的 merge 分fast-forward和recursive等模式，但 git 都能自动匹配最佳方案，就不提了。 要注意的是，合并过程中可能产生文件冲突。这时，当前分支会变为名叫&lt;branch&gt;|MERGING的临时分支，需要手动解决后，使用git merge --continue，才能产生新的合并提交。若要取消这次合并，使用git merge --abort即可。 git rebase &lt; hash &gt; // 分支历史的变基 这个命令是在不希望产生合并的分支历史的特殊要求下使用的，对清理出一条干净的 git 提交线非常有帮助。 加入-i 参数增加分布操作，能够使操作图形化，推荐使用时添加。 命令参数： p, pick &lt;提交&gt; = 使用提交 r, reword &lt;提交&gt; = 使用提交，但修改提交说明 e, edit &lt;提交&gt; = 使用提交，进入 shell 以便进行提交修补 s, squash &lt;提交&gt; = 使用提交，但融合到前一个提交 f, fixup &lt;提交&gt; = 类似于 “squash”，但丢弃提交说明日志 x, exec &lt;命令&gt; = 使用 shell 运行命令（此行剩余部分） b, break = 在此处停止（使用 ‘git rebase –continue’ 继续变基） d, drop &lt;提交&gt; = 删除提交 l, label &lt; label &gt; = 为当前 HEAD 打上标记 t, reset &lt; label &gt; = 重置 HEAD 到该标记 m, merge [-C &lt; commit &gt; | -c &lt; commit &gt;] &lt; label &gt; [# &lt; oneline &gt;] 创建一个合并提交，并使用原始的合并提交说明 git push &lt; remote &gt; &lt; branch &gt; // 将本地某个分支的更新推送到远程 其中本地分支名可以与远程分支名不同步，将&lt; branch &gt;部分改写为&lt;本地分支名&gt;:&lt;远程分支名&gt;即可。 这里还有一个特殊操作，如果不指定本地分支名，像是:&lt;远程分支名&gt;这样，表示删除该远程分支。 比较常用的参数如下： -u，指定当前推送的主机为默认主机，这样后面就可以不加任何参数使用git push。不带任何参数的git push，默认只推送当前分支。 -d 或–delete，删除该远程主机的该分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 -f 或–force，当你需要提交一个有文件冲突的版本，需要本地强制覆盖远程时，使用这个参数，它将在远程主机产生一个”非直进式”的合并 (non-fast-forward merge)。 –all，不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机。 –tags，推送时将本地的 tags 标签也推送上去（默认不推送）。 git pull &lt; remote &gt; &lt; branch &gt; // 取回远程主机某个分支的更新。 功能相当于同时执行了git fetch与git merge。参数大致与git push相同，就不多做介绍了。 git revert &lt; hash &gt; // 分支的回滚操作 与git reset的区别在于 revert 不会更改或删除原有的提交记录，反而会生成一条新的提交。对于线上代码或者多人使用的回滚来说一定要使用 revert 而不是 reset，尽量不要修改多人合作分支的时间线。 加入-n 参数能将多次回滚，合并成一次 commit。如果不加-n，回滚了多少条 commit 就会新生成多少条 commit。 状态信息查看操作 git remote // 列出所有远程主机。 -v选项，可以参看远程主机的网址。 git remote add &lt;主机名&gt; &lt; git 地址 &gt;，添加远程主机。 git remote rm &lt;主机名&gt;，删除远程主机。 git branch // 查看该版本的所有分支 默认只查看本地分支。-r选项，可以用来查看远程分支，-a选项查看所有分支。 git branch &lt; branch &gt; 表示新建分支。（若分支已存在，则报错。） git checkout &lt; branch &gt; 又是这个命令，但是注意，这一次没有--命令，它表示将工作区跳转到该分支上。 若不存在该分支，可以使用-b参数新建该分支并跳转到该分支上。 git status // 查看当前的工作区和暂存区文件修改 git reflog // 查看该分支的历史提交记录 到目前我发现它最有用的地方就是记录了我git reset --hard之前的版本 hash，可以让我恢复版本。 git log // 查看该分支的提交记录 如果跟我一样不太喜欢用 gitk 这样的 GUI 的话，我提供几个常用参数作参考。参数对 gitk 也适用。 –oneline 给我的感觉相当于–pretty=oneline 与–abbrev-commit 的结合，只显示提交 ID 和提交信息的第一行。 –all 显示所有分支的信息。 –decorate 标记让 git log 显示指向这个提交的所有引用（比如说分支、标签等）。 –graph 选项绘制一个 ASCII 图像来展示提交历史的分支结构。 -[number]，表示只显示最后提交的若干列信息。 gitk // git log 的图形化界面版本]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 原理深入 (1)--virtual DOM]]></title>
    <url>%2Fposts%2F6bab%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。想要用好 react 这个前端 View 层大杀器，深入理解其工作原理必不可少。理解一个框架是如何让某种操作得到优化的至关重要，知其然也要知其所以然，它有助于我们对这个框架的正确高效的使用，这是一个前端工程师成长的必经路程。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 深入理解 (4)]]></title>
    <url>%2Fposts%2F2db7%2F</url>
    <content type="text"><![CDATA[这一节主要来讲讲 Redux 在 React 项目中的具体使用。 将学的新知识新组件集成进项目里是初学者最大的障碍，这也是我最初学习 Redux 的时候很难有进展的原因。Redux 的源码体积很小，加起来连 1k 行都不到，利用的原理在之前已经说过，也很好理解，但由于 Redux 只是 Flux 对 React 的一种优化，但并不只是服务于 React，如果你愿意，在 Vue 中使用 Redux 也是完全可行的，毕竟状态管理的思想还是不会变的嘛。 因此我们需要一个 Redux 与 React 之间的连接件来方便我们的搭建，这就是React-redux。也是我们将 Redux 合并进 React 最后也是最大的难点。 React-redux的总体思想 React-redux 将所有组件分成两大类：UI 组件和容器组件。 UI 组件和容器组件的定义很好理解。 UI 组件不负责任何的交互逻辑，只负责展示，类比于纯函数，它是一个“纯组件”。不应该有自己定义的 state，所有的状态和事件动作应全由上层的 props 获取。 容器组件则跟 UI 组件相反，可以有自己的状态，能处理业务交互逻辑。 React-redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 这个思想完美的解决了逻辑数据处理与 UI 界面耦合的问题，让程序的思路更清晰，极大地提高开发与调试效率，这也是为什么越大型的项目越需要使用这样的状态管理组件的根本原因。 之后我们来看看React-redux几个主要的功能方法： &lt;Provider store={store}&gt;&lt;app&gt;&lt;/app&gt;&lt;/Provider&gt;作为一个全局状态管理组件，我们首先应该想到的就是状态的传递。 最简单的想法是从应用的最外层传入当前的 state 状态，之后在接下来的每一层中层层 props 传递。但是这样做太麻烦了，而且很容易让传入状态难以维护，比如你要删去一个状态，就必须把这个组件下的所有子组件使用到这个状态的删除，不然就会报错。 我在 Redux 深入理解（一） 里面悄悄的提到了一个东西：context，也就是上下文，它可以实现祖先与后台之间的状态直接传值。这个特性被React-redux利用了，放入了 Provider 组件中。 Provider组件直接包裹在需要调用全局 store 的根组件的外层，然后传入属性 store，即可在该根组件的任何后代组件中直接拿到 state 数据了。 如果你的项目还需要用到 React-router 的话，Provider 组件应包裹在 router 组件的外层。 12345&lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/Router&gt;&lt;/Provider&gt; connect(mapStateToProps, mapDispatchToProps)(App)之前说过，React-redux希望用户只编写 UI 组件而不用注意状态管理，容器组件则是由 React-redux 自动生成，那么生成的方法就是connect()方法，我们用它将外层的状态以 props 的方式传入进 UI 组件。 connect()方法接受两个参数，mapStateToProps用于传递 state，mapDispatchToProps用于传递 UI 组件需要调用的 store.dispatch 中的方法。 mapStateToProps(state, ownProps)mapStateToProps是一个函数，它接受state作为参数，返回一个对象。 12345const mapStateToProps = (state) =&gt; &#123; return &#123; name: state.name &#125;&#125; 对象的键名代表 UI 组件的 props 中的同名参数，键值为你希望传入的处理过后的值。 mapStateToProps会订阅 Store，每当state更新的时候，就会重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。 至于mapStateToProps的第二个参数ownProps是可选的，为该容器组件自身的 props，传入后若容器组件自身的 props 被改变同样会触发 UI 组件的重新渲染。 mapDispatchToProps()mapDispatchToProps可以是一个函数，也可以是一个对象。它定义了 UI 组件中的一些操作能够发出 action，被 store 响应。 当mapDispatchToProps作为对象时，结构与mapStateToProps类似。它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，这个函数我们之前提到过，叫做actionCreator ，它返回的 action 会由 Redux 自动发出。 1234567891011const mapDispatchToProps = &#123; onClick: (e) =&gt; &#123; const action = &#123; type: 'SET_CURRENT_TARGET', payload: &#123; target: e.target &#125; &#125; return action &#125;;&#125; 当mapDispatchToProps是一个函数时，可以传入dispatch和ownProps（容器组件的props对象）两个参数。返回值仍然一个对象，该对象的每个键值对事实上都是一个映射，定义了 UI 组件的这个键名参数应该怎样 dispatch，发出 action。 123456789101112const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_CURRENT_TARGET', payload: &#123; target: e.target &#125; &#125;); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 深入理解 (3)]]></title>
    <url>%2Fposts%2F1db5%2F</url>
    <content type="text"><![CDATA[上一节说到，reducer 是一个纯函数。那么纯函数具体的定义是什么呢？阮一峰老师是这样说的： 纯函数是函数式编程的概念，必须遵守以下一些约束。 不得改写参数 不能调用系统 I/O 的 API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 我们知道，处理业务逻辑的过程中不可避免的要用到异步操作，而 reducer 是一个纯函数，无法完成这项使命，那怎么办呢？ 这又是一个非常复杂的故事了。 首先我想到的是，action不是由actionCreator函数生成的吗？我们可以在actionCreator函数里面进行异步操作，返回不同的payload，问题不就解决了吗？但是问题又来了，之前说过，reducer 不能接收一个函数作为参数传入啊。 事实上，著名的中间件redux-thunk就是处理这样的问题的，使得actionCreator方法能接受一个返回 action 对象的函数作为返回值。 那么这里就引入了一个中间件的概念。中间件实际上就是用来修饰 reducer 操作，增强 reducer 函数功能的。 我们来看看 redux 中间件是怎么运作的： 若 reducer 涉及到异步操作，则必须使用中间件。创建 store 时使用applyMiddleware(middleware)(createStore)(reducer, initialState)来创建 store 这看起来实在是太绕了…… 实际上，我们可以将applyMiddleware(middleware)看成一个修饰器，用来修饰createStore(reducer, initialState)函数。是不是看明白了一点？ 因此，这个函数我们也能写成这样： 12345const store = createStore( reducer, initial_state, applyMiddleware(middleware)); 将applyMiddleware(middleware)作为createStore的最后一个参数传入，现在是不是好理解多了？ 另外，中间件的传入是有顺序讲究的，涉及到执行顺序的问题，通过 redux 中applyMiddleware的源码中可以看出，applyMiddleware(middleware1，middleware2，middleware3)的实际执行顺序为store.dispatch=&gt;middleware1=&gt;middleware2=&gt;middleware3。这一点一定要非常小心，比如著名的 redux-logger 中间件是用来记录操作日志的，一定要放在最后一个参数中以便第一时间执行。 redux 中间件的各种组件可谓是博大精深，有各种各样好用的中间件让人去探索学习，本文着重讲解 redux 本身的原理，对中间件插件就不多做介绍了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 深入理解 (2)]]></title>
    <url>%2Fposts%2F8db4%2F</url>
    <content type="text"><![CDATA[在理解了 redux 的作用原理后，我们来看看 redux 的基本概念。 statestate：state 是状态管理的根本。在 redux 中，有唯一的状态树 state，为整个应用共享。本质上是一个普通对象。处于程序逻辑中，无法直接调用。 storestore：store 是 state 的管理者，一个应用同样只有唯一的 store，管理着唯一的 state。store 包含下列四个函数： getState() ：用于获取整个 state dispatch(action) ：View 触发 action 改变 state 的唯一途径，请注意我用了唯一这个词 subscribe(listener) ：可以理解成是 DOM 中的 addEventListener ，也就是我在上一篇里说过的发布订阅模式中的订阅方法，在 redux 的使用中，这个方法通常不需要手动使用，一般会放在 setState 方法中。 replaceReducer(nextReducer) ：这个不太常用，一般在 Webpack Code-Splitting 按需加载的时候用获取 state 的方式： 这几个方法中，dispatch函数略微难理解一点，单独提出来说说。 dispatchdispatch(action)用于 View 层想要更改 state 的操作，发布订阅模式中的发布操作。用于通知 store 做相应变更。 那么怎么让 store 知道变更哪一个属性呢？这里就要提到action了。action实际上是一个包含了type属性以及payload对象属性（这个叫载荷，不是必须的，但是在规范里推荐使用）的普通对象。其中type属性定义了应该进行的操作名。 我们从这里可以看出，由于载荷的存在，通常我们需要对action进行一些处理，因此，通常action对象由一个返回action对象的普通函数生成，一般我们称之为actionCreator函数。 actionCreator函数不仅可以直接返回action对象，也可以返回一个闭包，闭包传入的参数可以为我们刚才介绍的 store 中的四个函数，最终结果必须返回一个action对象。 注：actionCreator函数不能直接当做参数传入 dispatch 中，必须引入中间件redux-thunk。 createStore于是问题来了，既然state是由store生成和管理的，那么这个store又是怎么来的呢？生成 store 的方式又需要用到一个新的函数：createStore(reducer, intialState, applyMiddleware)。（initialState参数可以设置初始 state，非必须。applyMiddleware(middlewares)方法用于引入中间件，这里按住不表）这里又引出来一个新东西：reducer，这是干什么的呢？ reducer刚刚说到的 action ，我的简单的理解是：type 的值就是函数名，payload 的值就是函数的传入参数。那么这个特殊的“函数”在哪里执行呢？redux 的思想是：当 View 层调用dispatch方法，发出相应的action给store，store 收到 action 以后，必须给出一个新的 state，这样 View 才会发生变化。这种 state 的计算过程就叫做 reducer。 reducer(oldState, action)是一个纯函数（指任何时候输入同一个数据，返回的数据永远都相同，也就是说 reducer 函数中的处理不能带有任何异步操作），reducer负责对state操作，接收旧的 state 和 action，根据action.type的类型以及action.payload中的数据，处理 state 并返回。 12345678910111213141516const reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return &#123; ...state, count: state.count + action.payload.num; &#125; case 'DELETE': return &#123; ...state, count: state.count - action.payload.num; &#125; default: return state; &#125;&#125;; 一行代码简单来说就是(oldState, action) =&gt; newState。由于reducer是直接替换state，因此reducer必须有返回值。不然整个 redux 就会得不到state了。 话说一个计算变化重新生成 state 的方法为什么要叫 reducer 呢？我查了查资料，原来这个方法可以作为数组的reduce方法的参数。使用方法如下： 123456const actions = [ &#123; type: 'ADD', payload: &#123;num: 1&#125; &#125;, &#123; type: 'ADD', payload: &#123;num: 2&#125; &#125;];const newState = actions.reduce(reducer, state); // &#123;..., count: 3&#125; 由于 redux 中，reducer和state一样，也是唯一的，因此如果我们需要根据不同的处理逻辑分割reducer的话，需要用combineReducers({reducer})将这些reducer合并成一个rootReducer。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 深入理解 (1)]]></title>
    <url>%2Fposts%2F7db4%2F</url>
    <content type="text"><![CDATA[学习 react 的过程中，redux 的熟练掌握是一个绕不开并且很难绕过去的坎。接触 react 已经有一段时间了，甚至连一些小项目都用 react 做了不少了，但 redux 的使用上还是有诸多不理解不熟练的地方。正好有很长一段时间没有更过博客了，就从这里着手，增强一下自己的理解。 先从解决全局事件的问题开始我们都知道，react 的数据流是单向的，这样做是为了保证数据同源。 一般来说，子组件可以直接从父组件提供的 props 中获取数据放入 state 或是渲染出来，但是子组件要影响父组件的 state 的话就比较困难了，一般来说需要从父组件写一个回调函数通过 props 传入子组件，子组件调用这个回调函数之后，值就能在父组件中获取了。 那么，如何与孙组件传值呢？依据单向数据流的思路，层层 props 传递，回调函数再层层传递回来，是不是在写法上就有点看不懂了？ 那么，跟与这个组件几乎完全没关系的远房亲戚组件传值呢？数据状态管理上就非常混乱了。我们自然而然的会想到，是不是能设计出一种思路，解决多级无关层次属性传递的问题呢？ 有计算机基础的同学应该会从设计模式中找到灵感。没错，发布-订阅模式啊，全局订阅一个事件，将监听函数的回调函数置入其中，之后让想要改变数据的操作 dispatch 一个 action 的话，会依次激活通知所有订阅了这个事件的组件，这样再也不用辛苦的一级一级传递数据了，岂不是美滋滋？ 123456789101112131415161718var EventEmitter = &#123; _events: &#123;&#125;, dispatch: function (event, data) &#123; if (!this._events[event]) return; for (var i = 0; i &lt; this._events[event].length; i++) this._events[event][i](data); &#125;, subscribe: function (event, callback) &#123; if (!this._events[event]) this._events[event] = []; this._events[event].push(callback); &#125;, unSubscribe: function(event)&#123; if(this._events &amp;&amp; this._events[event]) &#123; delete this._events[event]; &#125; &#125;&#125; 是不是看起来很简单？事实上，redux 本身的思路就是这么简单，甚至你可以直接拿这个自己写的“myRedux”中的发布订阅功能投入到 react 项目的使用中。举个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var MyContainer = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;CurItemPanel /&gt; &lt;SelectionButtons/&gt; &lt;/div&gt; ) &#125;&#125;);var CurItemPanel = React.createClass(&#123; getInitialState: function()&#123; return &#123; curItem: 'item1' &#125; &#125;, componentDidMount: function()&#123; var self = this; EventEmitter.subscribe('changeItem', function(newItem)&#123; self.setState(&#123; curItem: newItem &#125;); &#125;) &#125;, componentWillUnmount: function()&#123; EventEmitter.unSubscribe('changeItem'); &#125;, render: function()&#123; return ( &lt;p&gt;The curItem is: &#123;this.state.curItem&#125;&lt;/p&gt; ) &#125;&#125;);var SelectionButtons = React.createClass(&#123; onClickItem: function(item)&#123; EventEmitter.dispatch('changeItem', item); &#125;, render: function()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.onClickItem.bind(this, 'item1')&#125;&gt;item1&lt;/button&gt; &lt;button onClick=&#123;this.onClickItem.bind(this, 'item2')&#125;&gt;item2&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;); 当点击按钮时，SelectionButtons的兄弟节点CurItemPanel可直接通过订阅的回调函数取得数据啦。 redux 本身的思路就是这么简洁明了。 有没有别的方法如果你的工程的数据流动没有那么繁杂，不想加入 redux 库来强行增加代码复杂度，但又实在觉得单项数据流的祖先传值太不友好的话，react 本身还提供了一个解决办法：Context（上下文）。它同样能解决层次传递的痛点，可以使子组件直接访问祖先组件数据，先写一个示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105var CurItemWrapper = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;CurItemPanel /&gt; &lt;/div&gt; ) &#125;&#125;);var CurItemPanel = React.createClass(&#123; contextTypes: &#123; curItem: React.PropTypes.any &#125;, render: function()&#123; return ( &lt;p&gt;The curItem is: &#123;this.context.curItem&#125;&lt;/p&gt; ) &#125;&#125;);var MyContainer = React.createClass(&#123; getInitialState: function()&#123; …… &#125;, childContextTypes: &#123; curItem: React.PropTypes.any, changeItem: React.PropTypes.any &#125;, getChildContext: function()&#123; return &#123; curItem: this.state.curItem, changeItem: this.changeItem &#125; &#125;, changeItem: function(item)&#123; this.setState(&#123; curItem: item &#125;); &#125;, render: function()&#123; return ( &lt;div&gt; &lt;CurItemWrapper /&gt; &lt;ListWrapper changeItem=&#123;this.changeItem&#125;/&gt; &lt;/div&gt; ) &#125;&#125;);var ListWrapper = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;List /&gt; &lt;/div&gt; ) &#125;&#125;);var List = React.createClass(&#123; contextTypes: &#123; changeItem: React.PropTypes.any &#125;, onClickItem: function(item)&#123; this.context.changeItem(item); &#125;, render: function()&#123; return ( &lt;ul&gt; &lt;li onClick=&#123;this.onClickItem.bind(this, 'item1')&#125;&gt; item1&lt;/li&gt; &lt;li onClick=&#123;this.onClickItem.bind(this, 'item2')&#125;&gt;item2&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;);var MyContainer = React.createClass(&#123; getInitialState: function()&#123; …… &#125;, childContextTypes: &#123; curItem: React.PropTypes.any, changeItem: React.PropTypes.any &#125;, getChildContext: function()&#123; return &#123; curItem: this.state.curItem, changeItem: this.changeItem &#125; &#125;, changeItem: function(item)&#123; this.setState(&#123; curItem: item &#125;); &#125;, render: function()&#123; return ( &lt;div&gt; &lt;CurItemWrapper /&gt; &lt;ListWrapper changeItem=&#123;this.changeItem&#125;/&gt; &lt;/div&gt; ) &#125;&#125;); 可以看出，通过指定childContextTypes后，父组件通过getChildContext方法可以直接获取到子孙组件中的 context，而子孙组件通过调用 context 对象也能轻松获取来自祖先的回调函数，省去了中间商赚差价（误 getChildContext 函数将会在每次 state 或者 props 改变时调用。为了更新 context 中的数据，使用 this.setState触发本地状态的更新。这将触发一个的 context 并且数据的改变可以被子元素收到。 但是！官方似乎并不希望 context 这个功能被广泛的使用，并声称在日后很可能下架这项功能。以下是原话： 绝大多数的应用程序不需要使用上下文 (context)。 如果你希望使用应用程序更加稳定，就不要使用上下文 (context)。这只是一个实验性的 API ，并且可能在未来的 React 版本中移除。 如果你不熟悉 Redux 或者 MobX 这类 state 管理库，就不要使用 context 。在许多实际应用中，这些库以及和 React 绑定是一个很好的管理 和许多组件相关的 state 。Redux 相比 context 是更好的解决方案。 如果你不是一个经验丰富的 React 开发者，就不要使用 context 。更好的方式是使用 props 和 state 。 如果你不顾这些警告仍然坚持使用 context ，尝试着将 context 的使用隔离在一个将小的范围内，并且在可能的情况下直接使用 context ，以便在 API 改变的时候进行升级。 emmm，所以呀，我们还是尽情拥抱 redux 吧，作为一个状态管理 flux 的 react 优化版，还是很值得学习一番的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 极简实践入门]]></title>
    <url>%2Fposts%2Fe000%2F</url>
    <content type="text"><![CDATA[为什么用 MongoDB传统的计算机应用大多使用关系型数据库来存储数据，比如大家可能熟悉的 MySql, Sqlite 等等，它的特点是数据以表格 (table) 的形式储存起来的。数据库由一张张排列整齐的表格构成，就好像一个 Excel 表单一样，每个表格会有若干列，比如一个学生信息表，可能包含学号、姓名、性别、入学年份、高考成绩、籍贯等等。而表格的每一排，则是一个个学生的具体信息。在企业级应用和前互联网时代，关系型数据库几乎是不二选择。关系型数据库的特点是有整齐划一的组织，很方便对数据进行描述、插入、搜索。 想象有一个传统的网上服装商店吧，它的主要的数据可能是储存在一张叫 products 的表单里，表单可能包含这些列：商品编号 (ID)、名称 (Name)、商家 (brand)、主目录 (cate)、子目录 (sub-cat)、零售价 (price)、是否促销 (promotion) 等等。如果有一个用户想要查找所有价格低于 300 元的正在促销的鞋子的编号和名称，则可以执行类似于以下的 SQL 语句： 1SELECT ID, name FROM products WHERE cate='shoes' AND price&lt;300 and AND promotion=true; SQL 具备了强大了的深度查询能力，能满足各式各样的查询要求。而如果要对数据进行添加和删除，成本也是非常低的。这些是 SQL 的优势之一， 但随着互联网的兴起以及数据形式的多样化，四平八稳的 SQL 表单在一些领域渐渐显现出它的劣势。让我们通过一个例子来说明。考虑一个博客后台系统，如果我们用关系型数据库为每篇博客 (article) 建一个表单的话，这个表单大概会包括以下这些列： ID Title Description Author Content Likes A_1 Title1 Political Article Joe Content 1 12 A_2 Title2 Humorous Story Sam Content 2 50 这时候用 SQL 数据库来存储是非常方便的，但假如我们要位每篇文章添加评论功能，会发现每篇文章可能要多篇评论，而且这个数目是动态变化的，而且每篇评论还包括好几项内容：评论的人、评论的时间、以及评论内容。这时候要将这些内容都塞进上述的那个表，就显得很困难。通常的做法是为评论 (comment) 单独建一个表： ID Author Time Content Article C_1 Anna 2014-12-26 08:23 Really good articles! A_1 C_2 David 2014-12-25 09:30 I like it! A_1 类似地，每篇文章可能会有若干标签 (tags)。标签本身又是一个表单： ID Category Tags Content Article T_1 Anna 2014-12-26 08:23 Really good articles! A_1 T_2 David 2014-12-25 09:30 I like it! A_2 而博客的表格则要通过 foreign key 跟这些相关联的表格联系起来（可能还包括作者、出版社等其它表格）。这样一来，当我们做查询的时候，比如说，“找出评论数不少于 3 的标签为‘政治评论’的作者为 Sam 的文章”，就会涉及到复杂的跨表查询，需要大量使用join语句。这种跨表查询不仅降低了查询速度，而且这些语句写起来也不简单。 那么，如果用 MongoDB 数据库来实现，可以如何设计数据模型呢？很简单，像下面这样 http://www.tutorialspoint.com/mongodb/mongodb_data_modeling.htm 123456789101112131415161718_id: POST_IDtitle: TITLE_OF_POST,description: POST_DESCRIPTION,author: POST_BY,tags: [TAG1, TAG2, TAG3],likes: TOTAL_LIKES,comments: [ &#123; user:'COMMENT_BY', message: TEXT, dateCreated: DATE_TIME, &#125;, &#123; user:'COMMENT_BY', message: TEXT, dateCreated: DATE_TIME, &#125;] 在 MongoDB 里，每篇博客文章以一个文档 (document) 的形式保存起来，而文档内部包含了很多项目，比如title tags等，每一个项目都是key-value的形式，即有一个项目的名字，比如title，以及它的值TITLE_OF_POST。而重要的是，一个key可以有多个values，他们用[]括起来。 这种“宽松”的数据存储形式非常灵活，MongoDB 不限制每个key对应的values的数目。比如有的文章没有评论，则它的值就是一个空集，完全没有问题；有的文章评论很多，也可以无限制地插入。更灵活的是，MongoDB 不要求同一个集合 (collection，相当于 SQL 的 table) 里面的不同 document 有相同的 key，比如除了上述这种文档组织，有的文档所代表的文章可能没有 likes 这个项目，再比如有的文章可能有更多的项目，比如可能还有 dislikes 等等。这些不同的文档都可以灵活地存储在同一个集合下，而且查询起来也异常简单，因为都在一个文档里，不用进行各种跨文档查询。而这种 MongoDB 式的存储也方便了数据的维护，对于一篇博客文章来说，所有的相关数据都在这个 document 里面，不用去考虑一个数据操作需要 involve 多少个表格。 当然，除了上述的优点，MongoDB 还有不少别的优势，比如 MongoDB 的数据是用 JSON(Javascript Object Notation) 存储的（就是上面的这种 key-value 的形式），而几乎所有的 web 应用都是基于 Javascript 的。因此，存储的数据和应用的数据的格式是高度一致的，不需经过转换。更多的优点可以查看：http://www.tutorialspoint.com/mongodb/mongodb_advantages.htm。 文章目的这个极简教程，或者说笔记，并不是一个覆盖 MongoDB 方方面面的教程。所谓极简的意思，就是只选取那些最重要、最常用的内容进行基于实例的介绍，从而让读者能够在最短的时间内快速上手，并且能顺利地进行后续的纵深的学习。 具体地说，这个教程的特点是： 不求全面，只求实用。只覆盖最核心的部分； 以大量例子为导向； 一边阅读一边动手操作的话，大约只需要 2 小时的时间； 阅读这篇文章不需要有特别的基础，但最好知道数据库的基本概念，如果本身熟悉 SQL 那就更好啦。 安装与环境MongoDB 可以在 Windows、Linux、Mac OS X 等主流平台运行，而且下载和安装非常简单，非常友好。这篇文档的例子采用 MongoDB 2.6 版本，均在 OS X 测试过，有充足的理由相信，在其它平台也能顺利运行。 Windows 的安装和设置可以参考：http://www.w3cschool.cc/mongodb/mongodb-window-install.html Linux 的安装和设置可以参考：http://www.w3cschool.cc/mongodb/mongodb-linux-install.html Mac OS X 下的安装和设置： 在 https://www.mongodb.org/ 下载适合你的 Mac 的 MongoDb; 下载得到的文件是一个 zip 文件，解压，然后放到你想到的文件夹，比如/Users/Steven/MongoDB; 创建一个你喜欢的文件夹来存储你的数据，比如/User/Steven/myData; 打开 Terminal，cd 到 2 里面那个文件夹/Users/Steven/MongoDB，再 cd bin; 输入。/mongod –dbpath /User/Steven/myData, 等到出现类似“waiting for connections on port 27017”，说明 MongoDB 服务器已架设好，而数据将储存在 myData 里面； 新打开一个 Terminal, cd /Users/Steven/MongoDB/bin, 然后运行。/mongo; 顺利的话它将出现一个 interactive shell 让你进行各种操作，而你的数据将储存在 myData 里 如果以上的各个步骤都运行顺利，就可以跳到下一节啦。 创建集合和删除集合在上一节执行完步骤 6 后，你会看到命令行里显示：connecting to: test，这里的test是默认的数据库。这里我们可以新建一个数据库。在命令行里打入： 1use tutorial 这样就新建了一个叫做tutorial的数据库。你可以执行 1show databases 来显示当前的数据库。不过这时候由于我们的新数据库是空的，所以会显示类似这样的： 12admin (empty)local 0.078GB 我们试着往我们的数据库里添加一个集合 (collection)，MongoDB 里的集合和 SQL 里面的表格是类似的： 1db.createCollection('author') 顺利的话会显示： 1&#123; "ok" : 1 &#125; 表示创建成功。 你可以再回头执行： 1show databases 这时候我们的 tutorial 集合已经位列其中。你可以再执行 1show collections 可以看到创建的集合 author 也在其中。 我们暂时不需要 author 这个集合，所以我们可以通过执行： 1db.author.drop() 来将其删除。这时候你再执行show collections，就再也看不到我们的 author 了。 这一节要记住的点主要只有一个：集合 (collection) 类似于 SQL 的表格 (table)，类似于 Excel 的一个个表格。 插入想象一个精简版的“豆瓣电影”。我们需要创建一个数据库，来存储每部电影的信息，电影的信息包括： 电影名字 导演 主演（可能多个） 类型标签（可能多个） 上映日期 喜欢人数 不喜欢人数 用户评论（可能多个） 显然我们需要先创建一个叫电影的集合： 1db.createCollection('movie') 然后，我们就可以插入数据了： 12345678910111213141516171819202122232425db.movie.insert( &#123; title: 'Forrest Gump', directed_by: 'Robert Zemeckis', stars: ['Tom Hanks', 'Robin Wright', 'Gary Sinise'], tags: ['drama', 'romance'], debut: new Date(1994,7,6,0,0), likes: 864367, dislikes: 30127, comments: [ &#123; user:'user1', message: 'My first comment', dateCreated: new Date(2013,11,10,2,35), like: 0 &#125;, &#123; user:'user2', message: 'My first comment too!', dateCreated: new Date(2013,11,11,6,20), like: 0 &#125; ] &#125;) 请注意，这里插入数据之前，我们并不需要先声明 movie 这个集合里面有哪些项目。我们直接插入就可以了~这一点和 SQL 不一样，SQL 必须先声明一个 table 里面有哪些列，而 MongoDB 不需要。 把上面的例子复制进命令行应该可以顺利运行，但我强烈建议你手动打一下，或者输入一部你自己喜欢的电影。insert操作有几点需要注意： 不同 key-value 需要用逗号隔开，而 key:value 中间是用冒号； 如果一个 key 有多个 value，value 要用 []。哪怕当前只有一个 value，也加上 [] 以备后续的添加； 整个“数据块”要用{}括起来； 如果你在insert之后看到WriteResult({ &quot;nInserted&quot; : 1 })，说明写入成功。 这个时候你可以用查询的方式来返回数据库中的数据： 1db.movie.find().pretty() 这里find()里面是空的，说明我们不做限制和筛选，类似于 SQL 没有WHERE语句一样。而pretty()输出的是经格式美化后的数据，你可以自己试试没有pretty()会怎么样。 仔细观察find()的结果，你会发现多了一个叫&#39;_id&#39;的东西，这是数据库自动创建的一个 ID 号，在同一个数据库里，每个文档的 ID 号都是不同的。 我们也可以同时输入多个数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960db.movie.insert([ &#123; title: 'Fight Club', directed_by: 'David Fincher', stars: ['Brad Pitt', 'Edward Norton', 'Helena Bonham Carter'], tags: 'drama', debut: new Date(1999,10,15,0,0), likes: 224360, dislikes: 40127, comments: [ &#123; user:'user3', message: 'My first comment', dateCreated: new Date(2008,09,13,2,35), like: 0 &#125;, &#123; user:'user2', message: 'My first comment too!', dateCreated: new Date(2003,10,11,6,20), like: 14 &#125;, &#123; user:'user7', message: 'Good Movie!', dateCreated: new Date(2009,10,11,6,20), like: 2 &#125; ]&#125;,&#123; title: 'Seven', directed_by: 'David Fincher', stars: ['Morgan Freeman', 'Brad Pitt', 'Kevin Spacey'], tags: ['drama','mystery','thiller'], debut: new Date(1995,9,22,0,0), likes: 134370, dislikes: 1037, comments: [ &#123; user:'user3', message: 'Love Kevin Spacey', dateCreated: new Date(2002,09,13,2,35), like: 0 &#125;, &#123; user:'user2', message: 'Good works!', dateCreated: new Date(2013,10,21,6,20), like: 14 &#125;, &#123; user:'user7', message: 'Good Movie!', dateCreated: new Date(2009,10,11,6,20), like: 2 &#125; ]&#125;]) 顺利的话会显示： 123456789BulkWriteResult(&#123; "writeErrors" : [ ], "writeConcernErrors" : [ ], "nInserted" : 2, "nUpserted" : 0, "nMatched" : 0, "nModified" : 0, "nRemoved" : 0, "upserted" : [ ] 表面我们成功地插入了两个数据。注意批量插入的格式是这样的：db.movie.insert([{ITEM1},{ITEM2}])。几部电影的外面需要用 [] 括起来。 请注意，虽然 collection 的插入不需要先声明，但表达相同意思的 key，名字要一样，比如，如果我们在一个文档里用directed_by来表示导演，则在其它文档也要保持同样的名字（而不是director之类的）。不同的名字不是不可以，技术上完全可行，但会给查询和更新带来困难。 好了，到这里，我们就有了一个叫 tutorial 的数据库，里面有一个叫 movie 的集合，而 movie 里面有三个记录。接下来我们就可以对其进行查询了。 查询在上一节我们已经接触到最简单的查询db.movie.find().pretty()。MongoDB 支持各种各样的深度查询功能。先来一个最简单的例子，找出大卫芬奇 (David Fincher) 导演的所有电影： 1db.movie.find(&#123;'directed_by':'David Fincher'&#125;).pretty() 将返回《搏击俱乐部》和《七宗罪》两部电影。这种搜索和 SQL 的WHERE语句是很相似的。 也可以设置多个条件。比如找出大卫芬奇导演的，摩根弗里曼主演的电影： 1db.movie.find(&#123;'directed_by':'David Fincher', 'stars':'Morgan Freeman'&#125;).pretty() 这里两个条件之间，是 AND 的关系，只有同时满足两个条件的电影才会被输出。同理，可以设置多个的条件，不赘述。 条件之间也可以是或的关系，比如找出罗宾怀特或摩根弗里曼主演的电影： 1234567db.movie.find(&#123; $or: [ &#123;'stars':'Robin Wright'&#125;, &#123;'stars':'Morgan Freeman'&#125; ]&#125;).pretty() 注意这里面稍显复杂的各种括号。 还可以设置一个范围的搜索，比如找出 50 万人以上赞的电影： 1db.movie.find(&#123;'likes':&#123;$gt:500000&#125;&#125;).pretty() 同样要注意略复杂的括号。注意，在这些查询里，key 的单引号都是可选的，也就是说，上述语句也可以写成： 1db.movie.find(&#123;likes:&#123;$gt:500000&#125;&#125;).pretty() 类似地，少于二十万人赞的电影： 1db.movie.find(&#123;likes:&#123;$lt:200000&#125;&#125;).pretty() 类似的运算符还有：$let: 小于或等于；$get: 大于或等于；$ne: 不等于。 注意，对于包含多个值的 key，同样可以用 find 来查询。比如： 1db.movie.find(&#123;'tags':'romance'&#125;) 将返回《阿甘正传》，虽然其标签既有 romance，又有 drama，但只要符合一个就可以了。 如果你确切地知道返回的结果只有一个，也可以用findOne: 1db.movie.findOne(&#123;'title':'Forrest Gump'&#125;) 如果有多个结果，则会按磁盘存储顺序返回第一个。请注意，findOne()自带 pretty 模式，所以不能再加pretty()，将报错。 如果结果很多而你只想显示其中一部分，可以用limit()和skip()，前者指明输出的个数，后者指明从第二个结果开始数。比如： 1db.movie.find().limit(2).skip(1).pretty() 则跳过第一部，从第二部开始选取两部电影。 局部查询第五节的时候我们讲了find的用法，但对于符合条件的条目，我们都是返回整个 JSON 文件的。这类似于 SQL 里面的SELECT *。有的时候，我们需要的，仅仅是部分数据，这个时候，find的局部查询的功能就派上用场了。先来看一个例子，返回 tags 为 drama 的电影的名字和首映日期。 1db.movie.find(&#123;'tags':'drama'&#125;,&#123;'debut':1,'title':1&#125;).pretty() 数据库将返回： 123456789101112131415&#123; "_id" : ObjectId("549cfb42f685c085f1dd47d4"), "title" : "Forrest Gump", "debut" : ISODate("1994-08-05T16:00:00Z")&#125;&#123; "_id" : ObjectId("549cff96f685c085f1dd47d6"), "title" : "Fight Club", "debut" : ISODate("1999-11-14T16:00:00Z")&#125;&#123; "_id" : ObjectId("549cff96f685c085f1dd47d7"), "title" : "Seven", "debut" : ISODate("1995-10-21T16:00:00Z")&#125; 这里 find 的第二个参数是用来控制输出的，1 表示要返回，而 0 则表示不返回。默认值是 0，但_id是例外，因此如果你不想输出_id，需要显式地声明： 1db.movie.find(&#123;'tags':'drama'&#125;,&#123;'debut':1,'title':1,'_id':0&#125;).pretty() 更新很多情况下你需要更新你的数据库，比如有人对某部电影点了个赞，那么你需要更新相应的数据库。比如有人对《七宗罪》点了个赞，而它本来的赞的个数是 134370，那么你需要更新到 134371。可以这样操作： 1db.movie.update(&#123;title:'Seven'&#125;, &#123;$set:&#123;likes:134371&#125;&#125;) 第一个大括号里表明要选取的对象，第二个表明要改动的数据。请注意上述的操作相当不现实，因为你首先要知道之前的数字是多少，然后加一，但通常你不读取数据库的话，是不会知道这个数 (134370) 的。MongoDB 提供了一种简便的方法，可以对现有条目进行增量操作。假设又有人对《七宗罪》点了两个赞，则可以： 1db.movie.update(&#123;title:'Seven'&#125;, &#123;$inc:&#123;likes:2&#125;&#125;) 如果你查询的话，会发现点赞数变为 134373 了，这里用的是$inc。除了增量更新，MongoDB 还提供了很多灵活的更新选项，具体可以看：http://docs.mongodb.org/manual/reference/operator/update-field/ 。 注意如果有多部符合要求的电影。则默认只会更新第一个。如果要多个同时更新，要设置{multi:true}，像下面这样： 1db.movie.update(&#123;&#125;, &#123;$inc:&#123;likes:10&#125;&#125;,&#123;multi:true&#125;) 所有电影的赞数都多了 10. 注意，以上的更新操作会替换掉原来的值，所以如果你是想在原有的值得基础上增加一个值的话，则应该用$push，比如，为《七宗罪》添加一个 popular 的 tags。 1db.movie.update(&#123;'title':'Seven'&#125;, &#123;$push:&#123;'tags':'popular'&#125;&#125;) 你会发现《七宗罪》现在有四个标签： 123456"tags" : [ "drama", "mystery", "thiller", "popular"], 删除删除的句法和 find 很相似，比如，要删除标签为 romance 的电影，则： 1db.movie.remove(&#123;'tags':'romance'&#125;) 考虑到我们数据库条目异常稀少，就不建议你执行这条命令了~ 注意，上面的例子会删除所有标签包含 romance 的电影。如果你只想删除第一个，则 1db.movie.remove(&#123;'tags':'romance'&#125;,1) 如果不加任何限制： 1db.movie.remove() 会删除 movie 这个集合下的所有文档。 索引和排序为文档中的一些 key 加上索引 (index) 可以加快搜索速度。这一点不难理解，假如没有没有索引，我们要查找名字为 Seven 的电影，就必须在所有文档里逐个搜索。而如果对名字这个 key 加上索引值，则电影名这个字符串和数字建立了映射，这样在搜索的时候就会快很多。排序的时候也是如此，不赘述。MongoDB 里面为某个 key 加上索引的方式很简单，比如我们要对导演这个 key 加索引，则可以： 1db.movie.ensureIndex(&#123;directed_by:1&#125;) 这里的 1 是升序索引，如果要降序索引，用-1。 MongoDB 支持对输出进行排序，比如按名字排序： 1db.movie.find().sort(&#123;'title':1&#125;).pretty() 同样地，1 是升序，-1 是降序。默认是 1。 1db.movie.getIndexes() 将返回所有索引，包括其名字。 而 1db.movie.dropIndex('index_name') 将删除对应的索引。 11. 聚合MongoDB 支持类似于 SQL 里面的GROUP BY操作。比如当有一张学生成绩的明细表时，我们可以找出每个分数段的学生各有多少。为了实现这个操作，我们需要稍加改动我们的数据库。执行以下三条命令： 123db.movie.update(&#123;title:'Seven'&#125;,&#123;$set:&#123;grade:1&#125;&#125;)db.movie.update(&#123;title:'Forrest Gump'&#125;,&#123;$set:&#123;grade:1&#125;&#125;)db.movie.update(&#123;title:'Fight Club'&#125;,&#123;$set:&#123;grade:2&#125;&#125;) 这几条是给每部电影加一个虚拟的分级，前两部是归类是一级，后一部是二级。 这里你也可以看到 MongoDB 的强大之处：可以动态地后续添加各种新项目。 我们先通过聚合来找出总共有几种级别。 1db.movie.aggregate([&#123;$group:&#123;_id:'$grade'&#125;&#125;]) 输出： 12&#123; "_id" : 2 &#125;&#123; "_id" : 1 &#125; 注意这里的 2 和 1 是指级别，而不是每个级别的电影数。这个例子看得清楚些： 1db.movie.aggregate([&#123;$group:&#123;_id:'$directed_by'&#125;&#125;]) 这里按照导演名字进行聚合。输出： 12&#123; "_id" : "David Fincher" &#125;&#123; "_id" : "Robert Zemeckis" &#125; 接着我们要找出，每个导演的电影数分别有多少： 1db.movie.aggregate([&#123;$group:&#123;_id:'$directed_by',num_movie:&#123;$sum:1&#125;&#125;&#125;]) 将会输出： 12&#123; "_id" : "David Fincher", "num_movie" : 2 &#125;&#123; "_id" : "Robert Zemeckis", "num_movie" : 1 &#125; 注意$sum 后面的 1 表示只是把电影数加起来，但我们也可以统计别的数据，比如两位导演谁的赞比较多： 1db.movie.aggregate([&#123;$group:&#123;_id:'$directed_by',num_likes:&#123;$sum:'$likes'&#125;&#125;&#125;]) 输出： 12&#123; "_id" : "David Fincher", "num_likes" : 358753 &#125;&#123; "_id" : "Robert Zemeckis", "num_likes" : 864377 &#125; 注意这些数据都纯属虚构啊！ 除了$sum，还有其它一些操作。比如： 1db.movie.aggregate([&#123;$group:&#123;_id:'$directed_by',num_movie:&#123;$avg:'$likes'&#125;&#125;&#125;]) 统计平均的赞。 1db.movie.aggregate([&#123;$group:&#123;_id:'$directed_by',num_movie:&#123;$first:'$likes'&#125;&#125;&#125;] 返回每个导演的电影中的第一部的赞数。 其它各种操作可以参考：http://docs.mongodb.org/manual/reference/operator/aggregation/group/。 All or NothingMongoDB 支持单个文档内的原子化操作 (atomic operation)，这是说，可以将多条关于同一个文档的指令放到一起，他们要么一起执行，要么都不执行。而不会执行到一半。有些场合需要确保多条执行一起顺次执行。比如一个场景：一个电商网站，用户查询某种商品的剩余数量，以及用户购买该种商品，这两个操作，必须放在一起执行。不然的话，假定我们先执行剩余数量的查询，这是假定为 1，用户接着购买，但假如这两个操作之间还加入了其它操作，比如另一个用户抢先购买了，那么原先购买用户的购买的行为就会造成数据库的错误，因为实际上这种商品以及没有存货了。但因为查询剩余数量和购买不是在一个“原子化操作”之内，因此会发生这样的错误 http://www.tutorialspoint.com/mongodb/mongodb_atomic_operations.htm。 MongoDB 提供了findAndModify的方法来确保 atomic operation。比如这样的： 123456db.movie.findAndModify( &#123; query:&#123;'title':'Forrest Gump'&#125;, update:&#123;$inc:&#123;likes:10&#125;&#125; &#125; ) query 是查找出匹配的文档，和 find 是一样的，而 update 则是更新 likes 这个项目。注意由于 MongoDB 只支持单个文档的 atomic operation，因此如果 query 出多于一个文档，则只会对第一个文档进行操作。 findAndModify还支持更多的操作，具体见：http://docs.mongodb.org/manual/reference/command/findAndModify/。 文本搜索除了前面介绍的各种深度查询功能，MongoDB 还支持文本搜索。对文本搜索之前，我们需要先对要搜索的 key 建立一个 text 索引。假定我们要对标题进行文本搜索，我们可以先这样： 1db.movie.ensureIndex(&#123;title:'text'&#125;) 接着我们就可以对标题进行文本搜索了，比如，查找带有”Gump”的标题： 1db.movie.find(&#123;$text:&#123;$search:"Gump"&#125;&#125;).pretty() 注意 text 和 search 前面的$符号。 这个例子里，文本搜索作用不是非常明显。但假设我们要搜索的 key 是一个长长的文档，这种 text search 的方便性就显现出来了。MongoDB 目前支持 15 种语言的文本搜索。 正则表达式MongoDB 还支持基于正则表达式的查询。如果不知道正则表达式是什么，可以参考 Wikipedia。这里简单举几个例子。比如，查找标题以b结尾的电影信息： 1db.movie.find(&#123;title:&#123;$regex:'.*b$'&#125;&#125;).pretty() 也可以写成： 1db.movie.find(&#123;title:/.*b$/&#125;).pretty() 查找含有’Fight’标题的电影： 1db.movie.find(&#123;title:/Fight/&#125;).pretty() 注意以上匹配都是区分大小写的，如果你要让其不区分大小写，则可以： 1db.movie.find(&#123;title:&#123;$regex:'fight.*b',$options:'$i'&#125;&#125;).pretty() $i是 insensitive 的意思。这样的话，即使是小写的 fight，也能搜到了。 后记至此，MongoDB 的最基本的内容就介绍得差不多了。如果有什么遗漏的以后我会补上來。如果你一路看到底完全了这个入门教程，恭喜你，你一定是一个有毅力的人。 把这个文档过一遍，不会让你变成一个 MongoDB 的专家（如果会那就太奇怪了）。但如果它能或多或少减少你上手的时间，或者让你意识到“咦，MongoDB 其实没那么复杂”，那么这个教程的目的也就达到啦。 这个文档是匆忙写就的，出错简直是一定的。如果您发现了任何错误或者有关于本文的任何建议，麻烦发邮件给我（stevenslxie at gmail.com）或者在 GitHub 上直接交流，不胜感激。 转载声明原作者 StevenSLXie 原链接 https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/MongoDB%20%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8.md]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 建立 repository 并上传工程的方法]]></title>
    <url>%2Fposts%2F3e41%2F</url>
    <content type="text"><![CDATA[这不是什么新知识了，自从我用 github 以来一直就是这么用着的，但是最近有一段时间没上传过自己的 project 了，竟然手生了忘了怎么做了。想了想还是记录下来比较好，也给大家分享分享。 由于是给自己做的备忘，怎么注册 github 之类的新手问题我就不说了，不懂的朋友可以自行去百度相关问题，很多的。 先 clone 再写入的方法（适用于还未开发项目时）通常最简单最无脑的办法就是现在 github 网站上创建一个 repository，可以自己任意设定名字和 readme.md。之后通过： 1git clone git@github.com:username/respositoryname.git 克隆到本地，之后往里面写入文件文件夹就行了。 写完想要提交到 github 的话，就输入如下命令： 1234git pullgit add .git commit -m "first commit"git push origin master 这里最好先 git pull 一下，以免有冲突导致提交不成功。 对本地项目 git init 再提交（适用于项目已经成型，想要在此时进行版本控制）如果你已经写好了工程但还没有进行过 git 版本控制，或者直接是从别的地方下载好的 github 上的工程还没有进入你自己的代码库的话，可以使用这种方法： 首先，如果你的工程完全没有经过 git 版本控制，那么在你的工程目录中输入命令： 12git inittouch .gitignore 之后你的工程里会多出一个。git 的文件夹，之后你需要建立一个。gitignore 文件，来建立规则忽略你不想传上 github 进行版本控制的文件或文件夹（一般为依赖库、数据库或者一些隐私文件），配置规则请百度。 之后的操作跟方法一大体相同，指定要提交到的远程 repository，并注意同步冲突问题，之后提交即可。 12345git add .git commit -m "first commit"git remote add origin git@github.com:username/respositoryname.gitgit pull origin mastergit push -u origin master 其实 github 还提供了一个方法：import code from another repository，从别的版本库中导入工程，这个就不细说了，因为 git 是公认的目前最好的版本控制库，根本不需要再放在别的地方了。有历史原因的工程想导入的话完全可以先下载下来，再参照方法一二进行。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Linux 下 nodejs 的安装方法大全]]></title>
    <url>%2Fposts%2Ffab0%2F</url>
    <content type="text"><![CDATA[这段时间为了上线测试很多 nodejs 代码的部署，开始鼓捣云服务器。由于不是很懂运维知识，首先在安装上就踩了很多大坑，于是决定记录下来做个备忘。 首先，我们可以去 nodejs 官网 下载代码。 页面大概长成这样，上面有不同系统的不同位版本的下载，也可以点击上面的连接直接下载源码。 1. 第一种方法，直接使用编译好的版本这是我认为最简单最好用的方法，直接下载官网的可编译版本的压缩包，然后用 ftp 导入到服务器中。当然你也可以直接在服务器中输入下载链接下载下来。 之后将压缩包文件解压，解压方法根据压缩包类型的不同方法有很多，我随便给一个 tar.gz 的： 1tar xvf node-v8.1.0-linux-64.tar.gz 其中，node-v8.1.0-linux-64 是你的下载文件名，文件名不同这里填写的内容就不同，下面的内容也是一样的，就不一一重复了。 解压之后，我们 cd 到这个目录执行 node，发现已经能直接干了。 123cd node-v8.1.0-linux-64/bin./node -v./npm -v 但是这样比较麻烦，每次都要进入到这个目录才能执行 node 和 npm。那么怎样在 linux 里设置全局命令呢？答案是使用 ln 命令： 12ln -s /root/node-v8.1.0-linux-64/bin/node /usr/local/bin/nodeln -s /root/node-v8.1.0-linux-64/bin/npm /usr/local/bin/npm 命令接收两个参数，第一个是你的 node 文件夹所在的位置，我图省事直接装在 root 下了，你改了文件位置的话这个地方就写 node 文件夹所在的位置的父目录即可，第二个是全局指令库位置。 接下来随便跳到一个目录，执行： 12node -vnpm -v 是不是就有反应啦。 2. 第二种方式，通过源码编译还是在官网的那个下载页面下载，但是这次选择下载的是 Source Code 源码，还是原样 ftp 导入后解压，方法同上。 之后我们进入到源码目录中，进行编译三板斧： 123./configuremakemake install 经过一段及其漫长的编译过程后……（make 真的漫长，等了得有 20 分钟，可能是我云服务器配置太差 %&gt;_&lt;%）就能自动的在全局使用 node 和 npm 命令啦~ 如果你的在服务器上不行的话，加上这一句试试： 1cp /usr/local/bin/node /usr/sbin/ 这种方式是最推荐使用的，出问题的可能性最小，卸载修改也都很好解决。缺点是……实在是太麻烦了…… 3. 第三种方式，通过系统安装 apt-get 或 yum 等方式安装 nodejs我写这种方式在这里只是因为确实可以下载并安装。但我这里就不写过程了，因为这种方式下载到的安装包不仅下载慢，下载完成后的包版本还可能不是最新的，安装后还可能出现各种各样的问题，非常的不推荐使用。 （完）]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局体验]]></title>
    <url>%2Fposts%2Fa342%2F</url>
    <content type="text"><![CDATA[还在为各种布局的 hack 方法犯愁么？还在想着网上流传的各类垂直居中存在的各种奇怪 bug 而影响工作体验么？还在为找不到一个合适自己的规范而疯狂造轮子么？现在，一个全新的布局解决方案规范已经展现在我们面前，它就是 flex 布局。只要 998，各类布局完美解决方案带回家！ 2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 看到没，w3c 大佬亲自提出来，这权威性不用质疑了吧。 Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局，包括行内元素。只需要设置元素的 display 为 flex 或者 flex-inline 即可。需要注意的是，元素设为 Flex 布局以后，它的子元素的 float、clear 和 vertical-align 属性将失效。 好，接下来我们就来看看，flex 布局到底是个什么样的布局原理和思想。以下内容摘自阮一峰老师的 Flex 布局教程: 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 因此啊，我们只需要关注当前元素的水平轴和垂直轴位置，即可完全定位整个元素，是不是很有道理呢？ 具体的工具教程请自行查阅相关文档，这里我随便给个 传送门，要授人以渔喔。 demo 分割线那我带大家做什么呢？当然是做 demo 啦，这种东西实用，进步最快啦。 先给大家上个效果图： 这是一个自适应宽高的九个骰子图（好吧我知道骰子没有 9 个），大家先根据以往的经验，每个骰子应该怎样实现，再用 flex 布局试一次。 然后附上我的实现代码：flex_demo 如果大家有什么更好的想法和建议，欢迎留言或者 pull request 呐～]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 github+Hexo 的博客多终端同步问题]]></title>
    <url>%2Fposts%2F28d%2F</url>
    <content type="text"><![CDATA[解决 github + Hexo 的博客多终端同步的思路是将博文内容相关文件放在 Github 项目中 master 中，将 Hexo 配置写博客用的相关文件放在 Github 项目的 hexo 分支上，这个是关键，多终端的同步只需要对分支 hexo 进行操作。 下面是详细的步骤讲解： 1. 准备条件安装了 Node.js,Git,Hexo 环境完成 Github 与本地 Hexo 的对接这部分大家可以参考史上 最详细的 Hexo 博客搭建图文教程 配置好这些，就可以捋起袖子大干一场了！ 2. 在其中一个终端操作，push 本地文件夹 Hexo 中的必要文件到 yourname.github.io 的 hexo 分支上在利用 Github+Hexo 搭建自己的博客时，新建了一个 Hexo 的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到 Github 项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示： git init //初始化本地仓库git add source //将必要的文件依次添加，有些文件夹如 npm install 产生的 node_modules 由于路径过长不好处理，所以这里没有用’git add .’命令了，而是依次添加必要文件，如下所示 12345git commit -m "Blog Source Hexo"git branch hexo //新建 hexo 分支git checkout hexo //切换到 hexo 分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与 Github 项目对接git push origin hexo //push 到 Github 项目的 hexo 分支上 完成之后的效果图为： 这样你的 github 项目中就会多出一个 Hexo 分支，这个就是用于多终端同步关键的部分。 3. 另一终端完成 clone 和 push 更新此时在另一终端更新博客，只需要将 Github 的 hexo 分支 clone 下来，进行初次的相关配置 12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将 Github 中 hexo 分支 clone 到本地cd yourname.github.io //切换到刚刚 clone 的文件夹内npm install //注意，这里一定要切换到刚刚 clone 的文件夹内执行，安装必要的所需组件，不用再 inithexo new post "new blog name" //新建一个。md 文件，并编辑完成自己的博客内容git add source //经测试每次只要更新 sorcerer 中的文件到 Github 中即可，因为只是新建了一篇新博客git commit -m "XX"git push origin hexo //更新分支hexo d -g //push 更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了 Github 中的 master 4. 不同终端间愉快地玩耍在不同的终端已经做完配置，就可以愉快的分享自己更新的博客 进入自己相应的文件夹 123456git pull origin hexo //先 pull 完成本地与远端的融合hexo new post " new blog name"git add sourcegit commit -m "XX"git push origin hexohexo d -g 本文转载自：http://blog.csdn.net/Monkey_LZL/article/details/60870891]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 学习笔记]]></title>
    <url>%2Fposts%2F6008%2F</url>
    <content type="text"><![CDATA[最近在尝试学习新框架，感觉学习曲线异常的陡峭，全然没有当时学习 bootstrap 和 jquery 的顺畅感觉。后面仔细想来，自己应该是缺了一些基础知识没有补上来，才会导致框架学习遇到了极大的阻力。那自己的知识栈到底缺失了哪一块呢？没错，就是面向未来的 javascript 语法————ES6。 那么现在开始恶补吧，还不算晚。我将我的学习过程记录下来，为自己做 notes，也与各位分享。 这个学习笔记我决定由浅入深，先说说 es6 中最有用、最常用的一些新特性，并举例子介绍它们的特点，所举例子大部分参考自阮一峰老师的 《ECMAScript 6 入门》。这本书可是 es6 入门的一本佳作，更难能可贵的是还获得了开源许可，推荐大家一读。 好了言归正传，这一期我准备先来介绍 es6 新增的用来定义变量的新命令。 let 命令只要是听过 es6 大名的人，第一个想到的应该就是 let 命令，因为它的出现一举解决了 es5 时代的许多莫名其妙的变量提升，变量污染的问题。 我们都知道，es5 以前的规范中，javascript 并没有作用域作用块的概念，唯一能够限制使用 var 定义的变量不溢出的块只有函数包裹的块。其他的任何方式都很容易一个不小心就把局部变量泄漏了出去。比如这样： 1234567891011121314function fun() &#123; var a = 1;&#125;console.log(a) //ReferenceError: a is not defined&#123; var b = 1;&#125;console.log(b); // 1for(var c = 0; c &lt; 5; c++)&#123;&#125;;console.log(c) // 5 但是自从引入了 let 命令，js 就有了作用域和代码块，我们可以定义只在块作用域（使用花括号括起来的作用域，包括函数、对象等）中作用的变量了。 1234567891011121314function fun() &#123; let a = 1;&#125;console.log(a) //ReferenceError: a is not defined&#123; let b = 1;&#125;console.log(b); //ReferenceError: b is not definedfor(let c = 0; c &lt; 5; c++)&#123;&#125;;console.log(c) //ReferenceError: c is not defined 这就是 let 的特性。 那么有了这个新的定义变量的命令，我们就能解决许多从前我们极其痛恨过的 js 缺陷了。 1. 妈妈再也不用担心我的变量提升我们都知道，var 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。而 let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 12345console.log(a); //undefinedvar a = 1;console.log(b); //ReferenceError: b is not definedlet b = 1; 写很长的代码时，经常会遇到很尴尬的事儿：忘记自己定义过了一个变量导致重复定义，或在变量声明前就使用这个变量，从而导致意料之外的行为。 我们来看一道超级经典的面试题，var a=a 的运算结果： 12345var a = a;console.log(a); //undefinedlet b = b;console.log(b); //ReferenceError: b is not defined 由于 var 定义的变量存在变量提升，因此 a 变量被提前定义，值为 undefined。再由 js 语法中运算符的计算顺序是从右到左，因此在右侧的 a 先进行运算，此时 a 的值为 undefined，因此左侧的 a 被赋值为 undefined。 对这么简单的代码，里面包含的过程就是这么复杂。 但是没必要啊，粗略一看这样的赋值行为就是不合理的，怎么能在没声明变量前就先使用了这个变量呢。于是 let 命令告诉了我们，再也不会有这样的事情了。 2. 解决闭包缺陷变得 so easy还是让我们再来看一道超级经典的面试题，求以下 a 数组中任意一个项目的值： 12345678var a = [];for (var i = 0; i &lt; 5; i++) &#123; (a[i] = function () &#123; return i; &#125;)();&#125;console.log(a[2]()); //5 很明显我们看到，这是一个由闭包引发的灾难，内部函数持续保持对 i 的引用导致最后取值的时候获得的都是已经被循环完成后的值了。 那么以前我们会怎么解决呢？很简单，会再加一层闭包，保持对当前 i 的引用，并立即执行掉： 12345678910var a = [];for (var i = 0; i &lt; 5; i++) &#123; (function(i)&#123; a[i] = function () &#123; return i; &#125; &#125;)(i);&#125;console.log(a[2]()); //2 或者干脆将函数移出循环体： 123456789101112var a = [];function fun(i) &#123; return function()&#123; return i; &#125;;&#125;for (var i = 0; i &lt; 5; i++) &#123; a[i] = fun(i);&#125;console.log(a[2]()); //2 看看，为了解决个这么小的问题，这代码一下就变得复杂了起来。 有了 let 命令，这一切问题都不存在了： 12345678var a = [];for (let i = 0; i &lt; 5; i++) &#123; (a[i] = function () &#123; return i; &#125;)();&#125;console.log(a[2]()); //2 const 命令const 命令又是另外一个用来声明变量的常用命令。const 声明一个只读的常量。一旦声明，常量的值就不能改变。 这个命令我感觉尤其在 nodejs 里面使用的多，包括定义端口呀、定义服务指令呀都需要用到它。 对于这个命令，我们只需要知道一点： const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 也就是说，我们不能改变使用 const 定义的基本数据类型，但定义的函数、数组、对象等引用类型里面的值我们还是可以随意更改的。 12345678const a = 1;a = 2; //TypeError: Assignment to constant variable.console.log(a);const b = [1, 2];b[0] = 2;b.push(3);console.log(b); //[ 2, 2, 3 ] 如果你连这点权利也不让这个变量使用的话，那真是太没人性了！（悄悄的告诉你，使用 Object.freeze() 函数吧，他会锁死引用对象，不让其中的数据增删改。：）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 学习笔记梳理 (2)]]></title>
    <url>%2Fposts%2F1312%2F</url>
    <content type="text"><![CDATA[上一节我梳理了一下闭包的概念，这些天各种学校的事情挺忙的，直到现在才有空余时间来写写博客这样杀时间的事儿。这一次整理一下原型链的那些事儿。 大家都知道在 JavaScript 的世界里，一切皆对象。而我们又知道，JavaScript 并不是完全的一门 OOP（面向对象编程）的语言，它是一门面向原型链编程的语言。综上我们可以得出，其实原型也是一个对象。这对我接下来要讲的内容的理解有至关重要的作用。 OOP 中一个最重要的特性就是继承，那 JavaScript 作为一门完全独立的语言自然也需要有这一特性，而 JavaScript 本身并没有类继承或者接口继承相关的概念，我们需要使用原型链来模拟这一过程。不多说，先上一个例子。 1234567891011121314151617function Person (name) &#123;this.name = name;&#125;function Father () &#123;&#125;Father.prototype = &#123; //Father 的原型 age: 50, home: ['Beijing', 'Shanghai']&#125;;var father = new Father();Person.prototype = father; //Person 的原型为 Father// 这样写的好处是子类如果更改了 prototype，那么更改的东西也是附加到 father 这个实例对象上的// 如果你直接写 Person.prototype = Father.prototype，// 那你对 Person 的 prototype 的任何修改都会同时修改 Father 的 prototype 这个例子中，我定义了一个父类构造函数 Father，和一个子类构造函数 Person。至于为什么用构造函数这么奇怪的模式来定义一个类的原因我认为完全可以下次再开一篇专门的文章来阐述，简单来说这个构造函数模式是 JavaScript 生成自定义原型链的一种模式。 好，那么接下来，重点来了。这里使用了父类构造函数的 prototype，这是个什么东东呢？在 JavaScript 里，对每一个函数，都自动会继承一个 prototype 的属性，指向了构造函数所继承的原型对象。 我之前说过，万物皆对象。函数当然也是一个对象，它当然也需要继承另一个对象，那么被函数对象继承的对象，就叫原型对象，在例子里面，他就叫做 Father.prototype。 原型对象，首先是一个对象呀。因此我在重写父类构造函数的原型对象的时候使用了字面量模式，也就是{……}的方法来指定一个对象。当然，你要这么书写也是对的： 12Father.prototype.age = 50;Father.prototype.home = ['Beijing', 'Shanghai']; 当然，它们之间会有一些差别，但就为对象赋值的情况他们的作用是等效的。 在之后呢，我们为父类创建了一个实例，并将子类构造函数的原型对象指向了这个实例，到此继承原型链完成。 啊啊啊不要问我为什么要这样继承了，这样做并不奇怪。首先我们知道函数的 prototype 必定指向一个 obj 对象，那么构造函数显然不能担当这一职责，只有被实例化的对象才能成为子类的原型对象。这里可以填入的对象有两个，一个是 father，另一个是 Father.prototype。那为什么不是后面这个呢？试试就知道了。 1Person.prototype = Father.prototype; 这行代码一敲完我就觉得非常的搞笑了，按自然语言的理解来看看，你的父亲等于你父亲的父亲！？？那你爸是你表哥咯？实际上呢，这样子的赋值语句也经常用到，只不过含义完全不同，这是继承自同一原型的两个不同子类，相当于兄弟节点，这好理解吧？ 这里要讲的是子类继承，因此接下来子类的构造函数的 prototype 自然也指向这个被实例化的原型对象。JavaScript 的语言逻辑就是这么奇怪又好有道理的样子。 好，接下来我要给子类实例化两个对象出来，分别是我和我弟弟。 12var person1 = new Person('成龙');var person2 = new Person('成风'); 前戏就讲到这里，接下来我们进入正题。基于原型到底有哪些特性。 简单赋值不会改变原型以及该对象的兄弟对象的属性，实例不能改变原型的基本值属性还是先举一个例子，比如我肯定没有我爸年纪那么大，因此我继承了所有属性后，我还应该要自己有一个年龄属性覆盖上去。 123person1.age = 20;console.log(person1.age); //20console.log(person1.__proto__.age); //50 子类改变了自己类内的属性（实质是覆盖，使用 delete 删去该属性后，仍然继承父类的值），但是这并不会影响父类中该属性的值。 这很好理解吧，你虽然天生遗传了你爸的基因，但是你自己上课外班学会了唱歌跳舞你爸总不会就自然学会了吧？ ps：这里说一说”proto“这个属性，ECMAScript5 中叫它 [prototype]，是每一个被实例化的对象都会被继承的属性，它的指向与该实例化对象的构造函数的 prototype 的指向相同，指向原型对象。 原型中引用类型的属性是共享的，实例对象能够修改原型对象中引用类型对象的属性引用类型是什么呢，这里涉及到 js 的基础知识了，在 JavaScript 中，数据类型一共有 7 种，分别是：Number, String, Boolean, Undefined, Null, Object, Function。其中基本数据类型共 5 种：Number, String, Boolean, Undefined, Null。而剩下的统称为引用类型，包括 obj 对象，函数和数组。究其原理呢，是因为引用类型并不实际占用栈内存而只是其中的基本类型数据占用，引用类型仅用堆内存提供指针指向他们，于是就有了一个非常有趣的现象：基本数据类型永远无法被改变，而引用类型可以，原因就是引用类型只需要修改指针，指向另外一个基本类型数据就可以了呀。 扯远了，总而言之，引用类型并不是保存值的，而只是一个指针堆，或者说是基本数据的引用堆，因此我们修改实例对象中的引用类型对象的时候，原型对象中引用类型对象的属性也会同时被修改，因为他们本来就指向的同一个内存块嘛。 还是举一个例子加深一下理解。 1234console.log(person1.home); //[ 'Beijing', 'Shanghai' ]person1.home[0] = 'Shenzhen';console.log(father.home); //[ 'Shenzhen', 'Shanghai' ]console.log(person1.home); //[ 'Shenzhen', 'Shanghai' ] 本来啊，你们一家都住在北京，但是你长大了，跑到深圳去工作了，还在那里买了房子住下了，于是你的住址被迁移到了深圳。但是同时，你必须要和爸妈住在一起，拥有相同的住址（引用类型嘛，指向同一个地址位置），因此你爸也吧户口改了，迁移到了深圳。 还是不能理解？哎，我也觉得有点牵强，还是不能随便类比，那还是来个基础编程吧。我们如果要让 person1 拥有一个 home 的数组属性，并且它的第 0 号元素为’Shenzhen’，该怎么办呢？ 12var person1 = &#123;&#125;;person1.home[0] = 'Shenzhen'; 这样行得通吗？你可以自己试试，显然是不可以的，这里会报错：’home’ not defined。它连 home 这个属性都还没有呀，怎么能给 home 的第一个元素赋值呢？所以我们应该这样写： 123var person1 = &#123;&#125;;person1.home = [];person1.home[0] = 'Shenzhen'; 先把 home 属性给它定义出来自然就不会有问题啦。其实呀，这跟我们的问题是一样一样的。person1 中，并没有一个名为 home 的属性，因此 person1.home[0] 是不行的。 至于为什么没有报错呢，是因为 js 的原型链向上搜索机制：如果查找一个对象的属性没有找到，搜索会继续在继承的对象中搜索，如果还没有则逐级向上搜索直到找到为止。而此时，虽然 person1 中没有这个属性，但它继承的父类中有 home 这个属性，于是系统会认为找到了这个属性，并随着你的赋值语句更改了父类中该属性的值。 再来举一个例子。我们开始说了，给子类改写属性的实质是一种覆盖。删除实例的属性之后，就会取消了子类的属性覆盖，这个时候再需要调用该对象的这个属性时，就会从原型链上一层一层找到头，直到找到为止。 123console.log(person1.home); //[ 'Shenzhen', 'Shanghai' ]delete person1.home;console.log(person1.home); //[ 'Beijing', 'Shanghai' ] 累死了，现在总该明白这西方的一套是怎么回事了吧？如果这样还不明白的话，我也只能说“不了不了“。 改写构造函数的原型，改写的属性能够动态反应到实例化的对象中在定义父类完毕后，你突然想补充一点，比如说：我弟和我都是男的啊！你爸那一代身份证可能没考虑到性别这一属性，那你爸和你以及你弟怎么办呢，总不能性别模糊吧？ 办法还是有的，就是改写子类的原型对象。 12345Person.prototype.sex = 'male';// 等同于 father.sex = 'male'，也等同于 person1.__proto__.sex = 'male'// 这里不能写成：Father.sex = 'male'; 这是因为面向对象编程的规则：对象（实例）才是属性的拥有者。console.log(person1.sex); 'male'console.log(father.sex); 'male' 其实呀，这个 Person.prototype 就是 father，因此呢，你如果非要定义 father.sex = ‘male’ 也不是不可以，仅在此题中实现的效果是相同的。但是这不符合 JavaScript 规范，也是普遍面向对象编程的规则：对象（实例）才是属性的拥有者。 改写原型对象后呢，子类也会动态地继承这些属性，因此这一招改原型大法还是非常的常用的。 4. 重写构造函数的原型，使子类继承一个新的原型比如呀，你有一个同母异父的弟弟，他的什么东西都和你跟你爸爸不像，显然啊，他跟你爸并没有什么血缘关系嘛，因此它没有任何属性是从你爸那里继承的呀。 重写原型其实很简单，直接对 Person.prototype 附一个不同字面量对象即可。由于重写原型会使得原有的继承全部更换，因此不是特殊用途的情况下使用的很少。 1234567891011Person.prototype = &#123; age: 40, home: ['Guangzhou', 'Changsha']&#125;;var person3 = new Person('黄龙');// 这个时候 Person 的原型已经完全变成了另一个对象，于是我连这个家伙的姓氏都改掉了~console.log(person3.home);console.log(person3.age);console.log(person1.home);console.log(person1.age); 你这个没有什么血缘关系的弟弟有一个更年轻的爸爸，住址也跟你完全不同，其实跟你完全就是两个世界的人了嘛，于是我连这个家伙的姓氏都改掉了~ 唔，大概我能总结出来的特性就这么多啦，想到再补充吧~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 学习笔记梳理 (1)]]></title>
    <url>%2Fposts%2Fe312%2F</url>
    <content type="text"><![CDATA[最近在梳理关于 js 一些原理层次的东西，感觉学的有点乱，是时候整理沉淀一下记录成文字了。在我看来，最难理解的核心就两点，一是对闭包的理解，二是对原型链的深入。在这里我先说说闭包。 大家都知道闭包是 JavaScript 的难点，首先我们得知道什么是闭包？ 《JavaScript 高级程序设计）》中是这样说的： 闭包就是指有权访问另一个函数中的变量的函数。 《JavaScript 权威指南》这样定义： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包”。 简单的来说呢，这个牵扯到 JavaScript 作用域的问题。 在 es6 以前，js 其实只有一种作用域，那就是函数级作用域，也就是说任何的私有变量或者函数必须包裹在函数内才能导致不产生全局的变量污染。当然 es6 以后出现的 let（）也有这个功能了，关于 let 的用法可参考 《ECMAScript 6 入门》中第二章。这里暂且按住不表。 那么闭包是什么呢，闭包简单来说就是一个特殊的函数，能在自己的作用域里调用其他函数中的私有变量或者私有函数的特殊函数。通俗的来讲就是闭包就还一个嵌套在其他函数里的函数，其中可以引用外部函数的参数和变量，这些参数和变量不会被 js 的垃圾回收机制自动回收，且变量和参数不会对外部的作用域造成污染。 说完了是什么，那么为什么要创建闭包，它又有什么功能呢？ 在我看来好处有三点： 提供访问函数中的私有变量的入口举个例子： 1234567891011121314function Obj()&#123; var privateVar = 1; function privateFunc() &#123; return privateVar; &#125; //特权方法（闭包访问私有变量和私有函数并传递给外界） this.publicFunc = function() &#123; privateVar++; return privateFunc(); &#125;;&#125;var obj = new Obj();console.log(obj.publicFunc()); 这里就可以看到一个闭包就能把函数中的私有变量以及私有函数的值取出到了外部作用域。 作用域隔离闭包的另一个作用是防止变量污染，限制向全局作用域中添加过多的变量和函数。 12345678910function fun1() &#123; var a = 1; (function fun2() &#123; var a = 2; a += 1; console.log(a); &#125;)(); console.log(a);&#125;fun1(); 我们可以看到，在 fun2() 这个闭包里定义的新的变量并进行更改时，并不会对外部变量造成污染。 在循环中包含函数且该函数中使用了遍历数据记得在知乎上看到一道面试题，地址搜不到了，大体说是要利用循环给一个数组绑定数组索引对应的值，我先列一个错误的写法： 12345678910111213function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 5; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]());&#125; 这样并不能得到想要的结果，因为 result[i] 绑定的是一个函数，但是当场并不执行，等到 console.log() 的时候才想到去执行，并调用 i，但此时 i 早已结束了循环，此时的值为 5，因此，输出为 5 个 5，而不是 0-4。 那么需要怎么改才能达到想要的结果呢，这个时候，闭包闪亮登场了。 123456789101112131415function _createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 5; i++)&#123; (function(i) &#123; result[i] = function()&#123; return i; &#125;; &#125;)(i); &#125; return result;&#125;var funcs = _createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]());&#125; 加一个 IIFE，并将遍历参数传了进去，一切都不一样了，为什么呢？ 这就又得提到垃圾回收机制了，由于闭包函数传入了外部函数的参数变量 i，因此在 var funcs = _createFunctions(); 这一句之后、_createFunctions() 被销毁，但是函数变量 i 不会随着外部函数_createFunctions() 的销毁而回收，因为闭包能够保持对当前 i 的引用，于是在真正调用时，执行闭包中的 i 为当时循环遍历到的数值，从而输出了 0-4. 最后，我们再来做道课后习题来巩固一下吧。更改下面的代码，使得它能够每个一秒分别输出 0-4: 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; 我想到了两个利用闭包的解法 法一： 123456789(function fun2() &#123; for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;,1000*(i+1)); &#125;)(i); &#125;&#125;)(); 法二： 12345678(function _fun2(i) &#123; if (i &lt; 5) &#123; setTimeout(function() &#123; console.log(i); _fun2(++i); &#125;, 1000); &#125;&#125;)(0); 原理我就不细说啦，自己琢磨琢磨会有更多收获的哦。 啊，第一次尝试 markdown 写博客，花了好多时间啊，那原型链的知识就留到下次在整理吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 判断及修改 checked 状态的方法]]></title>
    <url>%2Fposts%2F634e%2F</url>
    <content type="text"><![CDATA[表单中经常需要使用单选框或多选框来让用户选择，而我们经常使用 jQuery 来判断或改变选项中 checked 的状态，但是由于 jQuery 版本不同，判断的方法也不太一样，这个坑点在这里记录一下。 123.attr("checked"): //1.6+返回："checked"或"undefined"; 1.5 以下返回：true/false.prop("checked"): //1.6+: true/false.is(":checked"): //所有版本：true/false，注意冒号 jQuery 赋值 checked 的几种写法： 所有的 jQuery 版本都可以这样赋值： 12$("#cb1").attr("checked","checked");$("#cb1").attr("checked",true); jquery1.6+: prop 的 4 种赋值： 123456$("#cb1″).prop("checked", true); $("#cb1″).prop(&#123; checked: true &#125;);$("#cb1″).prop("checked", function() &#123; return true; //函数返回 true 或 false&#125;);$("#cb1″).prop("checked", "checked");]]></content>
      <categories>
        <category>常见问题集锦</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构之我见]]></title>
    <url>%2Fposts%2F8158%2F</url>
    <content type="text"><![CDATA[最近在看一些软件工程和构建方面的书籍。俗话说，书读百遍，其义自见，看得多了，自然也就有一些知识可以拿得出手分享一二了。 由于我在写代码的过程中往往很追求代码的优雅和简洁，因此我着重阅读了代码重构方面的知识，现在对代码的重构也算略有体会了。接下来我将结合我所吸收到的知识与我自己的一些理解和观点来阐述一下代码重构的艺术。 先来说说代码重构是什么吧。 重构一般是指把代码优化，便于再修改和开发的一种过程。重构并不是说，我把原来的代码全部推翻，重改架构，不是的，那叫重写，不叫重构。重构更像是装修，重写是推倒重盖，不知道这样解释是不是比较形象了呢？ 那我们为什么需要重构呢？ 一般的底层码农编程理念不够扎实，加上，分工合作的原因，总会写出一些烂代码，难以修改，这才需要进行重构。 我要着重提出的是：重构不是万能的，更不是用来装逼的！接下来我想解释一下在什么时候我们才需要进行重构，以及重构究竟是为了做什么的。 因为我看到网上总是有很多人标榜我重构代码几千行改到几行之类的，我觉得那是噱头，为了装逼而装逼的。重构的首要宗旨并不是为了简化代码的，重构的本质是为了清除烂代码的，只是在代码层面做修改，并不触动架构。也就是说，你原来的架构就很烂的话，重构并不会有所改善重构以后，代码效率并不会比原来过程型的代码快，甚至更慢。 那么对于需要重构的代码，我们该如何进行重构呢？ 重构最简单的思路一般有两个：分，合。 分指的是把现有的业务逻辑简化，并不是实际简化，而是从代码结构上简化比如我一个功能需要 1000 行代码，干的 10 个事情，现在我把这 10 个事情都分出去，做成 10 个模块，然后做一个封装，这样，最上层的代码量就急剧减少了，逻辑也变的简单了。但是这不是随便分的，一般一个基础的底层处理的模块，一个模块只做一件事。什么是底层处理模块，比如分割字符串这个功能，就是底层模块，可以让任意模块调用，而且比较简单，这就是基础底层模块的要求。由于把一些公共的模块分离了，代码中直接调用这些模块，简化了代码，也减少了代码量。一般来说，代码如果超过一屏，就考虑尽量分离模块了。 一般说来，重构都是基于面向对象框架下的。因为一般过程型的代码，优化比较麻烦，不是面向对象的，分解起来会比较麻烦。一般来说，分层分的越细，结构越明晰，但是代码效率越差，因为继承封装可能比较多的缘故，所以一般要做一个平衡。公共调用的模块或者类，使用比较多的模块，一定要分出来。 举个例子吧，比如我要写一个自定义的格式化时间的函数，能够把一系列的时间函数，能用到的集合在一个类里。比如格式化时间函数，比如计算时间差的函数，如果就是孤单的一个函数，可以放到一个基类里。我觉得最好所有的函数最好都封装在类中，一个没有单独函数的框架，重用性一般能大大提高。基于类的好处，是可以轻易定位函数所在的位置，一般类名和文件名是需要保持一致的，看到类的前缀，就可以定位到类的名称和文件，但是如果是单独的函数，定位起来就比较麻烦。 重构的好处和意义，就是帮助程序拥有一套良好的规范。我们都知道，一个好的框架，需要有公共函数，还需要有私有函数，不然容易产生函数名重复等种种问题。一直执行一套良好的规范的程序，一定是比较容易维护和比较容易看懂的。不遵守规范，即使重构，难度也比较大，一些质量相当差的代码甚至没有改的价值，重构纯属浪费时间，所以重构前，需要判断，代码用不用重构，太差的话不如重写了。 极限编程流派中有一个观点，就是代码质量不重要，开发速度最重要。我也觉得这样是有道理的，因为先做出成果再 debug 给我们的正向激励是大得多的。并且就我现在所处的学校环境来说，同学们写出来的代码还不至于会发生差到只能重写如此这般的惨剧，有一些代码甚至还十分的巧妙和效率。但是经过我上网浏览到的一些奇葩段子，我才发现，原来世界这么大。 说有一个程序员用一天的时间写了一个刷单程序，需要展示出需要刷单的列表。这个程序并不复杂，但不知道为什么，执行起来特别慢，一个页面需要几十秒甚至刷新不出来然后贴出了他的代码。我看了下代码，这个程序一次刷新就需要嵌套查询数据库上万次！一个列表查询上万次！列表要显示需要刷单的人信息，需要显示已经已经接单的人信息，有一些附加信息吧，结果，刷单的表没有冗余，需要关联用户表，他都是嵌套查询，所以刷单列表里嵌套查询用户信息，用户等级又是一个表，所以用户信息里嵌套查询等级名称，这样几十种数据嵌套来嵌套去，居然一个页面查询上万次！ 高尔基曾经说过：好程序的优点大致相同，烂程序的缺点也大致相同。（不他并没有这么说过【捂脸】）比如： 不断重复的代码。 举个例子，对数据库的 CURD 操作，纯过程代码，如果没有分离出模块来，那每调用一次就需要再写一次相同的代码。而这还不是最关键的。我改了一处的代码，势必要改另外所有地方的代码，因为逻辑一致啊。但是分离出去模块后，改一处就可以了，减少了工作量，代码量也减少了。 人为的刻意复杂 很多人爱秀技术爱装逼，把一个逻辑搞的特别复杂。我继续拿添加商品的逻辑做例子吧。添加商品，需要添加 id，需要添加搜索条件，需要同步更新缓存，需要生成页面，把这一堆逻辑写到一个页面里，成百上千行代码，怕不怕？尤其是多层嵌套的 if else，嵌套上三层五层，估计看着就晕。 再说一个段子吧：有个程序员看到一段代码，大骂起来，这是哪个傻逼写的代码啊，这么乱啊！回头仔细看了下，是自己写的。 有的时候这确实是个真命题：你写的代码你不一定能看的懂。 对于如何针对嵌套，如 if else 之类的，去优化代码结构，我自己是这么做的：单层的 if else，直接写就可以，短逻辑直接用三元表达式（a?b:c），而不是 if。长一点的简单逻辑，直接用数组表示。再复杂一点的，用 switch 语句，至于更复杂的，可以利用函数或者设计模式的方式解决。总的来说，嵌套一般不超出 2 层，一旦超出，就必须引入其他解决方式。要养成“看到 if 就不舒服的病”。分的模块多了，有的时候怕也是不好找，所以必须要让每个模块名称都是望文知意。必须要养成英文单词的驼峰式命名或者其他统一的命名规范，绝对不可以用拼音或者是简拼。还是举刚才的例子。zdydgshsj()，鬼才看得出来这是什么函数；zidingyidegeshishijianhanshu()，就算你看的懂，但你多次调用这个函数不觉得手抽筋么？customFormatTime() 相对来说看到就会明白意思了，或者是 customizeFormatTime() 更正规些，函数写多了后，my_FormatTime() 更有利于归类些。但是不管怎么样，总算能看明白含义。如果你还是嫌函数名过长的话，可以使用部分通用的英文缩写。比如表单相关的，frm 可以作为前缀；数据库相关的，db 可以做前缀；文件相关的，file 可以做前缀。这样整体看起来就更美观和易用了。 但是重构也绝对不是一见到长代码就必须要拆了。如果是一片孤单的代码段，没有引用，没有公共模块，简单的一个逻辑，但是代码段比较长，就没有必要分了，因为它和别的模块，别的方法都没有交集，自然没有优化的必要了。总的来说，重构的经验很多都来自于对编程的深入理解，理解越深，写的代码越优雅，执行的效率越高。 啊，头一次写长文干货，一口气写了这么多字，好鸡冻、(≧▽≦)/]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
</search>
